<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
<p>فصل ۴ موقعیت، موقعیت، موقعیت: ثبات‌ها، آدرس‌دهی حافظه و دانستن اینکه
    چیزها کجا هستند</p>
<p>من این کتاب را تا حد زیادی به این دلیل نوشتم که نتوانستم یک متن
    مقدماتی درباره زبان اسمبلی بیابم که حتی اندکی آن را قابل احترام بدانم.
    تقریباً تمامی کتاب‌های مربوط به اسمبلی با معرفی مفهوم مجموعه دستورالعمل‌ها
    شروع می‌کنند و سپس دستورالعمل‌های ماشینی را یکی‌یکی توضیح می‌دهند. این کار
    احمقانه است و نویسندگان چنین کتاب‌هایی باید حسابی تنبیه شوند. حتی اگر شما
    هر دستورالعمل موجود در یک مجموعه دستورالعمل را یاد بگیرید، هنوز هم زبان
    اسمبلی را یاد نگرفته‌اید.</p>
<p>شما حتی نزدیک به آن هم نشده‌اید.</p>
<p>اعتراض ساده‌انگارانه‌ای که می‌گوید کار یک CPU اجرای دستورالعمل‌های ماشینی
    است، به سادگی قابل رد کردن است: CPU دستورالعمل‌های ماشینی را زمانی اجرا
    می‌کند که آن‌ها را در دست داشته باشد. کار واقعی CPU و چالش واقعی زبان
    اسمبلی در یافتن دستورالعمل‌ها و داده‌های مورد نیاز در حافظه است. هر ابلهی
    می‌تواند دستورالعمل‌های ماشینی را یاد بگیرد. مهارت در زبان اسمبلی درک عمیق
    آدرس‌دهی حافظه است. باقی همه جزئیات است—و آن هم جزئیات آسان.</p>
<p>لذت مدل‌های حافظه</p>
<p>آدرس‌دهی حافظه کاری دشوار است، و این دشواری زمانی بیشتر می‌شود که
    بدانیم در خانواده CPUهای اینتل/AMD، تعداد قابل توجهی روش‌های مختلف برای
    آدرس‌دهی حافظه وجود دارد. هر کدام از این روش‌ها یک مدل حافظه نام دارند.
    برای اعضای جدیدتر خانواده اینتل، سه مدل حافظه اصلی و تعدادی تغییرات جزئی
    بر روی آن سه مدل—به خصوص مدل میانی—وجود دارد.</p>
<p>در برنامه‌نویسی برای لینوکس ۶۴ بیتی، عملاً محدود به یک مدل حافظه هستید،
    و وقتی کمی بهتر آدرس‌دهی حافظه را درک کنید، بسیار از این موضوع خوشحال
    خواهید شد. با این حال، من هر سه مدل را با جزئیات توضیح خواهم داد، حتی
    اگر دو تای قدیمی‌تر اکنون به موزه سپرده شده باشند. از بحث آن نمونه‌های
    موزه‌ای نگذرید. همان‌طور که مطالعه فسیل‌ها برای درک تکامل موجودات زنده بر
    درک موجودات امروزی می‌افزاید، دانستن کمی درباره مدل‌های حافظه قدیمی اینتل
    درک شهودی‌تری از مدل حافظه‌ای که احتمالاً از آن استفاده می‌کنید، به شما
    می‌دهد.</p>
<p>قدیمی‌ترین و اکنون باستانی‌ترین مدل حافظه، حالت واقعی مدل تخت (real
    mode flat model) نام دارد. این مدل کاملاً فسیل شده است، اما نسبتاً سرراست
    و ساده. مدل حافظه قدیمی‌تر (و اکنون بازنشسته) حالت واقعی و بخش‌بندی شده
    (real-mode segmented model) است. احتمالاً نفرت‌انگیزترین چیزی است که در هر
    نوع برنامه‌نویسی (اسمبلی یا غیره) یاد می‌گیرید. (اگر شما تازه در سال ۲۰۲۳
    شروع می‌کنید، به احتمال زیاد از یادگیری آن معاف هستید.) در اوج دوران
    برنامه‌نویسی تحت DOS، از مدل بخش‌بندی شده حالت واقعی استفاده می‌شد و به
    همین دلیل مقدار زیادی شربت پپتو بیسمول برای آرام کردن دل و روده
    برنامه‌نویس‌ها فروخته شد. جدیدترین مدل حافظه حالت محافظت شده تخت
    (protected-mode flat model) است که در دو گونه ۳۲ بیتی و ۶۴ بیتی عرضه
    می‌شود. این مدل حافظه پشت سیستم‌عامل‌های مدرن مانند ویندوز
    2000/XP/Vista/7/8/10/11 و لینوکس است. دقت کنید که حالت محافظت شده تخت
    تنها بر روی CPUهای ۳۸۶ و جدیدتر که از معماری IA-32 یا x64 پشتیبانی
    می‌کنند، در دسترس است. پردازنده‌های 8086، 8088 و 80286 از آن پشتیبانی
    نمی‌کنند. ویندوز 9x در جایی بین این مدل‌ها گیر کرده بود و فکر نمی‌کنم جز
    افراد مایکروسافت، کسی واقعاً همه پیچیدگی‌های آدرس‌دهی حافظه در آن را فهمیده
    باشد—و شاید حتی آن‌ها هم نه. خوشبختانه، اگرچه هنوز یک فسیل نشده، اما قطعاً
    مرده و مدفون است.</p>
<p>من در این کتاب یک استراتژی دارم و قبل از این که وارد بحث شویم، آن را
    بیان می‌کنم: ابتدا توضیح می‌دهم آدرس‌دهی حافظه در حالت واقعی مدل تخت که در
    DOS در دسترس بود، چگونه کار می‌کند. یادگیری آن به طرز شگفت‌انگیزی آسان
    است. مدل بخش‌بندی شده حالت واقعی را تا حدی توضیح خواهم داد، چون ممکن است
    گاه و بی‌گاه در جاهایی با آن برخورد کنید و نیاز داشته باشید آن را بفهمید،
    حتی اگر هرگز یک خط کد برای آن ننویسید. کار واقعی که امروزه و در آینده
    انجام می‌شود در «حالت بلند» ۶۴ بیتی است، چه برای ویندوز، لینوکس یا هر
    سیستم‌عامل ۶۴ بیتی حفاظت شده دیگر. یادگیری خود مدل بسیار آسان است—بخش سخت
    آن این است که سعی کنید مانند یک کامپایلر C فکر کنید در حالی که کد شما به
    کتابخانه‌هایی متصل می‌شود که از آن پشتیبانی می‌کنند، که این موضوع ربط
    چندانی به مدل حافظه ندارد. نکته کلیدی در تمام این ماجرا این است: مدل تخت
    در حالت واقعی شبیه مدل تخت محافظت شده در ابعاد کوچک‌تر است.</p>
<p>یک مدل تخت بزرگ وجود دارد و یک مدل تخت کوچک. اگر شما مدل تخت حالت
    واقعی را درک کنید، با مدل تخت حفاظت شده هم هیچ مشکلی نخواهید داشت. آن
    موجود مزاحم وسطی (مدل بخش‌بندی شده) صرفاً هزینه‌ای است که باید بپردازید تا
    خود را یک استاد واقعی در آدرس‌دهی حافظه بدانید.</p>
<p>پس بیایید ببینیم این چیزهای دیوانه‌وار چگونه کار می‌کنند.</p>
<p>۱۶ بیت برای شما ۶۴ کیلوبایت می‌خرد</p>
<p>در سال ۱۹۷۴، سالی که من از کالج فارغ‌التحصیل شدم، شرکت اینتل CPU 8080
    را معرفی کرد و عملاً ریزمحاسبه‌گرها را ابداع کرد. (بله، من یک آدم مسن
    هستم، اما خوشبختانه حس تاریخی دارم—به لطف اینکه بخش زیادی از آن را زندگی
    کرده‌ام.) 8080 در آن زمان پدیده‌ای داغ و جالب بود. من یکی از آن‌ها را داشتم
    که با سرعت ۱ مگاهرتز کار می‌کرد و برای پردازش کلمات (تایپ متن) که عمده
    کار من بود، بسیار کارآمد بود.</p>
<p>8080 یک CPU هشت بیتی بود، به این معنا که در هر لحظه ۸ بیت اطلاعات را
    پردازش می‌کرد. اما این CPU دارای ۱۶ خط آدرس بود. «بیتی بودن» یک CPU—یعنی
    پهنای ثبات‌های عمومی آن چند بیت است—مهم است، اما از نظر من معیار بسیار
    مهم‌تر توانایی CPU در مدیریت چند خط آدرس در یک عملیات است. در سال ۱۹۷۴،
    ۱۶ خط آدرس تهاجمی به نظر می‌رسید، چون حافظه بسیار گران بود و اغلب ماشین‌ها
    در نهایت ۴ یا ۸ کیلوبایت حافظه داشتند (به یاد داشته باشید که یعنی ۴۰۰۰
    یا ۸۰۰۰ بایت)، و بعضی حتی کمتر.</p>
<p>۱۶ خط آدرس ۶۴ کیلوبایت حافظه را آدرس‌دهی می‌کند. اگر در مبنای دودویی
    بشمارید (که کامپیوترها همیشه این کار را می‌کنند) و خود را به ۱۶ ستون
    دودویی محدود کنید، می‌توانید از ۰ تا ۶۵,۵۳۵ بشمارید. (اصطلاح رایج «64 KB»
    مخفف عدد ۶۵,۵۳۶ است.) این بدان معنی است که هر یک از ۶۵,۵۳۶ مکان حافظه
    می‌تواند آدرس منحصربه‌فرد خود را از 0 تا ۶۵,۵۳۵ داشته باشد.</p>
<p>طرح آدرس‌دهی حافظه در 8080 بسیار ساده بود: شما یک آدرس ۱۶ بیتی را روی
    خطوط آدرس قرار می‌دادید و مقدار ۸ بیتی ذخیره شده در آن آدرس را دریافت
    می‌کردید. توجه کنید که هیچ رابطه ضروری بین تعداد خطوط آدرس در یک سیستم
    حافظه و اندازه داده ذخیره شده در هر مکان حافظه وجود ندارد! 8080 در هر
    مکان ۸ بیت ذخیره می‌کرد، اما می‌توانست ۱۶ یا حتی ۳۲ بیت هم در هر مکان
    ذخیره کند و همچنان از ۱۶ خط آدرس استفاده کند.</p>
<p>محبوب‌ترین سیستم‌عاملی که با 8080 استفاده می‌شد، CP/M-80 بود. CP/M-80
    کمی غیرعادی بود چون در بالای حافظه نصب می‌شد—گاهی به این دلیل که در ROM
    قرار می‌گرفت، اما بیشتر برای این که از سر راه برنامه‌های گذرا کنار برود؛
    برنامه‌هایی که (برخلاف سیستم‌عامل) فقط در صورت نیاز در حافظه بارگذاری و
    اجرا می‌شدند. وقتی CP/M-80 یک برنامه را از دیسک برای اجرا می‌خواند، آن را
    در حافظه پایین، در آدرس 0100h بارگذاری می‌کرد—یعنی ۲۵۶ بایت بالاتر از
    پایین‌ترین قسمت حافظه. اولین ۲۵۶ بایت حافظه پیشوند بخش برنامه (PSP)
    نامیده می‌شد و حاوی اطلاعات مختلف و همین‌طور یک بافر حافظه برای
    ورودی/خروجی دیسک برنامه بود. اما کد اجرایی خودش تا آدرس 0100h شروع
    نمی‌شد.</p>
<p>من مدل حافظه 8080 و CP/M-80 را در شکل 4.1 نشان داده‌ام.</p>
<p>(شکل 4.1: مدل حافظه 8080)</p>
<p>مدل حافظه 8080 همان‌طور که با CP/M-80 استفاده می‌شد، ساده بود و مردم
    زیاد از آن استفاده می‌کردند. بنابراین، وقتی اینتل اولین CPU ۱۶ بیتی خود،
    یعنی 8086 را ساخت، می‌خواستند انتقال نرم‌افزارهای قدیمی CP/M-80 از 8080 به
    8086 را آسان کنند—کاری که ما آن را «پورت کردن» می‌نامیم. یکی از راه‌های
    انجام این کار این بود که مطمئن شوند یک سیستم آدرس‌دهی ۱۶ بیتی مانند 8080
    همچنان کار می‌کند. بنابراین، حتی با این که 8086 می‌توانست ۱۶ برابر 8080
    حافظه آدرس‌دهی کند (16 × 64KB = 1MB)، اینتل 8086 را طوری تنظیم کرد که یک
    برنامه می‌توانست داخل یک بخش ۶۴ کیلوبایتی از آن ۱ مگابایت حافظه به طور
    کامل اجرا شود، درست مثل یک سیستم حافظه کوچک‌تر 8080.</p>
<p>این کار با استفاده از ثبات‌های بخش (segment registers) انجام شد—به‌طور
    اساسی اشاره‌گرهایی که در ثبات‌های CPU قرار دارند و به جایی در حافظه اشاره
    می‌کنند که اشیا از آنجا شروع می‌شوند، خواه این اشیا داده باشند، کد اجرایی
    یا چیز دیگر. بعداً درباره ثبات‌های بخش بیشتر صحبت خواهم کرد. فعلاً کافی است
    به آن‌ها به چشم اشاره‌گرهایی فکر کنید که نشان می‌دهند برنامه‌ای که از دنیای
    8080 پورت شده، در کجای مگابایت حافظه 8086 آغاز شود. شکل 4.2 را
    ببینید.</p>
<p>(شکل 4.2: مدل حافظه 8080 درون سیستم حافظه 8086)</p>
<p>وقتی از 8086 و 8088 صحبت می‌کنیم، چهار ثبات بخش وجود دارد که بعداً مفصل
    با آن‌ها کار خواهیم داشت. اما برای اهداف شکل 4.2، ثباتی به نام CS را در
    نظر بگیرید—که مخفف کد سگمنت است. دوباره، این یک اشاره‌گر است که به
    موقعیتی در داخل مگابایت حافظه 8086 اشاره می‌کند. این موقعیت نقش نقطه شروع
    یک ناحیه ۶۴ کیلوبایتی از حافظه را ایفا می‌کند که یک برنامه تبدیل شده از
    CP/M-80 می‌تواند با خوشحالی در آن اجرا شود.</p>
<p>این فکر در کوتاه مدت بسیار عاقلانه بود—و در بلندمدت فاجعه‌بار. در طی
    یکی دو سال، هر تعداد برنامه CP/M-80 به 8086 منتقل شد. مشکلات زمانی شروع
    شد که برنامه‌نویسان تلاش کردند برنامه‌های کاملاً جدیدی بنویسند که هرگز با
    8080 کار نکرده بودند و نیازی به مدل حافظه بخش‌بندی شده نداشتند. اما چه
    می‌شد کرد—مدل بخش‌بندی شده معماری 8086 را تحت سلطه داشت. برنامه‌هایی که
    نیاز به بیش از ۶۴KB حافظه در یک زمان داشتند، مجبور بودند حافظه را در
    واحدهای ۶۴ کیلوبایتی استفاده کنند و بین این واحدها با تغییر مقادیر در
    ثبات‌های بخش جابه‌جا شوند.</p>
<p>این یک کابوس بود. خبر خوب اینکه دیگر هیچ کس مگر علاقه‌مندان به
    فناوری‌های قدیمی مجبور نیست آن را به کار گیرد. اما یک دلیل خوب برای
    یادگیری آن وجود دارد: درک نحوه کار آدرس‌دهی حافظه بخش‌بندی شده حالت واقعی،
    درک مدل‌های تخت امروزی را برای شما آسان‌تر می‌کند و در این فرآیند ذات
    CPUهای امروزی را بهتر درک خواهید کرد.</p>
<p>ماهیت یک مگابایت</p>
<p>در حالت واقعی بخش‌بندی شده، CPUهای x86 می‌توانند تا یک مگابایت حافظه را
    مستقیماً آدرس‌دهی کنند. به این حافظه، حافظه حالت واقعی هم گفته می‌شود.
    همان‌طور که در فصل ۳ به طور خلاصه اشاره کردم، یک مگابایت حافظه دقیقاً ۱
    میلیون بایت نیست، بلکه ۱,۰۴۸,۵۷۶ بایت است. باز هم، مانند اصطلاح «64 KB»،
    یک مگابایت در مبنای ۱۰ گرد درنمی‌آید، چون کامپیوترها در مبنای ۲ کار
    می‌کنند. آن ۱,۰۴۸,۵۷۶ بایت در مبنای ۲ برابر 100000000000000000000B است.
    این همان 2^20 است، نکته‌ای که به زودی به آن بازخواهیم گشت. نوشتن عدد
    100000000000000000000B بسیار جاگیر است، بنابراین بهتر است آن را در مبنای
    ۱۶ (هگزادسیمال) که سازگارتر و فشرده‌تر است بنویسیم. کمیت 2^20 معادل 16^5
    است و در هگزادسیمال به صورت 100000H نوشته می‌شود. (اگر همچنان مباحث
    مبناها برایتان گیج‌کننده است، توصیه می‌کنم دوباره سری به فصل ۲ بزنید، چه
    قبلاً آن را خوانده باشید چه نه.)</p>
<p>حالا، یک سؤال پیچیده و بسیار حیاتی: در یک بانک حافظه دارای 100000H
    بایت، آدرس آخرین بایت حافظه چیست؟ پاسخ 100000H نیست. سرنخ در سمت دیگر
    این سؤال است: آدرس اولین بایت حافظه چیست؟ پاسخ آن ۰ است. کامپیوترها
    همیشه از ۰ شروع به شمارش می‌کنند. این دوگانگی بارها و بارها در
    برنامه‌نویسی رخ می‌دهد. آخرین مورد در یک ردیف چهار تایی، مورد شماره ۳ است،
    چون اولین مورد در یک ردیف چهار تایی، شماره ۰ است. بشمارید: 0, 1, 2,
    3.</p>
<p>آدرس یک بایت در بانک حافظه صرفاً شماره آن بایت از ابتدا (صفر) است. این
    بدان معناست که بالاترین آدرس در یک بانک حافظه ۱ مگابایتی برابر است با
    100000H منهای یک، یعنی 0FFFFFH. (صفر اولیه از نظر ریاضی ضروری نیست، اما
    به آَسمبلر کمک می‌کند که گیج نشود. عادت کنید برای هر عدد هگزا که با A تا F
    شروع می‌شود، یک صفر اولیه بگذارید.)</p>
<p>پس آدرس‌های یک مگابایت حافظه از 00000H تا 0FFFFFH است. در مبنای
    دودویی، این محدوده برابر است با 00000000000000000000B تا
    11111111111111111111B. این تعداد زیادی بیت است—دقیقاً ۲۰ بیت. اگر به شکل
    3-3 در فصل ۳ نگاهی بیندازید، می‌بینید که یک بانک حافظه یک مگابایتی ۲۰ خط
    آدرس دارد. یکی از این ۲۰ بیت آدرس به هر یک از آن ۲۰ خط آدرس اختصاص
    می‌یابد، بنابراین هر آدرسی که به صورت ۲۰ بیتی بیان شود، دقیقاً یک بایت از
    آن ۱,۰۴۸,۵۷۶ بایت حافظه را مشخص می‌کند.</p>
<p>این همان یک مگابایت حافظه است: یک آرایش از تراشه‌های حافظه درون
    کامپیوتر، که با یک گذرگاه آدرس ۲۰ خطی به هم متصل شده‌اند. یک آدرس ۲۰ بیتی
    به آن ۲۰ خط آدرس داده می‌شود تا یک بایت از میان یک مگابایت را مشخص
    کند.</p>
<p>سازگاری با گذشته و حالت مجازی ۸۶</p>
<p>CPUهای مدرن می‌توانند بسیار بیشتر از این مقدار حافظه را آدرس‌دهی کنند،
    و من به زودی توضیح خواهم داد چگونه. در مورد CPUهای اولیه 8086 و 8088، آن
    ۲۰ خط آدرس و ۱ مگابایت حافظه تمام چیزی بود که وجود داشت. CPUهای ۳۸۶ و
    بعد از آن که ۳۲ بیتی بودند، می‌توانستند تا ۴ گیگابایت حافظه را بدون خرد
    کردن آن به بخش‌های کوچک‌تر آدرس‌دهی کنند. وقتی یک CPU ۳۲ بیتی در حالت حفاظت
    شده مدل تخت کار می‌کند، یک بخش حافظه ۴ گیگابایتی است—پس یک سگمنت به طور
    عمده کافی است و در صورت نصب حافظه ۸، ۱۶ یا ۶۴ گیگابایت، بیشتر هم می‌توان
    داشت. در حالت بلند x64 هم، خب، سگمنت شما می‌تواند هرقدر که بخواهید طولانی
    باشد. طول آن ممکن است شما را شگفت‌زده کند. وقتی درس تاریخ تمام شود، به آن
    برمی‌گردیم.</p>
<p>با این حال، تعداد زیادی نرم‌افزار DOS که برای استفاده از سگمنت‌ها نوشته
    شده بود، همه‌جا وجود داشت و باید با آن سازگاری حفظ می‌شد. بنابراین، برای
    حفظ سازگاری با عقب (برنامه‌های قدیمی 8086 و 8088)، CPUهای جدیدتر توانایی
    این را داشتند که خود را محدود به کاری که تراشه‌های قدیمی می‌توانستند انجام
    دهند، کنند. هنگامی که یک CPU نسل پنتیوم یا بهتر نیاز دارد نرم‌افزار نوشته
    شده برای مدل سگمنت‌بندی شده حالت واقعی را اجرا کند، ترفندی می‌زند که به
    طور موقت آن را به 8086 تبدیل می‌کند. این حالت را حالت مجازی ۸۶
    (virtual-86 mode) می‌نامند و برای سازگاری به عقب با نرم‌افزار DOS عالی
    بود.</p>
<p>وقتی شما در ویندوز NT و نسخه‌های بعدی ویندوز، یک پنجره MS-DOS یا “DOS
    box” باز می‌کنید، در واقع از حالت مجازی ۸۶ استفاده می‌کنید تا چیزی شبیه یک
    جزیره حالت واقعی درون سیستم حافظه حالت حفاظت شده ویندوز ایجاد کنید. این
    تنها راه خوب برای حفظ آن سازگاری به عقب بود، به دلایلی که به زودی درک
    خواهید کرد.</p>
<p>نابینایی ۱۶ بیتی</p>
<p>در مدل سگمنت‌بندی شده حالت واقعی، یک CPU x86 می‌تواند یک مگابایت کامل
    حافظه را «ببیند». یعنی چیپ‌های CPU طوری تنظیم می‌شوند که می‌توانند از ۲۰
    پین آدرس خود استفاده کنند و یک آدرس ۲۰ بیتی به سیستم حافظه بدهند. از این
    منظر، همه چیز ساده و سرراست به نظر می‌رسد. اما عمده مشکل شما در درک مدل
    سگمنت‌بندی شده حالت واقعی از این حقیقت نشئت می‌گیرد که: در حالی که CPU
    می‌تواند یک مگابایت کامل حافظه را ببیند، مجبور است از «نابینایی ۱۶ بیتی»
    رنج ببرد.</p>
<p>این استعاره نابینایی تقریباً عینیت دارد. به شکل 4.3 نگاه کنید. مستطیل
    بلند نشان‌دهنده یک مگابایت حافظه است که CPU می‌تواند در مدل سگمنت‌بندی شده
    حالت واقعی به آن دسترسی داشته باشد. CPU در سمت راست قرار دارد. در وسط یک
    قطعه مقوایی خیالی با یک شکاف وجود دارد. این شکاف یک بایت عرض و ۶۵,۵۳۶
    بایت طول دارد. CPU می‌تواند این مقوا را در طول کل حافظه بالا و پایین
    ببرد. اما در هر لحظه، فقط می‌تواند به آن ۶۵,۵۳۶ بایت دسترسی داشته
    باشد.</p>
<p>نمای CPU از حافظه در مدل سگمنت‌بندی شده حالت واقعی عجیب است. این نما
    محدود است به نگاه کردن به حافظه در قطعه‌هایی که هیچ‌کدام بزرگ‌تر از ۶۵,۵۳۶
    بایت نیستند—دوباره، همان «64KB» معروف. استفاده از این قطعه‌ها—یعنی دانستن
    اینکه کدام قطعه در حال حاضر مورد استفاده است و چگونه از یک قطعه به قطعه
    دیگر بروید—چالش اصلی برنامه‌نویسی مدل سگمنت‌بندی شده حالت واقعی است. زمان
    آن رسیده است که با دقت بیشتری بررسی کنیم این قطعه‌ها چه هستند و چگونه کار
    می‌کنند.</p>
<p>ماهیت سگمنت‌ها</p>
<p>تا حالا به طور غیررسمی از سگمنت‌ها به عنوان بخش‌هایی از حافظه درون فضای
    بزرگ‌تر حافظه صحبت کرده‌ایم که CPU می‌تواند ببیند و استفاده کند. در زمینه
    مدل سگمنت‌بندی شده حالت واقعی، یک سگمنت یک ناحیه حافظه است که بر یک مرز
    پاراگراف قرار دارد و طول آن تا یک مقدار مشخص است. در مدل سگمنت‌بندی شده
    حالت واقعی، این طول کمتر یا مساوی ۶۴KB (65,536 بایت) است. پیش‌تر درباره
    عدد ۶۴KB صحبت کردیم. اما پاراگراف؟</p>
<p>بگذارید کمی از خرده‌دانش‌های قدیمی خانواده ۸۶ بگوییم. یک پاراگراف واحدی
    از حافظه است معادل ۱۶ بایت. این یکی از چندین اصطلاح فنی است که برای
    توصیف مقادیر مختلف حافظه استفاده می‌شود. برخی از آن‌ها را قبلاً ذکر کردیم و
    همه آن‌ها مضاربی صحیح از ۱ بایت هستند (به جز اصطلاح کهنه شده «nybble» که
    ۴ بیت یا نیم بایت است). بایت‌ها اتم‌های داده هستند، یادتان باشد؛ بیت‌های
    حافظه به‌تنهایی مثل ذرات زیراتمی هستند و بدون وجود یک بایت (یا بیشتر)
    حافظه که آن‌ها را در بر گیرد، معنایی ندارند. برخی از این اصطلاحات بیشتر
    از بقیه استفاده می‌شوند، اما شما باید از همه آگاه باشید. این اصطلاحات در
    جدول 4.1 آمده‌اند.</p>
<p>برخی از این اصطلاحات، مانند 10 بایت، به‌ندرت به کار می‌روند، و برخی
    دیگر، مانند صفحه (page)، تقریباً هیچ‌وقت استفاده نمی‌شوند. اصطلاح پاراگراف
    (paragraph) نیز هیچ‌گاه رایج نبوده و بیشتر اوقات فقط در ارتباط با
    مکان‌هایی در حافظه به کار می‌رفته که بخش‌ها (segment) ممکن است از آنجا آغاز
    شوند.</p>
<p>[تصویری از مشاهده یک مگابایت از دریچه‌ی محدودیت 64 کیلوبایتی]</p>
<p>شکل 4.3: مشاهده یک مگابایت از پشت چشم‌بندهای 64 کیلوبایتی</p>
<pre><code>   نام            تعداد بایت به دهدهی     تعداد بایت به هگز
   ------------   --------------------     ----------------
   بایت (Byte)    1                       01H
   کلمه (Word)    2                       02H
   دابل‌ورد       4                       04H
   کوآد‌ورد       8                       08H
   ده‌بایت        10                      0AH
   پاراگراف       16                      10H
   صفحه (Page)    256                     100H
   سگمنت          65,536                  10000H</code></pre>
<p>جدول 4.1: اصطلاحات جمعی برای حافظه</p>
<p>هر آدرس حافظه‌ای که بر 16 بخش‌پذیر باشد، یک مرز پاراگراف (paragraph
    boundary) نامیده می‌شود. اولین مرز پاراگراف آدرس 0 است. دومین آن آدرس
    10H، سومین آدرس 20H و به همین ترتیب ادامه دارد. (به یاد داشته باشید که
    10H معادل 16 در دهدهی است.) هر مرز پاراگرافی می‌تواند به‌عنوان آغاز یک
    سگمنت در نظر گرفته شود.</p>
<p>این بدان معنا نیست که واقعاً یک سگمنت هر 16 بایت در سراسر آن یک
    مگابایت حافظه شروع می‌شود. یک سگمنت را می‌توان مانند یک طبقه در قفسه‌های
    کتاب قابل تنظیم امروزی تصور کرد. در پشت این قفسه کتاب تعداد زیادی
    شکاف‌های کوچک با فاصله نیم اینچ از یکدیگر قرار دارند. براکت‌های طبقه را
    می‌توان در هر یک از این شکاف‌های کوچک قرار داد. با این حال، صدها طبقه
    موجود نیست، بلکه فقط چهار یا پنج طبقه داریم. تقریباً همه شکاف‌ها خالی و
    بلااستفاده‌اند. وجود این شکاف‌ها برای آن است که تعداد کمی طبقه را بتوان
    بنا به نیاز، در ارتفاع مختلف قفسه بالا و پایین کرد.</p>
<p>به‌طور مشابه، مرزهای پاراگراف مانند شکاف‌های کوچکی هستند که یک سگمنت
    می‌تواند در آن آغاز شود. در مدل سگمنت‌بندی حالت واقعی (real mode)، یک
    برنامه ممکن است فقط از چهار یا پنج سگمنت استفاده کند، اما هر یک از آن
    سگمنت‌ها می‌توانند در هر یک از 65,536 مرز پاراگراف موجود در یک مگابایت
    حافظه حالت واقعی آغاز شوند.</p>
<p>دوباره آن عدد: 65,536 – عزیز 64 کیلوبایت ما. 64 کیلوبایت مرز پاراگراف
    مختلف وجود دارد که در آن یک سگمنت می‌تواند آغاز شود. هر مرز پاراگراف یک
    شماره دارد. طبق معمول، اعداد از 0 شروع شده و تا 64 کیلوبایت منهای یک
    ادامه می‌یابند؛ در دهدهی 65,535 یا در هگز 0FFFFH. از آنجا که یک سگمنت
    ممکن است در هر مرز پاراگرافی آغاز شود، شماره مرز پاراگرافی که سگمنت در
    آن شروع می‌شود، آدرس سگمنت آن نامیده می‌شود. در واقع، ما به‌ندرت از
    پاراگراف‌ها یا مرزهای پاراگراف صحبت می‌کنیم. هنگامی که در ارتباط با مدل
    سگمنت‌بندی حالت واقعی با اصطلاح آدرس سگمنت مواجه می‌شوید، به یاد داشته
    باشید که هر آدرس سگمنت، 16 بایت (یک پاراگراف) جلوتر از آدرس سگمنت قبلی
    در حافظه قرار دارد. شکل 4.4 را ببینید. در این شکل، هر نوار سایه‌دار یک
    آدرس سگمنت است و سگمنت‌ها هر 16 بایت شروع می‌شوند. بالاترین آدرس سگمنت،
    0FFFFH است که 16 بایت با بالاترین نقطه‌ی مگابایت حافظه‌ی حالت واقعی فاصله
    دارد.</p>
<p>[تصویری از مقایسه آدرس‌های حافظه با آدرس‌های سگمنت]</p>
<p>شکل 4.4: آدرس‌های حافظه در برابر آدرس‌های سگمنت</p>
<p>خلاصه اینکه، سگمنت‌ها می‌توانند در هر آدرس سگمنتی آغاز شوند. 65,536
    آدرس سگمنت در کل مگابایت حافظه حالت واقعی وجود دارد که با فاصله‌های 16
    بایتی توزیع شده‌اند. یک آدرس سگمنت بیشتر شبیه یک اجازه است تا یک اجبار؛
    از میان 64 کیلوبایت آدرس سگمنت ممکن، فقط پنج یا شش تای آنها در هر لحظه
    واقعاً برای آغاز سگمنت‌ها استفاده می‌شوند. آدرس‌های سگمنت را مانند شکاف‌هایی
    تصور کنید که در آنها می‌توان سگمنت‌ها را قرار داد.</p>
<p>تا اینجا درباره آدرس‌های سگمنت صحبت کردیم؛ حالا خود سگمنت‌ها چه هستند؟
    مهم‌ترین نکته این است که یک سگمنت می‌تواند حداکثر تا 64 کیلوبایت بایت
    اندازه داشته باشد، اما لزومی ندارد که چنین باشد. یک سگمنت ممکن است فقط 1
    بایت طول داشته باشد، یا 256 بایت، یا 21,378 بایت، یا هر طول دیگری کمتر
    از 64 کیلوبایت.</p>
<p>افق، نه یک مکان</p>
<p>شما عمدتاً با مشخص کردن نقطه‌ی شروع یک سگمنت، آن را تعریف می‌کنید. پس چه
    چیزی طول یک سگمنت را تعریف می‌کند؟ در واقع، هیچ چیز. اینجا وارد مباحث
    معنایی بسیار پیچیده‌ای می‌شویم. یک سگمنت بیشتر شبیه یک افق است تا یک مکان.
    وقتی نقطه شروع یک سگمنت را تعریف می‌کنید، آن سگمنت می‌تواند هر مکانی در
    حافظه را بین محل شروعش و آن افق که 65,536 بایت جلوتر است، در بر
    گیرد.</p>
<p>البته هیچ‌کس نگفته که یک سگمنت باید از تمام این حافظه استفاده کند. در
    بیشتر موارد، وقتی سگمنتی در یک آدرس سگمنت مشخص تعریف می‌شود، یک برنامه
    فقط چند صد یا شاید چند هزار بایت بعد از آن را به‌عنوان بخشی از آن سگمنت
    در نظر می‌گیرد، مگر اینکه برنامه بسیار بزرگی باشد. بسیاری از مبتدیان
    درباره سگمنت‌ها می‌خوانند و فکر می‌کنند که آنها نوعی تخصیص حافظه با منطقه‌ی
    محافظت‌شده هستند که از دو طرف با دیوار احاطه شده و برای استفاده خاصی رزرو
    شده است.</p>
<p>این تصور کاملاً اشتباه است. در حالت واقعی، هیچ چیز درون یک سگمنت
    محافظت نشده است، و سگمنت‌ها برای هیچ ثبات (register) یا روش دسترسی خاصی
    رزرو نمی‌شوند. سگمنت‌ها می‌توانند با هم همپوشانی داشته باشند (بسیاری از
    افراد به این موضوع فکر نمی‌کنند یا متوجه آن نیستند). در یک معنای کاملاً
    واقعی، سگمنت‌ها واقعاً وجود خارجی ندارند، مگر به‌عنوان یک افق که فراتر از
    آن، نوع خاصی از مرجع حافظه نمی‌تواند برود. دوباره به آن چشم‌بندهای 64
    کیلوبایتی CPU که در شکل 4.3 نشان دادیم برگردید. این‌طور تصور کنید: یک
    سگمنت محل قرار گرفتن این چشم‌بندهای 64 کیلوبایتی است. وقتی از میان این
    چشم‌بندها به حافظه نگاه کنید، می‌توانید بایت‌ها را از آدرس سگمنت ببینید تا
    جایی که این محدودکننده‌ها شما را 64 کیلوبایت جلوتر متوقف کنند.</p>
<p>کلید درک این تعریف فلسفی از سگمنت، این است که بدانید سگمنت‌ها چگونه
    استفاده می‌شوند، و درک نهایی آن نیازمند توضیح دقیق درباره ثبات‌ها
    (registers) است.</p>
<p>ساختن آدرس‌های 20 بیتی از ثبات‌های 16 بیتی</p>
<p>همان‌طور که در فصل‌های قبل غیررسمی اشاره کردم، یک ثبات (register) یک
    مکان حافظه داخل خود تراشه CPU است، نه خارج از CPU در یک بانک حافظه.
    پردازنده‌های 8086، 8088 و 80286 اغلب CPUهای 16 بیتی نامیده می‌شوند، زیرا
    تقریباً تمام ثبات‌های داخلی آنها 16 بیتی هستند. 80386 و جانشینان 25 ساله‌ی
    آن CPUهای 32 بیتی نامیده می‌شوند، زیرا بیشتر ثبات‌های داخلی آنها 32 بیتی
    است. آخرین CPU 32 بیتی اینتل سری Lincroft Atom بود که در سال 2010 معرفی
    شد و برای دستگاه‌های همراه هدف‌گذاری شد. آخرین CPU 32 بیتی دسکتاپ اینتل
    عضوی از خانواده Pentium 4 بود که در سال 2002 معرفی شد. دوره 32 بیتی شاید
    ارزش بررسی دقیق داشته باشد، اما حالا در سال 2023 عملاً پایان یافته
    است.</p>
<p>CPUهای x64 دارای طراحی 64 بیتی هستند، با ثبات‌هایی که 64 بیت عرض
    دارند. CPUهای اینتل تعداد نسبتاً قابل توجهی ثبات دارند و این ثبات‌ها واقعاً
    جالب هستند.</p>
<p>ثبات‌ها کارهای زیادی انجام می‌دهند، اما شاید مهم‌ترین کار آنها نگه‌داشتن
    آدرس‌های مکان‌های مهم در حافظه باشد. اگر به یاد داشته باشید، 8086 و 8088
    دارای 20 خط آدرس هستند و مگابایت حافظه‌ی آنها (همان حافظه سگمنت‌بندی شده
    در حالت واقعی که درباره آن صحبت می‌کنیم) نیازمند آدرس‌هایی 20 بیتی
    است.</p>
<p>چطور می‌توان یک آدرس 20 بیتی حافظه را در یک ثبات 16 بیتی قرار داد؟</p>
<p>خیلی ساده. این کار را نمی‌کنید.</p>
<p>شما یک آدرس 20 بیتی را در دو ثبات 16 بیتی قرار می‌دهید.</p>
<p>ماجرا از این قرار است: همه مکان‌های حافظه در مگابایت حالت واقعی، نه یک
    بلکه دو آدرس دارند. فرض بر این است که هر بایت درون یک سگمنت قرار دارد.
    آدرس کامل یک بایت، بنابراین، شامل آدرس سگمنت آن و همچنین فاصله بایت تا
    ابتدای آن سگمنت است. آدرس سگمنت (همان‌طور که قبلاً گفتیم) آدرس سگمنت آن
    بایت است. فاصله بایت تا ابتدای سگمنت، آدرس افست (offset) آن بایت نام
    دارد. هر دو آدرس باید مشخص شوند تا بتوان مکان یک بایت در بین کل یک
    مگابایت حافظه حالت واقعی را توصیف کرد. وقتی آدرس را می‌نویسیم، اول آدرس
    سگمنت و بعد آدرس افست می‌آید و بینشان یک دونقطه قرار می‌گیرد. آدرس‌های
    سگمنت:افست همیشه به صورت هگزادسیمال نوشته می‌شوند.</p>
<p>شکل 4.5 را کشیده‌ام تا این موضوع را کمی روشن‌تر کنم. یک بایت داده که ما
    آن را MyByte می‌نامیم، در مکانی از حافظه قرار دارد که علامت‌گذاری شده است.
    آدرس آن 0001:0019 است. این یعنی MyByte داخل سگمنتی با آدرس سگمنت 0001H
    قرار دارد و 0019H بایت با ابتدای آن سگمنت فاصله دارد. توجه کنید که
    به‌صورت قراردادی وقتی دو عدد را با دونقطه برای مشخص کردن آدرس می‌نویسیم،
    در پایان هر کدام H نمی‌گذاریم.</p>
<p>اما جهان بازی‌های عجیبی دارد، و اگر با دقت نگاه کنید، می‌بینید MyByte
    می‌تواند دو آدرس قانونی دیگر نیز داشته باشد: 0:0029 و 0002:0009. چطور
    چنین چیزی ممکن است؟ به یاد داشته باشید که یک سگمنت می‌تواند هر 16 بایت در
    سراسر یک مگابایت حافظه واقعی آغاز شود. یک سگمنت وقتی شروع می‌شود، همه
    بایت‌ها را از مبدأ خود تا 65,535 بایت جلوتر در بر می‌گیرد. هیچ اشکالی
    ندارد که سگمنت‌ها همپوشانی داشته باشند، و در شکل 4.5 ما سه سگمنت همپوشان
    داریم. MyByte در سگمنتی که از آدرس سگمنت 0000H شروع می‌شود 29H بایت جلوتر
    است، در سگمنتی که از آدرس 0001H شروع می‌شود 19H بایت جلوتر است. این بدان
    معنا نیست که MyByte در دو یا سه جای مختلف است. فقط در یک مکان است، اما
    آن مکان را می‌توان به سه روش مختلف توصیف کرد.</p>
<p>[تصویری از سگمنت‌ها و افست‌ها]</p>
<p>شکل 4.5: سگمنت‌ها و افست‌ها</p>
<p>این شبیه سیستم شماره‌گذاری خیابان‌های شیکاگو است. خیابان Howard، 76
    بلوک شمال خیابان “مبدأ” یعنی Madison است. اما Howard فقط 4 بلوک شمال
    خیابان Touhy است. می‌توانید مکان خیابان Howard را نسبت به خیابان Madison
    یا خیابان Touhy توصیف کنید، بسته به این‌که چه هدفی داشته باشید.</p>
<p>یک بایت دلخواه در جایی میانی از مگابایت حافظه‌ی حالت واقعی سگمنت‌بندی
    شده می‌تواند در هزاران سگمنت مختلف قرار بگیرد. اینکه آن بایت واقعاً در
    کدام سگمنت است، کاملاً یک قرارداد است.</p>
<p>خلاصه اینکه، برای بیان یک آدرس 20 بیتی با دو ثبات 16 بیتی، آدرس سگمنت
    را در یک ثبات 16 بیتی و آدرس افست را در ثبات 16 بیتی دیگر قرار می‌دهیم.
    این دو ثبات با هم یک بایت از مجموع 1,048,576 بایت حافظه یک مگابایتی حالت
    واقعی را مشخص می‌کنند.</p>
<p>آیا این دشوار است؟ شما تصوری ندارید. اما این بهترین کاری بود که سال‌ها
    می‌توانستیم انجام دهیم.</p>
<p>ثبات‌های سگمنت</p>
<p>آدرس سگمنت را به عنوان محل شروع آن چشم‌بندهای 64 کیلوبایتی در حالت
    واقعی در نظر بگیرید. معمولاً شما چشم‌بندها را جابه‌جا می‌کنید تا مکان
    موردنظر را در بر بگیرند و سپس چشم‌بندها را در همان‌جا نگه می‌دارید، در حالی
    که در محدوده 64 کیلوبایتی آنها حرکت می‌کنید.</p>
<p>این دقیقاً همان روشی است که ثبات‌ها در زبان اسمبلی مدل سگمنت‌بندی حالت
    واقعی استفاده می‌شوند. 8086، 8088 و 80286 دقیقاً چهار ثبات سگمنت دارند که
    برای نگهداری آدرس‌های سگمنت تعیین شده‌اند. 386 و CPUهای بعدی دو ثبات دیگر
    هم دارند که می‌توانند در حالت واقعی استفاده شوند. (اگر قصد استفاده از آن
    دو ثبات سگمنت اضافی را دارید، باید از مدل CPU که روی آن اجرا می‌شوید آگاه
    باشید، چون CPUهای قدیمی‌تر آنها را ندارند.) هر ثبات سگمنت یک مکان 16 بیتی
    درون خود تراشه CPU است. مهم نیست CPU چه کاری انجام می‌دهد؛ اگر دارد به
    مکانی در حافظه دسترسی پیدا می‌کند، آدرس سگمنت آن مکان در یکی از این شش
    ثبات سگمنت قرار دارد.</p>
<p>نام ثبات‌های سگمنت بازتاب‌دهنده عملکرد کلی آنهاست: CS، DS، SS، ES، FS و
    GS. FS و GS فقط در CPUهای 32 بیتی 386 و بعد از آن وجود دارند—اما همچنان
    16 بیتی هستند. همه ثبات‌های سگمنت 16 بیتی‌اند، فارغ از نوع CPU. این حتی در
    مورد CPUهای 64 بیتی امروزی هم صدق می‌کند، هرچند در این مورد نکته‌ای وجود
    دارد—بعداً در این باره بیشتر می‌گوییم.</p>
<ul>
    <li>CS مخفف code segment است. دستورالعمل‌های ماشین در برخی افست از یک
        سگمنت کد قرار دارند. آدرس سگمنت کد دستورالعمل در حال اجرا، در CS نگهداری
        می‌شود.
    </li>
    <li>DS مخفف data segment است. متغیرها و دیگر داده‌ها در برخی افست از یک
        سگمنت داده قرار دارند. ممکن است سگمنت‌های داده‌ی بسیاری وجود داشته باشد،
        اما CPU فقط می‌تواند در یک زمان از یکی استفاده کند، با قرار دادن آدرس
        سگمنت آن در DS.
    </li>
    <li>SS مخفف stack segment است. پشته (stack) یک بخش بسیار مهم CPU برای
        نگهداری موقت داده‌ها و آدرس‌هاست. بعداً توضیح می‌دهم پشته چگونه کار می‌کند؛
        فعلاً بدانید که، مانند هر چیز دیگر درون مگابایت حافظه حالت واقعی، پشته یک
        آدرس سگمنت دارد که در SS قرار می‌گیرد.
    </li>
    <li>ES مخفف extra segment است. سگمنت اضافی دقیقاً همان است: یک سگمنت یدکی
        که می‌توان از آن برای مشخص کردن یک مکان در حافظه استفاده کرد.
    </li>
    <li>FS و GS نسخه‌های کلون‌شده‌ای از ES هستند. هر دو سگمنت “اضافی” دیگر بدون
        کار ویژه‌اند. نام‌های آنها از این واقعیت می‌آید که پس از ES ایجاد شدند. (به
        ترتیب E، F، G را در نظر بگیرید.) فراموش نکنید که آنها فقط در CPUهای 386
        و بعد از آن وجود دارند.
    </li>
</ul>
<p>ثبات‌های سگمنت و x64</p>
<p>حالا، درباره‌ی ثبات‌های سگمنت در معماری x64 یک نکته عجیب وجود دارد:
    آنها در برنامه‌های کاربردی استفاده نمی‌شوند. اصلاً. تصور کنید: 64 بیت
    می‌تواند 2^64 بایت حافظه را آدرس‌دهی کند. در نماد علمی دهدهی این عدد
    تقریباً 1.8 ضرب در 10^19 است. به‌صورت شفاهی، می‌گوییم “18 اگزابایت”. اگر
    این کلمه برای شما جدید است، تنها نیستید. یک اگزابایت برابر است با یک
    میلیارد گیگابایت، یعنی یک میلیارد میلیارد بایت. رایانه کار روزمره من که
    خیلی هم جدید نیست 16 گیگابایت RAM دارد. اغلب کامپیوترهای جدید 64
    گیگابایت را پشتیبانی می‌کنند، و همین هم زیاد است. حتی گیمرها هم می‌دانند
    که بیش از 64 گیگابایت RAM بازی آنها را بهتر نمی‌کند.</p>
<p>تمام هدف وجود ثبات‌های سگمنت این بود که بتوان 20 بیت فضای آدرس را با
    دو ثبات 16 بیتی آدرس داد. وقتی یک ثبات 64 بیتی واحد می‌تواند تقریباً
    به‌اندازه تعداد ستارگان جهان قابل مشاهده آدرس‌دهی کند (من درباره‌ی این مورد
    اغراق نمی‌کنم!)، ثبات‌های سگمنت حداقل در برنامه‌نویسی کاربردی بی‌استفاده
    می‌شوند. سیستم‌های عامل از دو تای آنها برای اهدافی استفاده می‌کنند که
    توضیحش از محدوده این کتاب خارج است. سایر ثبات‌ها هم وجود دارند اما اگر
    سعی کنید از آنها استفاده کنید، ممکن است دردسر ایجاد کنند. خلاصه اینکه،
    وقتی وارد حالت بلند (long mode) x64 می‌شوید، ثبات‌های سگمنت 16 بیتی آشنا
    عملاً از بین می‌روند.</p>
<p>خب… آیا CPUهای x64 اینتل 64 خط آدرس دارند؟ خیر. حتی مکانیزمی درون
    تراشه برای پشتیبانی بیش از 48 بیت آدرس در CPUهای x64 قدیمی‌تر وجود ندارد.
    (اینتل چند سال پیش این مقدار را برای برخی از CPUهای رده‌بالا به 52 بیت
    افزایش داد.) چرا همین مقدار هم زیاد است؟ بخشی از آن نگاه به فناوری‌های
    حافظه‌ای است که هنوز تصورشان را هم نداریم. این موضوع ساده نیست و من فضای
    کافی برای پرداختن بیشتر به آن در این کتاب ندارم. اما این جمله را به خاطر
    بسپارید:</p>
<p>«از دیدگاه 64 بیتی، ثبات‌های سگمنت دیگر تاریخ مصرفشان تمام شده
    است.»</p>
<p>ثبات‌های همه‌منظوره</p>
<p>همه CPUهای اینتل مجموعه‌ای از ثبات‌های همه‌منظوره دارند که عمده کار
    محاسبات اسمبلی را انجام می‌دهند. این ثبات‌های همه‌منظوره مقادیر مورد نیاز
    برای محاسبات حسابی و منطقی، بیت‌شیفت‌ها (بعداً توضیح می‌دهم) و کارهای متعدد
    دیگر، از جمله نگهداری آدرس حافظه را نگه می‌دارند. آنها واقعاً جیب‌های
    همه‌کاره‌ی درون CPU هستند.</p>
<p>اما حالا به یکی از بزرگ‌ترین و مشهودترین تفاوت‌ها بین ادوار مختلف
    میکروکامپیوترهای اینتل می‌رسیم: عرض ثبات‌های همه‌منظوره. 8080 ابتدایی
    ثبات‌های 8 بیتی داشت. CPUهای x86 با معماری 16 بیتی (8086، 8088، 80186 و
    80286) ثبات‌های 16 بیتی داشتند. CPUهای 32 بیتی x86 که با 386 شروع شدند،
    ثبات‌های 32 بیتی داشتند. و در جهان x64، CPUها دارای 14 ثبات همه‌منظوره 64
    بیتی هستند. دو ثبات دیگر، ثبات اشاره‌گر پشته (stack pointer) و ثبات پایه
    (base pointer)، متخصص هستند و در معماری‌های 16 بیتی، 32 بیتی و 64 بیتی
    همگی وجود دارند. اشاره‌گر پشته همیشه به بالای پشته اشاره می‌کند. (بعدها
    درباره پشته مفصل توضیح می‌دهم.) ثبات پایه شبیه یک نشانگر است که برای
    دسترسی به داده‌هایی که “پایین‌تر” در پشته قرار دارند استفاده می‌شود. باز هم
    در ادامه، با رسیدن به بحث پشته، این را بیشتر توضیح خواهم داد.</p>
<p>درست همانند ثبات‌های سگمنت، ثبات‌های همه‌منظوره‌ی x64 مکان‌های حافظه‌ای
    هستند که درون خودِ تراشه‌ی CPU قرار دارند. ثبات‌های همه‌منظوره واقعاً
    «همه‌منظوره» هستند، به این معنا که همه‌ی آن‌ها مجموعه‌ی گسترده‌ای از قابلیت‌ها
    را به اشتراک می‌گذارند. با این حال، برخی از این ثبات‌ها یک «دستور کار
    پنهان» دارند: وظیفه یا مجموعه وظایفی که فقط آن‌ها می‌توانند انجام دهند. در
    ادامه‌ی کار این دستورکارهای پنهان را توضیح خواهم داد، با این توجه که بعضی
    از آن‌ها در واقع محدودیت‌های CPUهای 16 بیتی قدیمی هستند. ثبات‌های
    همه‌منظوره‌ی 32 بیتی و 64 بیتی بسیار «همه‌منظوره‌تر» از ثبات‌های قدیمی‌تر
    هستند.</p>
<p>در دنیای 64 بیتی کنونی، ثبات‌های همه‌منظوره به چهار دسته‌ی کلی تقسیم
    می‌شوند: ثبات‌های همه‌منظوره‌ی 16 بیتی، ثبات‌های همه‌منظوره‌ی 32 بیتی
    (گسترش‌یافته)، ثبات‌های همه‌منظوره‌ی 64 بیتی و نیمه‌های 8 بیتی ثبات‌ها. این
    چهار دسته در واقع چهار مجموعه‌ی کاملاً مجزا از ثبات‌ها نیستند. ثبات‌های 8
    بیتی، 16 بیتی و 32 بیتی در حقیقت نام‌هایی برای نواحی درون همان ثبات‌های 64
    بیتی هستند. رشد ثبات‌ها در خانواده‌ی قدیمی x86 با گسترش ثبات‌های موجود در
    CPUهای قدیمی‌تر ایجاد شد. اضافه کردن یک اتاق به خانه‌ی شما، آن خانه را به
    دو خانه تبدیل نمی‌کند—فقط یک خانه‌ی بزرگ‌تر می‌سازد. در مورد ثبات‌های x86 نیز
    همین اتفاق افتاده است.</p>
<p>هشت ثبات همه‌منظوره‌ی 16 بیتی وجود دارد: AX، BX، CX، DX، BP، SI، DI، و
    SP. (SP و BP اندکی کمتر از بقیه همه‌منظوره هستند، اما بعداً به آن
    می‌پردازیم.) این ثبات‌ها همگی در CPUهای 8086، 8088، 80186 و 80286 وجود
    داشتند. اندازه‌ی آن‌ها 16 بیت است و می‌توانید هر مقداری که با 16 بیت یا
    کمتر قابل بیان باشد را در آن‌ها قرار دهید. وقتی اینتل در سال 1985 معماری
    x86 را به 32 بیت گسترش داد، اندازه‌ی همه‌ی این هشت ثبات را دو برابر کرد و
    با افزودن یک حرف E در ابتدای نام آن‌ها، ثبات‌های EAX، EBX، ECX، EDX، EBP،
    ESI، EDI، و ESP را به وجود آورد.</p>
<p>در سال 2003 بار دیگر تغییراتی رخ داد، زمانی که اینتل شروع به پذیرش
    معماری 64 بیتی AMD با سازگاری معکوس (backward-compatible) به نام x64
    کرد. البته اینتل در آن زمان معماری 64 بیتی مخصوص خود با نام IA-64
    Itanium را داشت، اما Itanium در سطح ریزمعماری دچار مشکلات ظریف اما مهمی
    بود که توضیحشان در کتاب مقدماتی مثل این دشوار است. در نهایت اینتل غرورش
    را کنار گذاشت و کار هوشمندانه را انجام داد: پذیرش معماری 64 بیتی موفق
    AMD. افسوس که 8080 تنها ماند. سازگاری معکوس را فقط تا حدی می‌توان عقب
    برد، پیش از آنکه بیشتر به جای یک مزیت، یک اشکال به حساب آید.</p>
<p>معماری x64 ثبات‌های همه‌منظوره را از 32 بیت به 64 بیت گسترش داد. این
    بار پیشوند نام ثبات‌ها R شد. بنابراین به جای EAX 32 بیتی، حالا RAX داریم،
    و همین طور برای دیگر ثبات‌های 32 بیتی. همچنین اینتل هشت ثبات 64 بیتی جدید
    اضافه کرد که قبلاً هرگز بخشی از معماری نبودند. نام آن‌ها عمدتاً عددی است:
    R8 تا R15.</p>
<p>ثبات‌های 64 بیتی x64 در حقیقت ثبات‌هایی درون ثبات‌های دیگر هستند. مثل
    بسیاری چیزها، دیدن این موضوع بهتر از توضیح صرف آن است. به شکل 4.6 نگاه
    کنید که چگونگی این موضوع را با ثبات‌های RAX و R8 نشان می‌دهد.</p>
<p>[تصویر ثبات‌های درون ثبات‌ها]</p>
<p>شکل 4.6: ثبات‌های درون ثبات‌ها</p>
<p>RAX شامل EAX، AX، AH و AL است. EAX شامل AX، AH و AL است. AX شامل AH و
    AL است. نام‌های «RAX»، «EAX»، «AX»، «AH» و «AL» همگی در x64 معتبر هستند.
    شما می‌توانید همه‌ی این نام‌ها را در برنامه‌های زبان اسمبلی خود برای دسترسی
    به 64 بیت درون RAX یا بخش‌های کوچکتر آن به کار برید. اگر می‌خواهید به 32
    بیت پایین RAX دسترسی پیدا کنید، از نام EAX استفاده کنید. اگر می‌خواهید به
    16 بیت پایین RAX دسترسی پیدا کنید، از AX استفاده کنید.</p>
<p>نیمه‌های ثبات</p>
<p>همین موضوع برای چهار ثبات همه‌منظوره‌ی RAX، RBX، RCX و RDX نیز صادق
    است، اما یک پیچیدگی اضافه دارد: 16 بیت پایین آن‌ها خود به دو نیمه‌ی 8 بیتی
    نام‌گذاری‌شده تقسیم می‌شود. بنابراین ما چهار سطح نام برای ثبات‌ها داریم.
    ثبات‌های 16 بیتی AX، BX، CX و DX به عنوان بخش 16 بیتی پایینی از EAX، EBX،
    ECX، و EDX حضور دارند، که آن‌ها نیز به نوبه‌ی خود بخش‌های 32 بیتی پایینی
    RAX، RBX، RCX، و RDX هستند.</p>
<p>اما AX، BX، CX، و DX خودشان به دو نیمه‌ی 8 بیتی تقسیم می‌شوند و
    اسمبلرها برای این دو نیمه نام‌های خاصی را تشخیص می‌دهند. حرف‌های A، B، C و
    D حفظ می‌شوند، اما به‌جای X، با یک H (برای نیمه‌ی بالا، High) یا یک L (برای
    نیمه‌ی پایین، Low) مشخص می‌شوند. هر نیمه‌ی ثبات یک بایت (8 بیت) است.
    بنابراین، برای ساختن ثبات 16 بیتی AX، شما دو نیمه‌ی AH و AL را دارید؛ در
    BX، BH و BL وجود دارد، و به همین ترتیب.</p>
<p>ثبات‌های جدید x64 به نام‌های R8 تا R15 را می‌توان به صورت 64 بیتی، 32
    بیتی، 16 بیتی و 8 بیتی مورد دسترسی قرار داد. با این حال، طرح AH/AL برای
    16 بیت پایینی، تنها برای RAX تا RDX قابل استفاده است. شیوه‌ی نام‌گذاری
    برای ثبات‌های R یک نوع یادآوری است: D برای Double word (32 بیت)، W برای
    Word (16 بیت)، و B برای Byte (8 بیت). برای مثال، اگر می‌خواهید با 8 بیت
    پایین R8 سروکار داشته باشید، از نام R8B استفاده کنید.</p>
<p>اشتباه رایج مبتدیان این است که فرض می‌کنند R8، R8D، R8W و R8B چهار
    ثبات جداگانه و مستقل هستند! بهتر است آن‌ها را مانند
    کشور/استان/شهرستان/شهر در نظر بگیرید. یک شهر بخشی کوچک از یک شهرستان
    است، که آن هم بخشی از یک استان است و … . اگر یک مقدار را در R8B بنویسید،
    مقدار ذخیره‌شده در R8، R8D و R8W را تغییر داده‌اید.</p>
<p>باز هم این موضوع را بهتر است در یک نمودار دید. شکل 4.7 گسترشی از شکل
    4.6 است تا همه‌ی ثبات‌های همه‌منظوره‌ی x64 را شامل شود. این ثبات‌ها همه نوعی
    «نیمه‌ی پایین» دارند. به‌جز AH، BH، CH، و DH، هیچ نامی برای نیمه‌ی بالای
    هیچ ثبات همه‌منظوره‌ی دیگری وجود ندارد.</p>
<p>البته، می‌توان با استفاده از بیش از یک دستورالعمل ماشینی به نیمه‌ی
    بالای هر ثبات دسترسی داشت. شما فقط نمی‌توانید این کار را در یک مرحله و با
    یک نام انجام دهید، مگر اینکه با چهار استثنای 8 بیتی که اشاره شد سروکار
    داشته باشید.</p>
<p>توانایی برخورد با ثبات‌های AX، BX، CX و DX به عنوان نیمه‌های 8 بیتی
    می‌تواند در شرایطی که با مقدار زیادی داده‌ی 8 بیتی کار می‌کنید بسیار مفید
    باشد. هر نیمه‌ی ثبات را می‌توان به عنوان یک ثبات جداگانه در نظر گرفت و این
    باعث می‌شود دو برابر تعداد مکان‌های بالقوه برای قرار دادن داده‌ها در حین
    کار برنامه داشته باشید. همان‌طور که بعداً خواهید دید، یافتن جایی برای قرار
    دادن یک مقدار در شرایط دشوار یکی از چالش‌های بزرگ برنامه‌نویسان اسمبلی
    است.</p>
<p>[تصویر ثبات‌های 8 بیتی، 16 بیتی، 32 بیتی و 64 بیتی]</p>
<p>شکل 4.7: ثبات‌های 8 بیتی، 16 بیتی، 32 بیتی و 64 بیتی</p>
<p>شمارنده‌ی دستورالعمل (Instruction Pointer)</p>
<p>نوع دیگری از ثبات نیز در همه‌ی CPUهای اینتل از جمله x64 وجود دارد. به
    آن شمارنده‌ی دستورالعمل (IP) گفته می‌شود. در حالت 16 بیتی، این ثبات به
    سادگی IP نام دارد. در حالت 32 بیتی، EIP است. در x64، آن را RIP می‌نامند.
    در تمام این حالات، اما، این ثبات مستقیماً توسط برنامه‌نویس اسمبلی قابل
    دسترسی نیست. در عوض، به صورت غیرمستقیم و هنگام انجام پرش، انشعاب شرطی،
    فراخوانی زیرروال (procedure call) یا وقفه (interrupt) دستکاری می‌شود. در
    بحث‌های عمومی که محدود به حالت خاصی نیست، بر اساس عرف آن را IP
    می‌نامم.</p>
<p>در تضاد شدید با گروه ثبات‌های واقعاً همه‌منظوره، IP یک متخصص تمام عیار
    است—حتی متخصص‌تر از ثبات‌های سگمنت. فقط می‌تواند یک کار انجام دهد: این ثبات
    آدرس Offset دستور ماشینی بعدی که باید در سگمنت کد جاری اجرا شود را در
    خود دارد.</p>
<p>یک سگمنت کد بخش از حافظه است که دستورالعمل‌های ماشینی در آن ذخیره
    می‌شوند. بسته به مدل حافظه‌ای که استفاده می‌کنید، ممکن است در یک برنامه
    چندین سگمنت کد وجود داشته باشد، یا (در بیشتر موارد) فقط یکی. سگمنت کد
    جاری همان سگمنت کدی است که آدرس سگمنت آن در ثبات سگمنت CS قرار دارد. در
    هر لحظه، دستور ماشینی که در حال اجراست درون همان سگمنت کد جاری وجود
    دارد. در مدل سگمنت‌شده‌ی Real Mode، مقدار CS می‌تواند مرتب تغییر کند. اما
    در مدل تخت (flat) (که شامل حالت طولانی x64 نیز می‌شود)، مقدار CS (تقریباً)
    هرگز تغییر نمی‌کند—و قطعاً هرگز به فرمان یک برنامه‌ی کاربردی تغییر نمی‌کند.
    مدیریت سگمنت‌های کد و شمارنده‌ی دستورالعمل اکنون بر عهده‌ی سیستم‌عامل است.
    این موضوع به ویژه در حالت طولانی x64 صادق است، جایی که فقط یک سگمنت همه
    چیز را در بر دارد و ثبات‌های سگمنت در فضای کاربر عملاً کاری برای انجام
    ندارند.</p>
<p>در حین اجرای برنامه، CPU از IP برای پیگیری موقعیت خود در سگمنت کد
    جاری استفاده می‌کند. هر بار که یک دستور اجرا می‌شود، IP به اندازه‌ی چند
    بایت افزایش می‌یابد. تعداد این بایت‌ها اندازه‌ی همان دستور اجرای‌شده است.
    نتیجه‌ی نهایی، حرکت IP به جلو در حافظه است به طوری که به ابتدای دستور
    بعدی که باید اجرا شود اشاره کند، نه وسط دستور قبلی یا وسط یک دستور دیگر.
    اندازه‌ی دستورالعمل‌ها متفاوت است و معمولاً از 1 تا 15 بایت متغیر است. CPU
    اندازه‌ی هر دستورالعملی که اجرا می‌کند را می‌داند و با دقت IP را به اندازه‌ی
    درست افزایش می‌دهد تا دقیقاً به ابتدای دستورالعمل بعدی برسد.</p>
<p>اگر IP آدرس Offset دستور ماشینی بعدی را در خود دارد، آدرس سگمنت کجا
    نگهداری می‌شود؟ آدرس سگمنت در ثبات سگمنت CS نگهداری می‌شود. CS و IP با هم
    آدرس کامل دستورالعمل بعدی که باید اجرا شود را در خود دارند.</p>
<p>ماهیت این آدرس بستگی به این دارد که از چه CPU و چه مدل حافظه‌ای
    استفاده می‌کنید. در 8086، 8088 و (معمولاً) 80286، IP یک ثبات 16 بیتی است.
    در CPUهای 386 و بعدی، IP (مانند سایر ثبات‌ها به جز ثبات‌های سگمنت) به 32
    بیت گسترش یافته و به EIP تبدیل می‌شود.</p>
<p>در مدل سگمنت‌شده‌ی Real Mode، CS و IP با هم یک آدرس 20 بیتی را تشکیل
    می‌دهند که به یکی از 1,048,576 بایت حافظه‌ی Real Mode اشاره می‌کند. در
    مدل‌های تخت، CS توسط سیستم‌عامل تنظیم شده و ثابت می‌ماند. در این حالت، IP
    است که کار نشان دادن موقعیت دستورالعمل را انجام می‌دهد و شما به عنوان
    برنامه‌نویس باید با آن سروکار داشته باشید. در مدل تخت 16 بیتی (Real Mode
    Flat Model)، این به معنای آن است که IP می‌تواند اجرای دستورالعمل‌ها را در
    سراسر یک سگمنت کامل 64 کیلوبایتی دنبال کند. مدل تخت 32 بیتی از این هم
    فراتر می‌رود؛ 32 بیت می‌تواند 4,294,967,290 آدرس حافظه‌ی مختلف را نشان دهد.
    در حالت طولانی 64 بیتی، خب، RIP می‌تواند به اندازه‌ی حافظه‌ای که شما در
    تمام عمرتان می‌توانید در یک ماشین قرار دهید، آدرس‌دهی کند—و قطعاً بیش از
    مقداری که من بتوانم. درباره‌ی این که آیا روزی CPUهای 128 بیتی تولید
    خواهند شد، اختلاف نظر وجود دارد. من فکر نمی‌کنم، به دلایلی که کمی بعدتر
    در این فصل اشاره خواهم کرد.</p>
<p>IP تنها ثباتی است که نمی‌توان آن را به طور مستقیم خواند یا در آن نوشت.
    ترفندهایی وجود دارند که با آن‌ها می‌توان مقدار جاری IP را به دست آورد، اما
    داشتن مقدار IP آنقدر که فکر می‌کنید مفید نیست و خیلی به ندرت به آن نیاز
    پیدا خواهید کرد.</p>
<p>ثبات فلگ‌ها (Flags)</p>
<p>یک نوع دیگر از ثبات هم درون CPU وجود دارد: چیزی که ما آن را به طور
    کلی ثبات فلگ‌ها می‌نامیم. در CPUهای 8086، 8088، و 80286، این ثبات 16 بیتی
    بوده و نام رسمی آن FLAGS است. در CPUهای 32 بیتی، 32 بیتی است و نام رسمی
    آن EFLAGS است. در x64، ثبات RFLAGS دارای اندازه‌ی 64 بیت است. کمتر از نصف
    بیت‌های RFLAGS به عنوان ثبات‌های تک‌بیتی به نام فلگ‌ها استفاده می‌شوند. (باقی
    نامشخص است.) هر یک از این فلگ‌های تک‌بیتی یک نام با دو حرف اختصاری دارد،
    مانند CF، DF، OF، و غیره، و هر فلگ معنای بسیار مشخصی درون CPU دارد.</p>
<p>از آنجا که یک بیت فقط می‌تواند حاوی دو مقدار باشد، 0 یا 1، آزمایش فلگ
    در زبان اسمبلی واقعاً یک موقعیت دوگانه است: یا مقدار فلگ 1 است یا نیست.
    وقتی مقدار فلگ 1 باشد، می‌گوییم فلگ Set شده است. وقتی مقدار فلگ 0 باشد،
    می‌گوییم فلگ Clear شده است.</p>
<p>وقتی برنامه‌ی شما یک تست انجام می‌دهد، در واقع یک یا گاهی دو فلگ تک‌بیتی
    در RFLAGS را آزمایش می‌کند. سپس بر اساس حالت آن فلگ یا فلگ‌ها مسیر اجرای
    جداگانه‌ای را در پیش می‌گیرد. برای تمام فلگ‌های رایج دستورالعمل پرشی
    جداگانه‌ای وجود دارد و برای برخی موارد تست ترکیبی از فلگ‌ها نیز
    دستورالعمل‌های پرش مشخصی در نظر گرفته شده است.</p>
<p>ثبات RFLAGS تقریباً هرگز به صورت یکجا مورد استفاده قرار نمی‌گیرد، مگر
    زمانی که فلگ‌ها را روی پشته ذخیره می‌کنید. از آنجا که در حال حاضر بر
    آدرس‌دهی حافظه تمرکز داریم، فعلاً فقط قول می‌دهم که در فصل‌های مناسب بعدی،
    زمانی که درباره‌ی دستورالعمل‌هایی صحبت می‌کنیم که فلگ‌های مختلف RFLAGS را
    تست می‌کنند، به جزئیات فلگ‌ها بپردازیم.</p>
<p>کوپروسسور ریاضی و ثبات‌های آن</p>
<p>از زمان CPU 80486DX (32 بیتی)، یک کوپروسسور ریاضی روی همان تراشه با
    CPU اصلی قرار گرفته است. در زمان‌های قدیم، واحد محاسباتی ریاضی یک IC
    کاملاً جدا بود که در سوکت مخصوص خود روی مادربرد نصب می‌شد. همه‌ی CPUهای x64
    کوپروسسور ریاضی یکپارچه‌ای با ثبات‌ها و دستورالعمل‌های ماشینی مخصوص خود
    دارند. معماری x64 از نسل سوم کوپروسسور ریاضی، یعنی AVX استفاده می‌کند.
    (معماری‌های MMX و SSE نسل اول و دوم هستند که پیش از AVX آمده‌اند.)</p>
<p>اغلب این پرسش مطرح می‌شود که چه زمانی CPUهای 128 بیتی خواهیم داشت؟
    حقیقت این است که ما همین حالا هم آن‌ها را برای موارد مهم داریم. تنها جایی
    که ثبات‌های 128 بیتی ضروری هستند در کاربردهای پیشرفته‌ی ریاضی، مانند
    مدل‌سازی سه‌بعدی، پردازش ویدیو، رمزنگاری، فشرده‌سازی داده و هوش مصنوعی است.
    همه‌ی CPUهای مدرن که SSE دارند از ثبات‌های 128 بیتی برای کوپروسسور ریاضی
    استفاده می‌کنند. (CPU همه‌منظوره نمی‌تواند مستقیماً از آن‌ها استفاده کند.) و
    اینجا متوقف نمی‌شود. AVX اندازه را به 256 بیت افزایش داد. و AVX-512،
    معرفی‌شده در سال 2021 عمدتاً برای CPUهای سرور، می‌تواند محاسبات خود را در
    ثبات‌های 512 بیتی انجام دهد. با وجود ثبات‌های ریاضی 128 بیتی، 256 بیتی و
    512 بیتی برای انجام محاسبات سنگین، نیازی اندک به گسترش ثبات‌های همه‌منظوره
    به 128 بیت باقی می‌ماند. 64 بیت به طور گسترده به عنوان یک «نقطه‌ی مطلوب»
    (sweet spot) برای محاسبات همه‌منظوره در نظر گرفته می‌شود و احتمالاً برای
    مدت بسیار طولانی همین‌طور باقی خواهد ماند.</p>
<p>توضیح نحوه‌ی استفاده از SSE یا AVX بسیار فراتر از محدوده‌ی این کتاب
    است. یک آموزش مقدماتی خوب را می‌توانید در کتاب Beginning x64 Assembly
    Programming اثر Jo Van Hoey (Apress, 2019) پیدا کنید. برنامه‌نویسی
    کوپروسسور ریاضی ظریف و پیچیده است. من توصیه می‌کنم ابتدا در اسمبلی x64
    معمولی به مهارت نسبی برسید و بعد به سراغ بخش ریاضی بروید.</p>
<p>چهار مدل اصلی برنامه‌نویسی اسمبلی</p>
<p>پیش‌تر در این فصل اشاره کردم که چهار مدل برنامه‌نویسی اصلی برای استفاده
    روی CPUهای 64 بیتی اینتل وجود دارد، اگرچه دو مورد از آن‌ها اکنون کهنه و
    قدیمی محسوب می‌شوند. تفاوت بین آن‌ها (عمدتاً) در نحوه‌ی استفاده از ثبات‌ها
    برای آدرس‌دهی حافظه است. (و سایر تفاوت‌ها، به ویژه در حالت‌های سطح بالا،
    بیشتر توسط سیستم‌عامل از دید شما پنهان می‌شوند.) در این بخش، چهار مدل را
    برای مرجع تاریخی خلاصه می‌کنم. تنها یکی از آن‌ها، حالت طولانی x64، در
    ادامه‌ی کتاب با جزئیات مورد بررسی قرار خواهد گرفت.</p>
<p>مدل تخت در حالت Real (Real-Mode Flat Model)</p>
<p>در حالت Real، اگر به خاطر داشته باشید، CPU فقط می‌تواند 1 مگابایت
    (1,048,576 بایت) از حافظه را ببیند. شما می‌توانید از حقه‌ی segment:offset
    برای ساختن یک آدرس 20 بیتی از دو آدرس 16 بیتی در ثبات‌های سگمنت و offset
    استفاده کنید تا به تمامی این یک مگابایت دسترسی یابید. یا می‌توانید به 64
    کیلوبایت حافظه اکتفا کنید و اصلاً با سگمنت‌ها سروکار نداشته باشید.</p>
<p>در مدل تخت حالت Real، برنامه‌ی شما و تمام داده‌هایی که روی آن کار می‌کند
    باید در یک بلاک 64 کیلوبایتی از حافظه قرار داشته باشند. 64 کیلوبایت! چه
    کاری می‌توان در 64 KB انجام داد؟ خب، اولین نسخه‌ی WordStar برای IBM PC در
    64 KB جا شد. همین‌طور سه نسخه‌ی اول Turbo Pascal—در واقع خود برنامه‌ی توربو
    پاسکال بسیار کمتر از 64 KB فضا داشت، چرا که کدهایش را در حافظه کامپایل
    می‌کرد. کل بسته‌ی توربو پاسکال—کامپایلر، ویرایشگر متن، و تعدادی ابزار
    جانبی—مجموعاً چیزی در حدود 39 کیلوبایت بود. 39 کیلوبایت! این روزها با
    مایکروسافت ورد حتی نمی‌توانید یک نامه برای مادرتان در این حجم کم
    بنویسید!</p>
<p>شکل 4.8 مدل تخت حالت Real را به صورت نمودار نشان می‌دهد. چیز زیادی
    ندارد. ثبات‌های سگمنت همه برای اشاره به ابتدای این بلوک 64 کیلوبایتی
    حافظه تنظیم می‌شوند. (سیستم‌عامل هنگام بارگذاری و اجرای برنامه‌ی شما این
    کار را انجام می‌دهد.) همه‌ی آن‌ها به یک مکان اشاره می‌کنند و تا زمانی که
    برنامه در حال اجراست، تغییری نمی‌کنند. با این شرایط، می‌توانید کاملاً آن‌ها
    را نادیده بگیرید. پووووف! دیگر هیچ ثبات سگمنتی، هیچ کار با سگمنت‌ها، و
    هیچ پیچیدگی زشتی که از آن‌ها ناشی شود، ندارید.</p>
<p>[تصویر مدل تخت حالت Real]</p>
<p>شکل 4.8: مدل تخت حالت Real</p>
<p>بیشتر ثبات‌های همه‌منظوره می‌توانند حاوی آدرس‌هایی از مکان‌های حافظه
    باشند. شما از آن‌ها همراه با دستورالعمل‌های ماشینی استفاده می‌کنید تا داده
    را از حافظه بیاورید و دوباره در حافظه بنویسید.</p>
<p>در بالای این سگمنت واحد که برنامه‌ی شما در آن قرار دارد، یک ناحیه‌ی
    کوچک به نام پشته (stack) وجود دارد. پشته یک محل ذخیره‌سازی LIFO (آخر
    وارد، اول خارج) است که ویژگی‌ها و کاربردهای بسیار ویژه‌ای دارد. من در
    فصل‌های بعدی با جزئیات فراوان توضیح خواهم داد که پشته چیست و چگونه کار
    می‌کند.</p>
<p><strong>مدل سگمنت‌بندی شده در حالت ریل (Real-Mode)</strong></p>
<p>دو نسخه‌ی اول این کتاب کاملاً بر مدل سگمنت‌بندی شده در حالت ریل متمرکز
    بودند، مدلی که در دوره‌ی MS-DOS به‌عنوان مدل اصلی برنامه‌نویسی مورد استفاده
    قرار می‌گرفت. این یک سیستم پیچیده و ناموزون است که شما را مجبور می‌کند
    قواعد و نکات ریز و متعددی را به خاطر بسپارید. من پیش‌تر در این فصل
    درباره‌ی سگمنت‌ها توضیح دادم و اینجا وارد جزئیات نخواهم شد، به‌ویژه با در
    نظر گرفتن اینکه امروزه مدل سگمنت‌بندی شده در حالت ریل به‌ندرت استفاده
    می‌شود.</p>
<p>در مدل سگمنت‌بندی شده‌ی حالت ریل، برنامه‌ی شما می‌تواند کل 1 مگابایت
    حافظه‌ای را که در این حالت در دسترس CPU است، مشاهده کند. این کار با ترکیب
    یک آدرس سگمنت 16 بیتی با یک آدرس افست 16 بیتی انجام می‌شود. البته این‌طور
    نیست که صرفاً این دو را کنار هم بگذارید و یک آدرس 32 بیتی ایجاد کنید.
    باید به توضیحات قبلی من درباره‌ی سگمنت‌ها برگردید. یک آدرس سگمنت در حقیقت
    یک آدرس حافظه‌ی مستقیم نیست. آدرس سگمنت یکی از 65,535 موقعیتی را مشخص
    می‌کند که یک سگمنت می‌تواند از آنجا آغاز شود. این موقعیت‌ها هر 16 بایت، از
    پایین‌ترین بخش حافظه تا بالاترین بخش آن، برقرار هستند. برای مثال، آدرس
    سگمنت 0000H اولین موقعیت را مشخص می‌کند که در اولین مکان حافظه قرار دارد.
    آدرس سگمنت 0001H موقعیت بعدی را تعیین می‌کند که 16 بایت بالاتر در حافظه
    است. با بالا رفتن 16 بایت دیگر به آدرس سگمنت 0002H می‌رسید و همین‌طور
    ادامه می‌یابد. شما می‌توانید یک آدرس سگمنت را با ضرب کردن آن در 16 به یک
    آدرس 20 بیتی واقعی حافظه تبدیل کنید. بنابراین آدرس سگمنت 0002H معادل
    آدرس حافظه‌ی 0020H است که سی‌ودومین بایت در حافظه محسوب می‌شود.</p>
<p>CPU خودش ترکیب سگمنت‌ها و افست‌ها را برای رسیدن به یک آدرس 20 بیتی کامل
    درونی‌سازی می‌کند. وظیفه‌ی شما این است که به CPU بگویید دو جزء مختلف این
    آدرس 20 بیتی کجاست. نشانه‌گذاری معمول این است که رجیستر سگمنت و رجیستر
    افست را با یک دونقطه از هم جدا کنند. برای مثال:</p>
<pre><code>SS : SP
SS : BP
ES : DI
DS : SI
CS : BX</code></pre>
<p>هر یک از این پنج ترکیب رجیستر، یک آدرس کامل 20 بیتی را مشخص می‌کند.
    برای مثال، ES:DI آدرسی را نشان می‌دهد که به‌اندازه‌ی DI از ابتدای سگمنتی که
    توسط ES مشخص شده، فاصله دارد.</p>
<p>[تصویری از مدل سگمنت‌بندی شده در حالت ریل]</p>
<p><strong>شکل 4.9: مدل سگمنت‌بندی شده در حالت ریل</strong></p>
<p>برای جمع‌بندی تصویری از مدل سگمنت‌بندی شده در حالت ریل، در شکل 4.9 یک
    نمودار ترسیم کرده‌ام که این مدل را نشان می‌دهد. در مقابل مدل مسطح حالت ریل
    (تصویر 4.8)، نمودار اینجا کل حافظه را نشان می‌دهد، نه فقط یک بخش کوچک 64
    کیلوبایتی که برنامه‌ی مدل مسطح حالت ریل شما هنگام اجرا دریافت می‌کند. یک
    برنامه که برای مدل سگمنت‌بندی شده‌ی حالت ریل نوشته شده باشد، می‌تواند تمام
    حافظه‌ی حالت ریل را ببیند.</p>
<p>در نمودار، دو سگمنت کد و دو سگمنت داده نشان داده شده است. در عمل، شما
    می‌توانید هر تعداد معقول از سگمنت‌های کد و داده داشته باشید، نه فقط دو تا
    از هر کدام. شما می‌توانید هم‌زمان به دو سگمنت داده دسترسی داشته باشید،
    زیرا دو رجیستر سگمنت برای این کار در اختیار دارید: DS و ES. (در
    پردازنده‌های 386 و بالاتر، دو رجیستر سگمنت اضافه‌ی دیگر به نام‌های FS و GS
    نیز وجود دارند.) هر یک از این‌ها می‌تواند یک سگمنت داده را مشخص کند و شما
    می‌توانید با استفاده از چندین دستور ماشینی داده را از یک سگمنت به سگمنت
    دیگر منتقل کنید. با این حال، شما فقط یک رجیستر سگمنت کد (CS) دارید. CS
    همواره به سگمنت کد جاری اشاره می‌کند و دستور بعدی که باید اجرا شود توسط
    رجیستر IP مشخص می‌شود. شما مستقیماً مقادیر را در CS بارگذاری نمی‌کنید تا از
    یک سگمنت کد به دیگری بروید. برنامه‌ی شما می‌تواند در چندین سگمنت کد گسترده
    باشد و زمانی که یک دستور پرش (Jump) — که انواع مختلفی دارد — نیاز داشته
    باشد اجرای برنامه را به یک سگمنت کد دیگر ببرد، مقدار CS را به‌طور خودکار
    برای شما تغییر می‌دهد.</p>
<p>برای هر برنامه فقط یک سگمنت پشته (Stack) وجود دارد که توسط رجیستر
    سگمنت پشته SS مشخص می‌شود. رجیستر پشته SP به آدرس حافظه‌ای (نسبت به SS،
    اما با جهت‌گیری برعکس در حافظه) اشاره می‌کند که عمل بعدی پشته در آن رخ
    می‌دهد. پشته نیاز به توضیح قابل توجهی دارد که بعداً به آن خواهم
    پرداخت.</p>
<p>باید به خاطر داشته باشید که در حالت ریل، سیستم عامل نیز همراه با
    داده‌های مهم سیستمی در حافظه حضور دارد. شما می‌توانید با استفاده‌ی بی‌دقت از
    رجیسترهای سگمنت بخش‌هایی از سیستم عامل را نابود کنید و باعث کرش کردن
    سیستم عامل شوید که برنامه‌ی شما را نیز با خود پایین خواهد کشید. این خطر
    همان چیزی است که اینتل را بر آن داشت تا ویژگی‌های جدیدی در پردازنده‌های
    80386 و بعد از آن برای پشتیبانی از حالت محافظت‌شده (Protected Mode) ایجاد
    کند. در حالت محافظت‌شده، برنامه‌های کاربردی (یعنی برنامه‌هایی که شما
    می‌نویسید، در مقابل سیستم عامل یا راه‌اندازهای دستگاه) نمی‌توانند سیستم
    عامل یا سایر برنامه‌های در حال اجرا در حافظه را از بین ببرند. معنای واژه‌ی
    “محافظت‌شده” دقیقاً همین است.</p>
<p><strong>مدل مسطح 32 بیتی در حالت محافظت‌شده</strong></p>
<p>پردازنده‌های اینتل از زمان ظهور 386 در سال 1985، یک معماری حالت
    محافظت‌شده بسیار خوب را پیاده‌سازی کرده‌اند. با این حال، برنامه‌های کاربردی
    نمی‌توانند به‌تنهایی از حالت محافظت‌شده استفاده کنند. سیستم عامل باید حالت
    محافظت‌شده را برپا کرده و مدیریت کند تا برنامه‌های کاربردی بتوانند درون آن
    اجرا شوند. MS-DOS نمی‌توانست این کار را انجام دهد و Microsoft Windows نیز
    واقعاً این کار را تا زمان عرضه‌ی Windows NT در سال 1994 نمی‌توانست. لینوکس،
    به دلیل نداشتن مسائل مربوط به “ارثیه‌ی” حالت ریل، از اولین ظهورش در سال
    1992 در حالت محافظت‌شده عمل کرده است.</p>
<p>برنامه‌های زبان اسمبلی حالت محافظت‌شده ممکن است هم برای لینوکس و هم
    برای نسخه‌های ویندوز (از NT به بعد) نوشته شوند. من ویندوز 9x را به دلایل
    فنی کنار می‌گذارم. مدل حافظه‌ی آن یک ترکیب عجیـب و اختصاصی از حالت ریل و
    حالت محافظت‌شده است و درک کامل آن بسیار دشوار — و امروزه تقریباً کاملاً
    بی‌اهمیت — است. همچنین توجه کنید که برنامه‌های نوشته‌شده برای ویندوز لزوماً
    گرافیکی نیستند. آسان‌ترین راه برای برنامه‌نویسی در حالت محافظت‌شده تحت
    ویندوز، ایجاد برنامه‌های کنسولی است؛ برنامه‌هایی به صورت متن که در یک
    پنجره‌ی متنی به نام “کنسول” اجرا می‌شوند. این کنسول از طریق یک خط فرمان
    کنترل می‌شود، مشابه آنچه در MS-DOS وجود داشت، اما با دستورات بسیار بیشتر.
    برنامه‌های کنسولی از مدل مسطح محافظت‌شده استفاده می‌کنند و نسبت به نوشتن
    برنامه‌های واسط گرافیکی در ویندوز یا لینوکس که من در این کتاب به آن‌ها
    نخواهم پرداخت، نسبتاً سرراست‌ترند.</p>
<p>من مدل مسطح 32 بیتی در حالت محافظت‌شده را در شکل 4.10 ترسیم کرده‌ام.
    برنامه‌ی شما یک بلوک پیوسته از آدرس‌های حافظه را از صفر تا کمی بیش از 4
    گیگابایت می‌بیند. هر آدرس یک عدد 32 بیتی است. همه‌ی رجیسترهای همه‌منظوره
    (GP) در این حالت 32 بیتی هستند، بنابراین یک رجیستر GP می‌تواند به هر
    مکانی در فضای آدرس 4 گیگابایتی اشاره کند. اشاره‌گر دستور (IP) هم 32 بیتی
    است، بنابراین EIP می‌تواند هر دستور ماشینی را در هر نقطه‌ی 4 گیگابایت
    حافظه نشان دهد.</p>
<p>[تصویری از مدل مسطح 32 بیتی در حالت محافظت‌شده]</p>
<p><strong>شکل 4.10: مدل مسطح 32 بیتی در حالت محافظت‌شده</strong></p>
<p>رجیسترهای سگمنت هنوز وجود دارند، اما به شکل بنیادینی متفاوت عمل
    می‌کنند. نه تنها نیازی به دست‌کاری آن‌ها ندارید، بلکه نمی‌توانید این کار را
    انجام دهید. اکنون رجیسترهای سگمنت بخشی از سیستم عامل محسوب می‌شوند و در
    اغلب موارد شما نه می‌توانید آن‌ها را بخوانید و نه تغییر دهید. وظیفه‌ی جدید
    آن‌ها مشخص کردن محل قرارگیری فضای 4 گیگابایتی شما در حافظه‌ی فیزیکی یا
    مجازی است. ممکن است حافظه‌ی فیزیکی بسیار بزرگ‌تر از 4 گیگابایت باشد و در
    زمان نگارش این مطلب، داشتن 4 گیگابایت حافظه چندان گران نیست. اما یک
    رجیستر 32 بیتی تنها می‌تواند 4,294,967,296 مکان مختلف را نشان دهد. اگر
    رایانه‌ی شما بیش از 4 گیگابایت حافظه داشته باشد، سیستم عامل باید یک
    محدوده‌ی 4 گیگابایتی را درون حافظه تعریف کند و برنامه‌های 32 بیتی شما
    محدود به فعالیت در همین محدوده خواهند بود. تعیین اینکه این محدوده‌ی 4
    گیگابایتی در کدام بخش از حافظه‌ی بزرگ‌تر شما قرار می‌گیرد، وظیفه‌ی رجیسترهای
    سگمنت است و سیستم عامل آن‌ها را به‌شدت تحت کنترل خود دارد.</p>
<p>من در این کتاب درباره‌ی حافظه‌ی مجازی زیاد توضیح نخواهم داد. حافظه‌ی
    مجازی سیستمی است که یک فضای حافظه‌ی بسیار بزرگ‌تر می‌تواند بر روی دیسک
    نگاشت شود، تا حتی اگر سیستم شما فقط 4 گیگابایت حافظه‌ی فیزیکی داشته باشد،
    CPU بتواند یک فضای حافظه‌ی “مجازی” را که میلیاردها بایت بزرگ‌تر است،
    آدرس‌دهی کند. باز هم، این کار توسط سیستم عامل انجام شده و تقریباً به شکلی
    شفاف برای نرم‌افزاری که شما می‌نویسید صورت می‌گیرد.</p>
<p>همین اندازه بدانید که وقتی برنامه‌ی x86 شما اجرا می‌شود، یک فضای آدرس 4
    گیگابایتی در اختیار آن قرار می‌گیرد تا در آن فعالیت کند، و هر رجیستر 32
    بیتی به‌تنهایی می‌تواند بالقوه هر یک از آن 4 میلیارد مکان حافظه را آدرس‌دهی
    کند. بله، این یک ساده‌سازی است، به‌ویژه برای رایانه‌های معمولی مبتنی بر
    اینتل. همه‌ی آن 4 گیگابایت در اختیار برنامه‌ی شما نیستند و بخش‌هایی از فضای
    حافظه وجود دارند که شما نمی‌توانید از آن‌ها استفاده کنید یا حتی به آن‌ها
    نگاه کنید. متأسفانه، قواعد مربوط به این موضوع خاص سیستم عاملی هستند که
    شما تحت آن کار می‌کنید و من نمی‌توانم بدون اشاره به لینوکس یا ویندوز NT یا
    یک سیستم عامل محافظت‌شده‌ی دیگر بیش از این تعمیم بدهم.</p>
<p>اما ارزش دارد که نگاهی به شکل 4.8 بیندازید و آن را با مدل مسطح 32
    بیتی در حالت محافظت‌شده مقایسه کنید. تفاوت اصلی این است که در مدل مسطح
    حالت ریل، برنامه‌ی شما مالک تمام 64 کیلوبایت حافظه‌ای است که سیستم عامل به
    آن داده است. اما در مدل مسطح 32 بیتی حالت محافظت‌شده، شما بخشی از آن 4
    گیگابایت حافظه را دارید، در حالی که سایر بخش‌ها همچنان متعلق به سیستم
    عامل هستند. جدا از این موضوع، شباهت‌ها چشمگیرند: یک رجیستر همه‌منظوره (GP)
    می‌تواند به تنهایی هر مکان حافظه‌ای را در فضای کامل آدرس‌دهی مشخص کند، و
    رجیسترهای سگمنت ابزارهای سیستم عامل هستند، نه ابزار شما به عنوان
    برنامه‌نویس کاربردی.</p>
<p><strong>حالت لانگ 64 بیتی</strong></p>
<p>خلاصه‌های قبلی بیشتر جنبه‌ی تاریخی داشتند. حالت چهارمی که بررسی می‌کنیم
    همان حالتی است که در این کتاب برای نمونه‌های کد واقعی از آن استفاده
    خواهیم کرد.</p>
<p>معماری x64 سه حالت کلی را تعریف می‌کند: حالت ریل، حالت محافظت‌شده، و
    حالت لانگ (طولانی) 64 بیتی. حالت ریل یک حالت سازگاری است که اجازه می‌دهد
    CPU سیستم عامل‌ها و نرم‌افزارهای قدیمی حالت ریل مانند DOS و ویندوز 3.1 را
    اجرا کند. در حالت ریل، CPU دقیقاً مانند یک CPU 16 بیتی x86 عمل می‌کند و از
    مدل مسطح حالت ریل و مدل سگمنت‌بندی شده‌ی حالت ریل پشتیبانی می‌کند. حالت
    محافظت‌شده نیز یک حالت سازگاری است و CPU را از دید نرم‌افزار مانند یک CPU
    32 بیتی جلوه می‌دهد تا پردازنده‌های x64 بتوانند ویندوز 2000/XP/Vista/7/8 و
    سایر سیستم عامل‌های 32 بیتی مانند نسخه‌های قدیمی لینوکس و همچنین درایورها
    و برنامه‌های 32 بیتی آن‌ها را اجرا کنند. (ویندوز 10 و 11 در ساخت‌های 64
    بیتی جدید، کاملاً 64 بیتی هستند.)</p>
<p>اما این حالت‌های 16 و 32 بیتی صرفاً برای حفظ سازگاری با نرم‌افزارهای
    قدیمی تعبیه شده‌اند. حالت لانگ یک حالت واقعی 64 بیتی است. وقتی CPU در
    حالت لانگ است، همه‌ی رجیسترها جز سگمنت رجیسترها 64 بیتی می‌شوند و تمام
    دستوراتی که روی عملوندهای 64 بیتی کار می‌کنند، در دسترس خواهند بود. در
    این حالت فقط یک سگمنت وجود دارد که تا جایی که در حال حاضر استطاعت دارید
    (از لحاظ حافظه)، می‌تواند بسیار بزرگ باشد. هر چیزی که بخشی از برنامه‌ی
    شماست یا داده‌هایی که برنامه‌ی شما روی آن‌ها کار می‌کند، کاملاً درون همین یک
    سگمنت عظیم قرار دارند. حالت لانگ x64 آن‌قدر مفهومی ساده است که من برای آن
    نموداری رسم نکرده‌ام. این حالت تقریباً دقیقاً شبیه شکل 4.10 است، با این
    تفاوت که دیگر سقف 4 گیگابایتی وجود ندارد.</p>
<p>حالت لانگ نیز یک حالت محافظت‌شده است، و محاسبات عادی نیازمند یک سیستم
    عامل است که حالت محافظت‌شده را درک کند و کارهای عمیق درونی آن را انجام
    دهد. در حالت لانگ، رجیسترهای سگمنت متعلق به سیستم عامل هستند و شما نیازی
    ندارید آن‌ها را دستکاری کرده یا حتی از وجودشان آگاه باشید، به‌ویژه به‌عنوان
    یک مبتدی.</p>
<p>در مورد آدرس‌دهی حافظه در حالت لانگ x64 جزئیات بسیار بیشتری وجود دارد
    که بدون توضیح مقداری درباره‌ی فرایند برنامه‌نویسی و ابزارهایی که برای این
    کار استفاده می‌کنید، امکان تشریح کامل آن نیست.</p>

</body>
</html>