<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
<p><strong>فصل 6: جایی برای ایستادن، همراه با دسترسی به ابزارها: لینوکس
    و ابزارهایی که روش کار شما را شکل می‌دهند</strong></p>
<p><strong>محیط‌های توسعه یکپارچه</strong></p>
<p>ارشمیدس، مهندس اولیه، یک ضرب‌المثل محبوب داشت: “به من یک اهرم به
    اندازه کافی بلند بده و جایی برای ایستادن، و من زمین را حرکت خواهم داد.”
    او به طور واقعی درباره مزیت مکانیکی اهرم‌های خیلی بلند صحبت می‌کرد، اما
    پشت سر حرف‌هایش حقیقت بزرگتری درباره کار به طور کلی نهفته است: برای انجام
    کاری، شما نیاز به یک جایگاه دارید که ابزارها در دسترس شما باشند. میز
    رادیویی من در گاراژ کوچک به همین شکل تنظیم شده است: یک فضای بزرگ و صاف
    برای قرار دادن فرستنده‌های خراب و یک قفسه بالای آن که اسیلوسکوپ، VTVM،
    شمارنده فرکانس، ژنراتور سیگنال، ردیاب سیگنال و دستگاه DIP در دسترس
    هستند. در دیوار مقابل، فقط دو قدم فاصله دارد، یک ردیف طولانی از قفسه‌ها
    که در آن قطعات، مواد اولیه مانند ورق فلزی، تخته مدار و پلاستیک ضایعاتی و
    تجهیزات آزمایشی که به ندرت به آنها نیاز دارم، نگهداری می‌شود.</p>
<p>در برخی جنبه‌ها، سیستم‌عامل جایی است که شما برای انجام کار محاسباتی خود
    ایستاده‌اید. تمام ابزارهایی که به آنها نیاز دارید باید در دسترس شما باشند
    و باید روشی استاندارد و قابل فهم برای دسترسی به آنها وجود داشته باشد.
    ذخیره‌سازی داده‌های شما باید “نزدیک” و به راحتی قابل مرور و جستجو باشد.
    سیستم‌عامل لینوکس این نیاز را به شکلی بسیار بهتر از هر سیستم‌عامل دسکتاپ
    دیگری برآورده می‌کند.</p>
<p>سیستم‌عامل‌های قدیمی مانند DOS جایی برای ایستادن به ما دادند، اما به
    شکل محدودی. DOS دسترسی به ذخیره‌سازی دیسک و روشی استاندارد برای بارگذاری
    و اجرای نرم‌افزار فراهم کرد و چیز بیشتری نداشت. مجموعه ابزارها کوچک بود،
    اما شروع خوبی بود و تقریباً همه آنچه که می‌توانستیم روی دستگاه‌های 6
    مگاهرتزی 8088 که در اواسط تا اواخر دهه 1980 رایج بودند، انجام دهیم.</p>
<p>در برخی جنبه‌ها، جالب‌ترین نکته در مورد DOS 2.0 این بود که به عنوان یک
    نسخه “ساده‌شده” از یک سیستم‌عامل بسیار قدرتمندتر به نام یونیکس ایجاد شده
    بود، که در دهه‌های 1960 و 1970 در آزمایشگاه‌های تحقیقاتی AT&amp;T توسعه
    یافته بود. در زمان ظهور کامپیوتر IBM PC، یونیکس فقط روی رایانه‌های بزرگ و
    گران‌قیمت اصلی و مینی‌کامپیوترها اجرا می‌شد. PC توان محاسباتی لازم برای
    اجرای یونیکس را نداشت، اما DOS 2.0 با یک سیستم فایل سلسله‌مراتبی شبیه به
    سیستم فایل یونیکس ایجاد شد و خط فرمان آن دسترسی به یک زیرمجموعه از
    ابزارها را که بسیار شبیه به ابزارهای یونیکس بودند، فراهم کرد.</p>
<p>کامپیوتر x86 با گذشت زمان رشد کرد و تا سال 1990، پردازنده‌های اینتل به
    اندازه کافی قدرتمند شده بودند تا یک سیستم‌عامل مدل شده بر اساس یونیکس را
    اجرا کنند. در همین حال، یونیکس “پایین آمد” تا اینکه هر دو در جایی در وسط
    به هم رسیدند. در سال 1991، برنامه‌نویس فنلاندی جوان، لینوس توروالدز، یک
    سیستم‌عامل شبیه به یونیکس نوشت که می‌توانست روی یک کامپیوتر PC مبتنی بر
    386 اجرا شود. این سیستم‌عامل بر اساس یک پیاده‌سازی از یونیکس به نام Minix
    مدل شده بود که در اواخر دهه 1980 در هلند نوشته شده بود تا شبیه یونیکس
    باشد و بر روی کامپیوترهای کوچک اجرا شود. سیستم‌عامل لینوکس توروالدز در
    نهایت به تسلط بر دنیای یونیکس رسید.</p>
<p>لینوکس جایگاهی است که شما ایستاده‌اید و این جایگاه خوبی است. اما از
    نظر دسترسی به ابزارها، همچنین مفید است که یک نوع میز کار نرم‌افزاری
    مخصوصاً برای نوع کاری که در حال حاضر انجام می‌دهیم، داشته باشیم.
    پردازشگرهای کلمه میزهای کاری برای نوشتن و چاپ محتوای متنی (عمدتاً) هستند.
    PowerPoint و کلون‌های آن میزهای کاری برای ایجاد ارائه‌ها هستند و
    همین‌طور.</p>
<p>مترجم NASM قدرتمند است، اما کم‌حرف و ناگزیر به خط فرمان متصل است،
    مانند ld، gdb و بیشتر ابزارهای قدیمی یونیکس که در جعبه ابزار لینوکس
    خواهید یافت. در فصل 5، ما از روش قدیمی با تایپ دستورات در خط فرمان
    ترمینال برای انجام یک پروژه توسعه ساده استفاده کردیم. مبتدیان باید
    بدانند که این چگونه کار می‌کند، اما این بهترین چیزی نیست که می‌توانیم
    انجام دهیم. همچنین، ممکن است در نهایت از محیط توسعه تعاملی که استفاده
    می‌کنید، خارج شوید. شرایط خاصی می‌تواند شما را مجبور کند که دوباره به خط
    فرمان لینوکس بازگردید تا کار را انجام دهید.</p>
<p>موفقیت افسانه‌ای Turbo Pascal برای DOS در دهه 1980 به دلیل این بود که
    یک ویرایشگر و یک کامپایلر را با هم یکپارچه کرده بود. این یک منو ارائه
    می‌داد که اجازه می‌داد به راحتی و سریع میان ویرایشگر برای نوشتن کد،
    کامپایلر برای کامپایل کد به فایل‌های اجرایی و DOS برای اجرای این فایل‌ها
    جابجا شوید. برنامه‌نویسی در Turbo Pascal نسبت به روش‌های سنتی که شامل صدور
    مداوم دستورات از خط فرمان می‌شد، سریع‌تر و آسان‌تر بود.</p>
<p>Turbo Pascal اولین محصول تجاری موفقی بود که یک محیط توسعه تعاملی
    (IDE) برای برنامه‌نویسان سیستم‌های کوچک فراهم می‌آورد. سایر IDEها قبلاً ظاهر
    شده بودند (به‌ویژه UCSD P-system اولیه که بیشتر در دانشگاه‌ها استفاده
    می‌شد)، اما Turbo Pascal این ایده را برای همیشه روی نقشه قرار داد.</p>
<p>در ویرایش قبلی این کتاب (ویرایش سوم، 2009)، من مجموعه ابزاری شامل
    ویرایشگر Kate، ترمینال Konsole و رابط جلویی قدرتمند ولی غیرمعمول Insight
    برای اشکال‌زدایی gdb را معرفی کردم. در اجرای 2009 در فصل 5، یک رابط
    اشکال‌زدا ساده‌تر به نام Kdbg را معرفی کردم.</p>
<p>زمان‌ها تغییر می‌کنند. Insight از توزیع‌ها و مخازن لینوکس در اواخر 2009
    حذف شد، مدت کوتاهی پس از انتشار ویرایش سوم. از آن زمان به بعد
    abandonware شده است و نصب آن بر روی توزیع‌های مدرن لینوکس بسیار دشوار
    است. جایی در مسیر به سمت 2022، Kdbg نیز از صحنه لینوکس ناپدید شد و
    نمی‌توان آن را بر روی بیشتر توزیع‌های اخیر نصب کرد. من از هر دو محصول خوشم
    می‌آمد، اما فکر می‌کنم دلیل اینکه از رده خارج شدند را درک می‌کنم. Kate و
    Konsole هنوز به‌طور کامل در دسترس هستند. من در این فصل، Konsole را به
    تفصیل توضیح خواهم داد، در بخشی تحت عنوان “ترمینال لینوکس”. شما می‌توانید
    از Kate استفاده کنید، اما برای ویرایش متن ساده، من ویرایشگر Xed را ترجیح
    می‌دهم. برای اشکال‌زدایی هم به پیوست A نگاه کنید. Insight برگشته است.</p>
<p>بیشتر.</p>
<p>در تهیه این ویرایش، من یک چیز شگفت‌انگیز پیدا کردم: یک IDE طراحی شده
    مخصوصاً برای کار با زبان اسمبلی، با تأکید بر برنامه‌نویسان مبتدی. Simple
    ASM (SASM) توسط Dmitriy Manushin نوشته شده است. هنوز نگهداری می‌شود و
    هنوز در حال توسعه فعال است. این قدرتمند است تا بیشتر برنامه‌های ساده‌ای را
    که در این کتاب ارائه می‌کنم، مدیریت کند. این همچنین راه خوبی برای معرفی
    اشکال‌زدایی است.</p>
<p>حال، همانطور که در برخی جنبه‌ها خوب است، SASM برای مبتدیان طراحی شده
    است و فاقد برخی ویژگی‌های پیشرفته است. این یک مکان عالی برای شروع است و
    به شما ایده‌ای از اینکه IDE چیست، می‌دهد. مطمئناً، زمانی که شروع به نوشتن
    برنامه‌های بزرگ اسمبلی یا ترکیب اسمبلی با C کنید، SASM کافی نخواهد بود.
    من همچنین ابزار Make که همراه با لینوکس است را پوشش خواهم داد تا وقتی از
    SASM بزرگ‌تر شدید، بدانید چگونه فایل‌های make خود را بسازید. و در حالی که
    SASM پنجره ترمینال خود را دارد، من ترمینال قدرتمندتر Konsole را توضیح
    خواهم داد، همانطور که در 2009 کردم.</p>
<p>دیباگر قدیمی Insight دوباره اجرا شده است. به پیوست A مراجعه کنید. این
    ابزار کامل نیست، اما هنوز هم نسبت به سایر دیباگرهای مستقل رایگان برای
    لینوکس، برای مبتدیان مناسب‌تر است.</p>
<p>در دنیای لینوکس IDEهای دیگری هم وجود دارند که قدرت بیشتری دارند،
    مانند KDevelop، Geany و Eclipse. تلاش برای توضیح مفید هر کدام از این‌ها
    در اینجا فضایی بیشتر از آنچه که در این کتاب دارم می‌طلبد. وقتی اصول
    پایه‌ای IDEها را درک کردید، می‌توانید آن‌ها را نصب کرده و بر اساس نیازها و
    مهارت‌های خود یاد بگیرید. در این میان، ما با SASM شروع می‌کنیم و به Make و
    Konsole می‌پردازیم.</p>
<p>من SASM را در لینوکس مینت سینامون و کوبانتو پلازما آزمایش کرده‌ام. این
    ابزار در هر دو توزیع کار می‌کند و می‌توان آن را با استفاده از مدیر بسته هر
    پلتفرم نصب کرد. حدس من این است که روی هر توزیع مدرن لینوکس کار خواهد
    کرد.</p>
<p><strong>معرفی SASM</strong></p>
<p>SASM یک IDE ساده است که به طور خاص برای برنامه‌نویسی زبان اسمبلی طراحی
    شده است. ویژگی‌های اصلی آن به شرح زیر است:</p>
<ul>
    <li>پشتیبانی از اسمبلرهای NASM، FASM، MASM و gas. (MASM فقط تحت ویندوز
        کار می‌کند.)</li>
    <li>پشتیبانی از جلسات، به طوری که می‌توانید چندین پروژه را به طور همزمان
        باز داشته باشید.</li>
    <li>ویرایشگر کد منبع با برجسته‌سازی نحو رنگی کامل.</li>
    <li>پنجره‌های ترمینال جداگانه برای ورودی و خروجی استاندارد.</li>
    <li>یک دیباگر کد منبع که به شما این امکان را می‌دهد که از نقطه توقف‌ها و
        اجرای گام به گام در پروژه‌های زبان اسمبلی خود استفاده کنید.</li>
    <li>نمایش رجیسترها در حین دیباگ کردن و نمایش مفید (اگرچه محدود) از
        حافظه.</li>
</ul>
<p>برای نصب آن، باید از مدیر بسته‌ای که در توزیع لینوکس شما موجود است
    استفاده کنید. مدیر بسته در مینت به نام “Software Manager” است. در
    کوبانتو به نام “Discover” شناخته می‌شود. (کوبانتو نسخه پیشرفته‌تری از
    Discover به نام Muon Discover دارد، اما Discover ساده به راحتی جواب
    می‌دهد.)</p>
<p>هر دو مدیر بسته یک فیلد جستجو دارند. فقط عبارت “SASM” را تایپ کرده و
    Enter را فشار دهید. ممکن است تعداد زیادی از نتایج جستجو ظاهر شوند که هیچ
    ارتباطی با زبان اسمبلی (یا برنامه‌نویسی) نداشته باشند، اما باید در بالای
    نتایج خطی برای SASM ببینید. روی آن کلیک کنید. مدیر بسته توضیحی از SASM
    را نشان خواهد داد.</p>
<p>مانند هر نصب دیگری، از شما خواسته می‌شود که رمز عبور لینوکس خود را
    وارد کنید. اما به محض وارد کردن آن، SASM بر روی هارد دیسک شما نصب خواهد
    شد. در منوی نرم‌افزار، آن در دسته‌بندی برنامه‌نویسی قرار می‌گیرد. توصیه
    می‌کنم که یک آیکون روی دسکتاپ خود ایجاد کنید. فقط روی ورودی SASM در
    دسته‌بندی برنامه‌نویسی راست‌کلیک کرده و گزینه “Add To Desktop” را انتخاب
    کنید.</p>
<p><strong>پیکربندی SASM</strong></p>
<p>تنظیمات زیادی برای پیکربندی وجود ندارد. همه تنظیمات از طریق کادر
    گفتگوی Settings انجام می‌شود. لیست تنظیمات به شرح زیر است:</p>
<ul>
    <li>در برگه Settings ➪ Common، گزینه “On Start” را باز کرده و “Restore
        Previous Session” را انتخاب کنید. شما نمی‌خواهید هر بار که SASM را اجرا
        می‌کنید، پنجره “Get Started” را ببینید.</li>
    <li>روی دکمه رادیویی “No, Show Only General-Purpose” برای نمایش رجیسترها
        کلیک کنید. ما در اینجا ویژگی‌های ریاضی x64 AVX را بررسی نخواهیم کرد،
        بنابراین نمایش رجیسترهای ریاضی فقط پنجره SASM را شلوغ می‌کند.</li>
    <li>در برگه Settings ➪ Build (نگاه کنید به شکل 6.1)، دکمه رادیویی x64 را
        برای کدنویسی 64 بیتی انتخاب کنید. SASM همچنین از کد 32 بیتی x86 پشتیبانی
        می‌کند، و گزینه x86 پیش‌فرض است. این موضوع اهمیت دارد. شما قرار است کد x64
        بنویسید، و اگر x86 را انتخاب کرده باشید، SASM قادر به پردازش صحیح کد
        منبع x64 نخواهد بود.</li>
    <li>همچنین در برگه Settings ➪ Build، گزینه “Build In Current Directory”
        را علامت بزنید.</li>
    <li>بقیه تنظیمات را برای زمان حال می‌توانید دست نخورده بگذارید.</li>
</ul>
<p><strong>فونت‌های SASM</strong></p>
<p>در حال حاضر (2023)، استفاده از فونت‌ها در SASM کمی مشکل دارد. بیشتر
    افرادی که برنامه‌نویسی می‌کنند، از فونت‌های تک‌عرضه مانند Courier استفاده
    می‌کنند. با استفاده از فونت‌های تک‌عرضه مانند Courier، تمامی ستون‌ها به طور
    عمودی مرتب می‌شوند زیرا عرض هر کاراکتر یکسان است.</p>
<p>فونت پیش‌فرض SASM، Liberation Mono است که مانند Courier یک فونت تک‌عرضه
    واقعی نیست. شما می‌توانید فونت پنجره ویرایشگر را در بخش Settings ➪ Common
    تغییر دهید. فونت را به Courier 10 Pitch تغییر دهید. این یک فونت تک‌عرضه
    واقعی است و کمی پررنگ‌تر از سایر فونت‌های تک‌عرضه‌ای است که SASM ارائه می‌دهد
    (و بنابراین خواندن آن راحت‌تر است).</p>
<p>یکی دیگر از مشکلات فونت‌ها این است که شما فقط می‌توانید فونت را برای
    پنجره ویرایشگر مشخص کنید. فونت پنجره‌های ورودی و خروجی قابل تغییر نیست.
    این فونت چیزی شبیه به تک‌عرضه نیست، بنابراین اگر قصد دارید متن یا اعداد
    را در ستون‌های مرتب شده خروجی دهید، پنجره خروجی مناسب نخواهد بود. برای
    آزمایش این نوع خروجی، فایل EXE را از SASM ذخیره کرده و پس از خروج از
    SASM، برنامه را در داخل Konsole اجرا کنید.</p>
<p>یک نگاه سریع به SASM</p>
<p>پس بیایید نگاهی به قابلیت‌های SASM بیندازیم و بعداً آن را با جزئیات
    بیشتر توضیح می‌دهم. با استفاده از فایل کد منبع فهرست 6.1 در دایرکتوری‌اش،
    از منوی File ➪ Open برای پیمایش به دایرکتوری استفاده کنید و زمانی که
    فایل منبع هایلایت شد، روی Select کلیک کنید. SASM فایل منبع را در پنجره
    منبع خود بارگذاری می‌کند.</p>
<p>یک پرانتز کوتاه: پنجره SASM می‌تواند زمانی که در حالت اشکال‌زدایی
    (debug) هستید، خیلی شلوغ شود، بنابراین به شدت توصیه می‌کنم که همیشه SASM
    را در حین استفاده به حداکثر اندازه برسانید.</p>
<p>اولین گام ساخت فایل اجرایی است. «ساخت» در اینجا شامل فرآیندهای اسمبلی
    و لینک است که SASM آنها را در یک مرحله انجام می‌دهد. آیکون چکش در نوار
    ابزار فرآیند ساخت را شروع می‌کند. روی آن کلیک کنید.</p>
<p>ساخت در یک کامپیوتر سریع کمتر از یک ثانیه طول می‌کشد. در پنل لاگ در
    پایین پنجره SASM، عبارت «Built successfully» به رنگ سبز نمایش داده
    می‌شود. سبز به معنای این است که همه چیز خوب است. هرگونه خطای ساخت به رنگ
    قرمز ظاهر می‌شود.</p>
<p>برای اجرای برنامه، روی آیکون Run کلیک کنید، که مثلث سبز رنگی است که
    در سمت راست آیکون Build قرار دارد. پنجره لاگ گزارش می‌دهد که برنامه شروع
    به اجرا کرده و به طور معمول تمام شده است. در پنجره خروجی، پیغام «Eat at
    Joe’s!» نمایش داده خواهد شد.</p>
<p>بله، اینقدر ساده است—اگر برنامه شما به درستی کار کند. اگر اینطور
    نیست، باید اشکال‌زدایی را آغاز کنید. آیکون Debug یک مثلث سبز است که یک
    حشره خاکستری کوچک در جلوی آن قرار دارد. (ممکن است لازم باشد که با دقت
    نگاه کنید تا متوجه شوید که این یک حشره است.) روی آیکون Debug کلیک کنید.
    دوباره، اگر هنوز پنجره SASM را به حداکثر اندازه در نیاورده‌اید، این کار
    را اکنون انجام دهید، زیرا زمانی که در حالت اشکال‌زدایی هستید، اتفاقات
    زیادی در چندین پنل پنجره در حال رخ دادن است و شما به فضای صفحه نمایش
    بیشتری نیاز دارید.</p>
<p>دو گزینه از منوی Debug پس از وارد شدن به حالت اشکال‌زدایی فعال خواهند
    شد. روی Show Registers و Show Memory کلیک کنید. در سمت راست پنجره، یک
    پنل جدید باز خواهد شد. این پنل، پنل ریجسترها است و محتوای تمام ریجسترهای
    عمومی x64 را نشان می‌دهد. (ریجسترهای هم‌محاسباتی ریاضی در صورتی که SASM را
    به درستی برای دموهای این کتاب تنظیم کرده باشید، در آنجا نخواهند بود.)
    نکته: شما تنها زمانی که در حالت اشکال‌زدایی هستید، می‌توانید پنل ریجسترها
    را ببینید. همچنین، تا زمانی که شروع به گام‌برداری (single-stepping)
    نکرده‌اید، پنجره ریجستر همیشه پر نخواهد شد.</p>
<p>پنل Memory در بالای پنجره SASM ظاهر خواهد شد. استفاده از آن می‌تواند
    پیچیده باشد، همانطور که بعداً توضیح خواهم داد.</p>
<p>پنجره SASM در این مرحله شبیه به شکل 6.2 خواهد بود.</p>
<p>[تصویر پنجره کامل SASM در حالت اشکال‌زدایی.]</p>
<p>شکل 6.2: پنجره کامل SASM در حالت اشکال‌زدایی</p>
<p>در پنجره‌ی منبع، یک نوار هایلایت زرد رنگ روی اولین خط کد اجرایی (نه
    کامنت‌ها یا برچسب‌ها) نمایش داده خواهد شد. اجرای برنامه در آن خط متوقف
    می‌شود. به این توقف، نقطه توقف (breakpoint) می‌گوییم. در SASM، اولین خط کد
    همیشه یک نقطه توقف پیش‌فرض است زمانی که وارد حالت اشکال‌زدایی (debug mode)
    می‌شوید. من عبارت “پیش‌فرض” را به کار می‌برم چون می‌توانید نقطه توقف خود را
    روی هر خطی از کد تنظیم کنید، با کلیک کردن روی شماره آن خط در حاشیه سمت
    چپ پنجره‌ی منبع. برای شروع، شماره خط مربوط به این خط را کلیک کنید:</p>
<pre><code>mov rax,1</code></pre>
<p>یک نقطه قرمز به سمت راست شماره خط ظاهر می‌شود. این نشان می‌دهد که یک
    نقطه توقف در آن خط وجود دارد.</p>
<p>حالا روی آیکون Debug کلیک کنید. پس از ورود به حالت اشکال‌زدایی، آیکون
    Debug به SASM دستور می‌دهد که اجرای برنامه را ادامه دهد. هایلایت به نقطه
    توقف شما منتقل می‌شود. نکته مهم این است که: اجرای برنامه قبل از آنکه خط
    نقطه توقف اجرا شود، در آن توقف می‌کند. دستور MOV که هایلایت شده هنوز اجرا
    نشده است.</p>
<p>این زمان خوبی است برای مشاهده عملکرد پنجره‌ی رجیسترها. رجیستر RAX
    اولین رجیستر در لیست است. این رجیستر مقداری از نوع خاصی خواهد داشت. این
    مقدار اهمیت ندارد. این چیزی است که من به آن “باقی‌مانده‌ها” می‌گویم، که از
    کارهایی که SASM قبل از شروع اجرای برنامه با رجیستر RAX انجام داده باقی
    مانده است.</p>
<p>با توقف اجرای برنامه و انتظار برای دستور شما، روی آیکون Step Over که
    بلافاصله سمت راست آیکون Debug قرار دارد، کلیک کنید. هایلایت به خط کد
    بعدی منتقل خواهد شد. اگر محتوای رجیستر RAX را در پنجره‌ی رجیسترها مشاهده
    کنید، می‌بینید که اکنون مقدار 1 را در خود نگه می‌دارد.</p>
<p>اگر دوباره روی آیکون Step Over کلیک کنید، هایلایت به خط دیگری منتقل
    می‌شود و دستور MOV RDI,1 اجرا خواهد شد. می‌توانید مقدار RDI را در پنجره‌ی
    رجیسترها چک کنید تا ببینید که آن هم اکنون مقدار 1 را در خود نگه
    می‌دارد.</p>
<p>شما می‌توانید با کلیک بر روی آیکون Step Over، اجرای برنامه را خط به خط
    پیگیری کنید. زمانی که آخرین دستور SYSCALL اجرا شود، برنامه تمام خواهد شد
    و حالت اشکال‌زدایی به پایان می‌رسد. پنجره‌های رجیسترها و حافظه از بین
    خواهند رفت.</p>
<p>احتمالاً متوجه شده‌اید که دو آیکون Step وجود دارد، یکی Step Over و
    دیگری Step Into. تفاوت آنها چیست؟ برای برنامه‌های بسیار ساده مانند این
    یکی، تفاوتی ندارند. این دو تفاوت خود را زمانی نشان می‌دهند که شما رویه‌ها
    (procedures) و کتابخانه‌های رویه‌ای (procedure libraries) را برای
    برنامه‌های اسمبلی خود ایجاد کنید. شما با دستور CALL یک رویه را فرا
    می‌خوانید. اما فرض کنید رویه‌ی شما قبلاً به درستی کار می‌کند. نیازی به گام
    به گام پیش رفتن در آن نیست. بنابراین با کلیک روی دکمه Step Over،
    فراخوانی رویه را می‌گذارید و ادامه می‌دهید. اگر به جای آن Step Into را
    کلیک کنید، SASM به شما اجازه می‌دهد تا دستورات ماشین مربوط به رویه را گام
    به گام مشاهده کنید، قبل از اینکه به مکان برنامه‌ای که فراخوانی رویه در آن
    انجام شده بازگردید.</p>
<p>من این موضوع را در فصل‌های بعدی که به رویه‌ها می‌پردازیم، به طور کامل‌تر
    توضیح می‌دهم.</p>
<p>خلاصه اینکه، اشکال‌زدا به شما این امکان را می‌دهد که از دو طریق “داخل”
    کد اسمبلی را ببینید: با اجازه دادن به شما برای تنظیم نقطه توقف و اجرای
    کد با سرعت کامل تا رسیدن به نقطه توقف؛ یا با گام به گام پیش رفتن، توقف
    پس از هر گام برای مشاهده‌ی رجیسترها یا حافظه. البته شما می‌توانید از هر دو
    روش استفاده کنید، با استفاده از نقطه توقف برای رسیدن سریع به نقطه مورد
    نظر و سپس گام به گام پیش رفتن در ناحیه‌ی مورد علاقه برای مشاهده‌ی آنچه در
    حال انجام است.</p>
<p>ویرایشگر SASM</p>
<p>ویرایشگر SASM بسیار ابتدایی است. بیشتر دستورات رایج ویرایشگر متن که
    در ویرایشگرهای کد منبع استفاده می‌شوند را ارائه می‌دهد: باز کردن، ذخیره
    کردن، ذخیره به نام، بستن، انتخاب همه، برش، کپی، چسباندن، و
    جستجو/جایگزینی. تنها چیزی که من از دست داده‌ام دستور حذف خط است که با
    میان‌بر قدیمی Ctrl+Y انجام می‌شود. برای حذف یک خط، باید آن را با موس
    انتخاب کرده و سپس کلید Delete را فشار دهید. من اعتراف می‌کنم که این ممکن
    است به عنوان یک ویژگی ایمنی در نظر گرفته شود، حداقل زمانی که شما هنوز در
    حال شروع هستید.</p>
<p>آنچه SASM از کد شما می‌خواهد</p>
<p>اگر به دقت به برنامه‌ی نمایشی eatsyscallgcc.asm نگاه کنید، ممکن است
    چند تفاوت بین آن و برنامه eatsyscall.asm که قبلاً بررسی کردیم، مشاهده
    کنید. SASM دو الزامات دارد به دلیل استفاده از gcc به عنوان مدیر
    لینک.</p>
<ul>
    <li>نقطه ورود برنامه باید main باشد نه _start و main باید به حروف کوچک
        نوشته شود؛ به توضیحات زیر مراجعه کنید.</li>
    <li>اولین خط از بدنه برنامه باید MOV RBP,RSP باشد. NASM به طور پیش‌فرض
        حساس به حروف نیست و فرم کوچک mov rbp,rsp همان چیزی است که شما در پنجره
        ویرایشگر مشاهده خواهید کرد. این به طور عمدی است: شما باید با هر دو نوع
        کد منبع به حروف کوچک و تمام‌حروف بزرگ راحت باشید. در متن کتاب، کد به صورت
        حروف بزرگ خواهد بود؛ در فهرست‌ها، کد به صورت حروف کوچک خواهد بود.</li>
</ul>
<p>چرا این الزامات؟ SASM به طور خودکار برنامه‌های شما را به کتابخانه
    استاندارد C، libc لینک می‌کند. به نوعی، آنچه شما با SASM می‌نویسید، یک
    برنامه C است بدون نوشتن کد C. برخی از قوانین لازم برای یک برنامه C وجود
    دارند که حتی اگر برنامه به زبان C نوشته نشده باشد، باید رعایت شوند. یکی
    از این قوانین این است که بدنه یک برنامه C همیشه main نام دارد. دیگری این
    است که قبل از هر چیزی باید رجیستر اشاره‌گر پشته RSP در رجیستر RBP ذخیره
    شود. این اجازه می‌دهد که برنامه به داده‌های روی پشته دسترسی داشته باشد
    بدون اینکه مقدار اصلی اشاره‌گر پشته RSP را خراب کند.</p>
<p>یک ویژگی عجیب در SASM که من زیاد از آن خوشم نمی‌آید این است که چه شما
    دستور MOV RBP,RSP را به عنوان اولین دستور در برنامه قرار دهید و چه
    ندهید، SASM آن را هنگامی که وارد حالت اشکال‌زدایی می‌شوید، اضافه خواهد
    کرد. بنابراین اگر دستور MOV را در ابتدای برنامه قرار دهید، به محض ورود
    به حالت اشکال‌زدایی دو نمونه از MOV RBP,RSP خواهید داشت. این به هیچ عنوان
    مشکلی ایجاد نمی‌کند، اما کمی عجیب است. (توجه داشته باشید که این ممکن است
    یک باگ باشد و زمانی که شما این کتاب را مطالعه کنید، ممکن است در نسخه‌ای
    جدید این مشکل برطرف شده باشد.) این همچنین برخلاف چیزی به نام prolog
    استاندارد است که من در فصل‌های 11 و 12 در مورد آن توضیح خواهم داد.</p>
<p>SASM راه خوبی برای یادگیری تکنیک‌های ساده اسمبلی است. مخصوصاً در
    اشکال‌زدایی بصری خوب عمل می‌کند، چون شما کد منبع و کامنت‌های خود را هنگام
    گام به گام پیش رفتن در برنامه مشاهده می‌کنید. احتمالاً وقتی مهارت‌های شما
    افزایش یابد، به یک IDE قدرتمندتر ارتقا خواهید داد. در حالی که شما تازه
    وارد زبان اسمبلی شده‌اید، IDE SASM بیش از حد کافی خواهد بود.</p>
<p>این یک دموی سریع از قابلیت‌های SASM بود. حالا وقت آن است که درباره‌ی
    چند ابزار دیگر که در کار با زبان اسمبلی مفید هستند صحبت کنیم.</p>
<p>لینوکس و ترمینال‌ها</p>
<p>مردم یونیکس در آن زمان دوست نداشتند این را بپذیرند، اما زمانی که
    یونیکس ایجاد شد، واقعاً یک سیستم‌عامل mainframe مانند سیستم‌های IBM بود و
    از کاربران متعدد پشتیبانی می‌کرد از طریق زمان‌بندی مشترک. هر کاربر از طریق
    ترمینال‌های جداگانه، ارتباطی با کامپیوتر مرکزی برقرار می‌کرد، به ویژه
    ترمینال‌های سری VT شرکت Digital Equipment Corporation.</p>
<p>این ترمینال‌ها دسکتاپ‌های گرافیکی که از سال 1995 به بعد به طور ضروری
    مشاهده می‌کنیم، نشان نمی‌دادند. آنها دستگاه‌های متنی تنها بودند، معمولاً 25
    خط از 80 کاراکتر بدون آیکن یا پنجره. برخی از برنامه‌ها از صفحه‌ی کامل
    استفاده می‌کردند و منوهای شماره‌گذاری شده و فیلدهای پر کردن برای وارد کردن
    داده‌ها نمایش می‌دادند. بیشتر ابزارهای نرم‌افزاری یونیکس، به ویژه آنهایی که
    توسط برنامه‌نویسان استفاده می‌شدند، از خط فرمان کنترل می‌شدند و خروجی به
    صورت اسکرول از پایین به بالا ارسال می‌شد.</p>
<p>لینوکس همینطور کار می‌کند. ساده‌ترین شکل، لینوکس همان یونیکس است.
    لینوکس از ترمینال‌های “دور” خارجی مانند ترمینال‌های VT100 دهه 1970 استفاده
    نمی‌کند، اما ماشین‌آلات نرم‌افزاری مشابه ترمینال‌های DEC هنوز داخل لینوکس
    وجود دارند و همچنان کار می‌کنند، به شکل شبیه‌سازی ترمینال.</p>
<p>کنسول لینوکس</p>
<p>برنامه‌های مختلفی برای شبیه‌سازی ترمینال در لینوکس و دیگر پیاده‌سازی‌های
    یونیکس مانند BSD وجود دارند. اوبونتو و کوبونتو با یک برنامه به نام GNOME
    Terminal می‌آیند، و شما می‌توانید بسیاری از آنها را از مدیر بسته‌های توزیع
    خود دانلود و نصب کنید. برنامه‌ای که من برای بحث‌های این کتاب استفاده می‌کنم
    و معمولاً توصیه می‌کنم، Konsole است. اگر هنوز آن را نصب نکرده‌اید، حتماً آن
    را نصب کنید.</p>
<p>زمانی که یک برنامه شبیه‌ساز ترمینال را در لینوکس باز می‌کنید، یک خط
    فرمان متنی با یک نشانگر چشمک‌زن خواهید دید، شبیه به خط فرمان قدیمی DOS یا
    ابزار Command Prompt در ویندوز. برنامه‌ی ترمینال سعی می‌کند مانند یکی از
    آن ترمینال‌های سریال CRT قدیمی از اولین عصر یونیکس عمل کند. به طور
    پیش‌فرض، برنامه شبیه‌ساز ترمینال از صفحه‌کلید و نمایشگر کامپیوتر برای ورودی
    و خروجی استفاده می‌کند. و چیزی که به آن متصل می‌شود یک دستگاه خاص لینوکس
    به نام dev/console است، که یک دستگاه پیش‌فرض است که ارتباط با سیستم
    لینوکس خود را فراهم می‌کند.</p>
<p>مفید است که به یاد داشته باشیم یک برنامه ترمینال تنها یک برنامه است و
    می‌توانید چندین نوع مختلف از برنامه ترمینال را روی سیستم لینوکس خود نصب
    کنید و چندین نمونه از هرکدام را به طور همزمان اجرا کنید. با این حال،
    تنها یک کنسول لینوکس وجود دارد که منظور من از آن دستگاهی است به نام
    dev/console که دستورات را به سیستم لینوکس هدایت کرده و پاسخ‌های سیستم را
    برمی‌گرداند. به طور پیش‌فرض، برنامه شبیه‌ساز ترمینال زمانی که اجرا می‌شود به
    dev/console متصل می‌شود. اگر بخواهید، می‌توانید از یک شبیه‌ساز ترمینال
    لینوکس برای اتصال به چیزهای دیگر از طریق شبکه استفاده کنید، گرچه چگونگی
    این کار و نحوه انجام آن خارج از محدوده این کتاب است.</p>
<p>ساده‌ترین روش برای برقراری ارتباط با یک برنامه لینوکس از طریق یک
    شبیه‌ساز ترمینال مانند برنامه Konsole است که در این کتاب به آن اشاره
    می‌کنم. جایگزین شبیه‌ساز ترمینال این است که برنامه‌های خود را برای یک سیستم
    پنجره‌ای از هر نوع بنویسید. توصیف مدیران دسکتاپ لینوکس و سیستم پنجره‌ای X
    که زیر آن‌ها فعالیت می‌کنند به تنهایی یک کتاب (یا چند کتاب) می‌طلبد و شامل
    لایه‌های پیچیدگی است که ارتباط زیادی با زبان اسمبلی ندارند. بنابراین در
    این کتاب، برنامه‌های نمونه به طور خاص از خط فرمان شبیه‌ساز ترمینال اجرا
    می‌شوند.</p>
<p><strong>کدگذاری کاراکتر در Konsole</strong></p>
<p>در یک شبیه‌ساز ترمینال برنامه‌نویسی زیادی برای پیکربندی وجود ندارد،
    حداقل زمانی که در مراحل اولیه زبان اسمبلی هستید. یک چیز که برای
    برنامه‌های نمونه در این کتاب مهم است، کدگذاری کاراکترهاست. یک شبیه‌ساز
    ترمینال باید کاراکترها را در پنجره خود قرار دهد، و یکی از گزینه‌های
    پیکربندی در شبیه‌ساز ترمینال مربوط به این است که کدام گلیف‌ها با کد
    کاراکتر 8 بیتی مرتبط هستند. توجه داشته باشید که این مستقیماً مربوط به
    فونت‌ها نیست. یک گلیف یک نماد خاص قابل شناسایی است، مانند حرف A یا علامت
    @. نحوه رندر کردن آن نماد به گرافیک بستگی دارد که به چه فونتی استفاده
    می‌شود. در فونت‌های مختلف، یک گلیف خاص ممکن است ضخیم‌تر یا نازک‌تر باشد یا
    پاها یا تزئینات مختلفی داشته باشد. شما می‌توانید یک A را در تعداد زیادی
    فونت نمایش دهید، اما فرض کنید که فونت زیاد تزئینی نباشد (چنین فونت‌هایی
    وجود دارند)، شما هنوز می‌توانید تشخیص دهید که یک گلیف خاص همان A است.</p>
<p>کدگذاری کاراکتر یک مقدار عددی را به یک گلیف خاص نگاشت می‌کند. در
    استاندارد ASCII غربی که با آن آشنا هستیم، عدد اعشاری 65 با گلیفی که آن
    را به عنوان حرف A بزرگ می‌شناسیم مرتبط است. در یک کدگذاری کاراکتر دیگر که
    برای نمایش الفبای غیر رومی (مانند عبری، عربی یا تایلندی) ایجاد شده است،
    ممکن است عدد 65 با یک گلیف کاملاً متفاوت مرتبط باشد.</p>
<p>این کتاب برای مخاطبان غربی و عمدتاً انگلیسی‌زبان نوشته شده است،
    بنابراین گلیف‌های پیش‌فرض شبیه‌ساز ترمینال برای الفبا به خوبی کار می‌کنند.
    با این حال، مجموعه کاراکتر ASCII در واقع تنها از کاراکتر 0 تا کاراکتر
    127 می‌رود. هشت بیت می‌تواند مقادیر تا 256 را بیان کند، بنابراین 128
    کاراکتر “بالا” دیگر فراتر از بالاترین انتهای استاندارد ASCII وجود دارند.
    هیچ استاندارد قدرتمندتری مانند ASCII برای گلیف‌های این 128 کاراکتر وجود
    ندارد. طرح‌های مختلف کدگذاری کاراکتر شامل گلیف‌های مختلف زیادی هستند که
    بیشتر آن‌ها حروف الفبای رومی با اصلاحات (یعنی معکوس، سیرکُم‌فلکس، تیلده،
    لهجه‌ها و غیره)، حروف یونانی بزرگ و نمادهایی از ریاضیات و منطق هستند.</p>
<p>وقتی IBM کامپیوتر شخصی اولیه خود را در سال 1981 عرضه کرد، گلیف‌هایی را
    که چند سال قبل برای ترمینال‌های mainframe خود ساخته بود برای نمایش جعبه‌ها
    روی صفحه‌های ترمینالی که فقط متن نمایش می‌دادند و نمی‌توانستند گرافیک
    پیکسلی نمایش دهند، اضافه کرد. این گلیف‌ها برای تفکیک فرم‌های پرکردنی و
    دیگر موارد مفید شدند. مجموعه کاراکترهای ROM کامپیوتر شخصی در نهایت به
    نام Code Page 437 شناخته شد که شامل بسیاری از نمادهای دیگر مانند چهار
    شکل کارت بازی است.</p>
<p>یک طرح مشابه کدگذاری کاراکتر بعداً در پیاده‌سازی یونیکس IBM، AIX،
    استفاده شد و به نام IBM-850 شناخته شد. IBM-850 شامل یک زیرمجموعه از
    گلیف‌های خط جعبه در CP437 است و همچنین بسیاری از حروف الفبای رومی با
    اصلاحات را شامل می‌شود تا امکان نمایش صحیح متن در زبان‌های غیر از انگلیسی
    فراهم شود.</p>
<p>شبیه‌سازهای ترمینال لینوکس به طور پیش‌فرض هیچ‌کدام از طرح کدگذاری CP437
    یا IBM-850 (و بنابراین گلیف‌های مرز جعبه آن‌ها) را کدگذاری نمی‌کنند. طرح
    کدگذاری IBM-850 موجود است، اما باید آن را از منوها انتخاب کنید. به هر
    حال، تا به حال هیچ شبیه‌ساز ترمینال لینوکسی ندیده‌ام که قادر به نمایش
    مجموعه کاراکترهای اصلی CP437 باشد. ممکن است چنین چیزی وجود داشته باشد،
    اما CP437 منسوخ شده است و مجبور کردن آن برای اجرای برنامه‌ای که نوشته‌اید
    باعث آزار کاربران خواهد شد.</p>
<p>Konsole را راه‌اندازی کرده و از منوی Settings ➪ Manage Profiles
    استفاده کنید. Konsole با یک پروفایل پیش‌فرض به نام Default عرضه می‌شود. در
    گفتگوی Manage Profiles که ظاهر می‌شود، پروفایل جدیدی بسازید و نامی مانند
    Shell Box برای آن انتخاب کنید. آن را ذخیره کنید. در گفتگوی Edit Profile،
    به تب Advanced بروید و به دنبال کشویی Default Character Encoding بگردید.
    بر روی Select کلیک کنید و از فهرستی که ارائه می‌شود، روی Western European
    حرکت کنید تا فهرست کدگذاری‌ها ظاهر شود. IBM850 را انتخاب کرده و OK را
    بزنید (تصویر 6.3).</p>
<p>برای استفاده از کدگذاری کاراکتر IBM-850، باید پروفایل جدید Shell Box
    را به عنوان پروفایل پیش‌فرض Konsole تنظیم کنید. این کار با انتخاب
    Settings ➪ Manage Profiles و تیک زدن جعبه کنار نام پروفایل انجام می‌شود.
    زمانی که پروفایل Shell Box فعال باشد، گلیف‌های مرز جعبه IBM در دسترس
    برنامه‌های شما قرار خواهند گرفت. ما از آن‌ها در چند فصل بعدی استفاده
    خواهیم کرد.</p>
<p><strong>سه فایل استاندارد یونیکس</strong></p>
<p>کامپیوترها به عنوان ماشین‌هایی که داده‌ها را جابجا می‌کنند توصیف شده‌اند،
    و این یک روش خوب برای دیدن آن‌ها است. با این حال، بهترین روش برای درک
    ورودی و خروجی برنامه از طریق شبیه‌سازهای ترمینال، درک یکی از اصول طراحی
    بنیادی یونیکس است: همه چیز یک فایل است. یک فایل می‌تواند مجموعه‌ای از
    داده‌ها روی دیسک باشد، همانطور که در فصل 5 توضیح دادم. اما به طور کلی، یک
    فایل یک نقطه انتهایی در مسیری است که داده‌ها از آن عبور می‌کنند. زمانی که
    شما به یک فایل می‌نویسید، در حال ارسال داده‌ها از طریق یک مسیر به یک نقطه
    انتهایی هستید. زمانی که از یک فایل می‌خوانید، داده‌ها را از یک نقطه
    انتهایی دریافت می‌کنید. مسیری که داده‌ها بین فایل‌ها طی می‌کنند ممکن است
    کاملاً درون یک کامپیوتر باشد، یا ممکن است بین کامپیوترها از طریق یک شبکه
    باشد. داده‌ها ممکن است در طول مسیر پردازش و تغییر یابند یا ممکن است به
    سادگی از یک نقطه انتهایی به نقطه انتهایی دیگر منتقل شوند بدون تغییر.
    هیچ‌کدام مهم نیستند. همه چیز یک فایل است و همه فایل‌ها به طور یکسان توسط
    ماشین‌آلات داخلی یونیکس پردازش می‌شوند.</p>
<p>اصل “همه چیز یک فایل است” شامل مجموعه‌های داده بر روی دیسک نمی‌شود.
    صفحه‌کلید شما یک فایل است: این یک نقطه انتهایی است که داده‌ها را تولید
    می‌کند و آن‌ها را به جایی می‌فرستد. نمایشگر شما یک فایل است: این یک نقطه
    انتهایی است که داده‌ها را از جایی دریافت کرده و آن‌ها را جایی که می‌توانید
    ببینید قرار می‌دهد. فایل‌های یونیکس لزوماً نباید فایل‌های متنی باشند.
    فایل‌های باینری (مانند اجرایی‌هایی که توسط SASM ساخته می‌شوند) به همان شیوه
    پردازش می‌شوند.</p>
<p>سه فایل استاندارد توسط یونیکس تعریف شده‌اند و همواره در دسترس
    برنامه‌های شما در حین اجرای برنامه‌ها هستند. این سه فایل در جدول 6.1 آورده
    شده است.</p>
<table>
    <colgroup>
        <col style="width: 26%" />
        <col style="width: 24%" />
        <col style="width: 26%" />
        <col style="width: 23%" />
    </colgroup>
    <thead>
    <tr class="header">
        <th>فایل</th>
        <th>شناسه C</th>
        <th>شناسه فایل</th>
        <th>پیش‌فرض به</th>
    </tr>
    </thead>
    <tbody>
    <tr class="odd">
        <td>ورودی استاندارد</td>
        <td>stdin</td>
        <td>0</td>
        <td>صفحه‌کلید</td>
    </tr>
    <tr class="even">
        <td>خروجی استاندارد</td>
        <td>stdout</td>
        <td>1</td>
        <td>نمایشگر</td>
    </tr>
    <tr class="odd">
        <td>خطای استاندارد</td>
        <td>stderr</td>
        <td>2</td>
        <td>نمایشگر</td>
    </tr>
    </tbody>
</table>
<p><strong>جدول 6.1: سه فایل استاندارد یونیکس</strong></p>
<p>در نهایت، یک فایل برای سیستم‌عامل از طریق شناسه فایلش شناخته می‌شود که
    فقط یک عدد است. سه عدد اول مربوط به سه فایل استاندارد هستند. زمانی که
    شما یک فایل موجود را باز می‌کنید یا فایلی جدید از درون یک برنامه ایجاد
    می‌کنید، لینوکس یک مقدار شناسه فایل خاص برای فایلی که باز کرده‌اید یا
    ایجاد کرده‌اید برمی‌گرداند. برای دستکاری فایل، شما باید به سیستم‌عامل
    درخواست بدهید و شناسه فایل فایلی را که می‌خواهید با آن کار کنید ارسال
    کنید. جدول 6.1 همچنین شناسه‌های مرسومی را که در دنیای C برای این فایل‌های
    استاندارد شناخته می‌شود، فراهم کرده است. به عنوان مثال، وقتی مردم از
    “stdout” صحبت می‌کنند، آن‌ها در واقع در مورد شناسه فایل 1 صحبت می‌کنند.</p>
<p>اگر به فهرست 5-1 نگاه کنید، خواهید دید که در برنامه نمونه‌ای که در فصل
    5 در حین راهنمایی فرایند توسعه زبان اسمبلی نشان دادم، این خط وجود
    دارد:</p>
<pre><code>mov rdi,1 ; 1 = fd برای stdout؛ نوشتن به پنجره ترمینال</code></pre>
<p>وقتی ما شعار کوتاه “Eat at Joe’s!” را به نمایشگر فرستادیم، در واقع آن
    را به شناسه فایل 1، خروجی استاندارد، نوشتیم. با تغییر مقدار به 2،
    می‌توانستیم آن را به خروجی استاندارد ارسال کنیم. این به هیچ‌وجه به طور
    متفاوتی در صفحه نمایش داده نمی‌شود. خروجی استاندارد و خطای استاندارد از
    نظر نحوه پردازش داده‌ها کاملاً مشابه یکدیگر هستند. به طور سفارشی،
    برنامه‌هایی مانند NASM پیام‌های خطای خود را به خطای استاندارد ارسال
    می‌کنند، اما متنی که به خطای استاندارد ارسال می‌شود به عنوان “پیام خطا”
    علامت‌گذاری نمی‌شود یا به رنگ یا مجموعه کاراکتری متفاوت نمایش داده نمی‌شود.
    خروجی استاندارد و خطای استاندارد وجود دارند تا بتوانیم خروجی برنامه را
    از خطاها و پیام‌های دیگر برنامه که مربوط به چگونگی و آنچه که برنامه انجام
    می‌دهد، جدا نگه داریم.</p>
<p>این موضوع بعد از درک یکی از مفیدترین مکانیسم‌های پایه‌ای همه
    سیستم‌عامل‌های مشتق شده از یونیکس، یعنی <em>بازنشانی ورودی/خروجی</em> (I/O
    Redirection)، کاملاً قابل فهم خواهد شد.</p>
<h3 id="بازنشانی-ورودیخروجی">بازنشانی ورودی/خروجی</h3>
<p>به‌طور پیش‌فرض، خروجی استاندارد به صفحه‌نمایش می‌رود. (این معمولاً پنجره‌ای
    از شبیه‌ساز ترمینال است.) اما این فقط پیش‌فرض است. شما می‌توانید نقطه هدف
    برای جریان داده‌ای که از خروجی استاندارد می‌آید را تغییر دهید. داده‌های
    خروجی استاندارد می‌توانند به جای صفحه‌نمایش، به یک فایل روی دیسک ارسال
    شوند. فایل یک فایل است؛ داده‌ها بین فایل‌ها به‌طور یکسان توسط لینوکس پردازش
    می‌شوند، بنابراین تغییر نقطه هدف هیچ کار پیچیده‌ای نیست. داده‌های خروجی
    استاندارد می‌توانند به یک فایل موجود ارسال شوند، یا می‌توانند به فایلی
    جدید که هنگام اجرای برنامه شما ایجاد می‌شود، ارسال شوند.</p>
<p>ورودی به برنامه‌های شما به‌طور پیش‌فرض از صفحه‌کلید می‌آید، اما تمام چیزی
    که صفحه‌کلید ارسال می‌کند، متن است. این متن می‌تواند از یک فایل متنی دیگر
    هم بیاید. تغییر منبع داده‌ای که به برنامه‌های شما ارسال می‌شود، هیچ دشواری
    بیشتری از تغییر مقصد خروجی آن ندارد. این مکانیزم <em>بازنشانی
        ورودی/خروجی</em> نامیده می‌شود و ما از آن برای بسیاری از برنامه‌های نمونه
    در ادامه این کتاب استفاده خواهیم کرد.</p>
<p>شاید شما قبلاً از بازنشانی ورودی/خروجی در کار با لینوکس استفاده کرده
    باشید، حتی اگر اسم آن را نمی‌دانستید. تمام دستورات پایه‌ای شل لینوکس خروجی
    خود را به خروجی استاندارد ارسال می‌کنند. دستور <code>ls</code>، به‌عنوان
    مثال، فهرستی از محتوای دایرکتوری کاری را به خروجی استاندارد می‌فرستد. شما
    می‌توانید آن فهرست را با هدایت متن تولیدشده توسط <code>ls</code> به یک
    فایل دیسک لینوکس، با وارد کردن این دستور در خط فرمان، ضبط کنید:</p>
<div class="sourceCode" id="cb3"><pre
        class="sourceCode bash"><code class="sourceCode bash"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="fu">ls</span> <span class="op">&gt;</span> dircontents.txt</span></code></pre></div>
<p>فایل <code>dircontents.txt</code> اگر قبلاً وجود نداشته باشد، ایجاد
    می‌شود و متنی که <code>ls</code> تولید کرده است در آن ذخیره می‌شود. سپس
    می‌توانید فایل را چاپ کنید یا آن را در ویرایشگر متن بارگذاری کنید.</p>
<p>علامت <code>&gt;</code> یکی از دو عملگر بازنشانی است. علامت
    <code>&lt;</code> در جهت معکوس عمل می‌کند و ورودی استاندارد را از
    صفحه‌کلید به یک فایل دیگر هدایت می‌کند، که معمولاً یک فایل متنی ذخیره‌شده
    روی دیسک است. این برای ارسال دستورات صفحه‌کلید به برنامه کاربرد کمتری
    دارد و بیشتر برای ارائه مواد خامی است که برنامه قرار است روی آن کار
    کند.</p>
<p>فرض کنید شما می‌خواهید برنامه‌ای بنویسید که تمام متن‌های کوچک یک فایل را
    به حروف بزرگ تبدیل کند. (این یک کار بسیار معکوس‌کننده است، زیرا حروف بزرگ
    برای برخی از کاربران یونیکس بسیار آزاردهنده هستند.) شما می‌توانید برنامه
    را طوری بنویسید که متن را از ورودی استاندارد بگیرد و متن را به خروجی
    استاندارد بفرستد. این کار از منظر برنامه‌نویسی آسان است و در واقع، ما این
    کار را در قسمت‌های بعدی کتاب انجام خواهیم داد.</p>
<p>برای آزمایش برنامه‌تان می‌توانید این خط از متن را در صفحه‌کلید تایپ
    کنید:</p>
<div class="sourceCode" id="cb4"><pre
        class="sourceCode bash"><code class="sourceCode bash"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="ex">i</span> want live things in their pride to remain.</span></code></pre></div>
<p>برنامه شما این خط از متن را پردازش کرده و متن پردازش‌شده را به خروجی
    استاندارد ارسال می‌کند، جایی که در شبیه‌ساز ترمینال نمایش داده خواهد
    شد:</p>
<div class="sourceCode" id="cb5"><pre
        class="sourceCode bash"><code class="sourceCode bash"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="ex">I</span> WANT LIVE THINGS IN THEIR PRIDE TO REMAIN.</span></code></pre></div>
<p>خب، آزمایش موفقیت‌آمیز بود: به نظر می‌رسد که همه چیز در داخل برنامه
    به‌خوبی کار می‌کند. بنابراین، گام بعدی این است که برنامه uppercaser را روی
    برخی از فایل‌های واقعی آزمایش کنید. شما نیازی به تغییر برنامه uppercaser
    ندارید. فقط این دستور را در خط فرمان وارد کنید:</p>
<div class="sourceCode" id="cb6"><pre
        class="sourceCode bash"><code class="sourceCode bash"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="ex">uppercaser</span> <span class="op">&lt;</span> santafetrail.txt <span class="op">&gt;</span> vachelshouting.txt</span></code></pre></div>
<p>با جادوی بازنشانی ورودی/خروجی، برنامه شما تمام متن را از یک فایل دیسک
    به نام <code>santafetrail.txt</code> خوانده، تمام حروف کوچک را به حروف
    بزرگ تبدیل کرده و سپس متن بزرگ‌شده را به فایل دیسک
    <code>vachelshouting.txt</code> می‌نویسد.</p>
<p>عملگرهای بازنشانی را می‌توان به‌عنوان فلش‌هایی در نظر گرفت که جهت حرکت
    داده‌ها را نشان می‌دهند. داده‌ها از فایل <code>santafetrail.txt</code>
    گرفته شده و به برنامه <code>uppercaser</code> ارسال می‌شوند؛ بنابراین،
    علامت <code>&lt;</code> از فایل ورودی به برنامه اشاره می‌کند. برنامه
    <code>uppercaser</code> داده‌ها را به فایل خروجی
    <code>vachelshouting.txt</code> ارسال می‌کند و بنابراین عملگر بازنشانی از
    نام برنامه به سمت نام فایل خروجی اشاره می‌کند.</p>
<p>از دیدگاهی بلند، آنچه اتفاق می‌افتد شبیه به آنچه در شکل 6.4 رسم
    کرده‌ام، به نظر می‌رسد. بازنشانی ورودی/خروجی به‌عنوان یک نوع سوئیچ داده عمل
    می‌کند که جریان‌های داده را از فایل‌های استاندارد به فایل‌های منبع و مقصد با
    نام‌هایی که خودتان انتخاب می‌کنید، هدایت می‌کند.</p>
<p>[تصویر از بازنشانی ورودی/خروجی.]</p>
<h3 id="فیلترهای-متنی-ساده">فیلترهای متنی ساده</h3>
<p>ما در واقع یک برنامه کوچک به نام <code>uppercaser</code> خواهیم ساخت
    که دقیقاً همین کار را انجام می‌دهد: خواندن متن از یک فایل متنی، پردازش متن
    و نوشتن متن پردازش‌شده به یک فایل خروجی. داخل برنامه، ما از ورودی
    استاندارد می‌خوانیم و به خروجی استاندارد می‌نویسیم. این باعث می‌شود که
    نیازی به درخواست نام فایل‌های ورودی و خروجی از کاربر نباشد، ایجاد فایل
    خروجی و غیره. لینوکس تمام این کارها را برای ما انجام می‌دهد، که کار
    برنامه‌نویسی را بسیار ساده‌تر می‌کند.</p>
<p>برنامه‌هایی که این‌گونه عمل می‌کنند نمایانگر یک مکانیزم استاندارد در
    دنیای یونیکس بزرگتر هستند، که به آن فیلتر می‌گویند. شما قبلاً با چندتا از
    آن‌ها آشنا شده‌اید. اسمبلر NASM خودش یک فیلتر است: فایل‌های متنی پر از کد
    منبع زبان اسمبلی را می‌گیرد، آن‌ها را پردازش می‌کند و یک فایل باینری پر از
    کد شی و اطلاعات نمادها می‌نویسد. لینک‌کننده لینوکس فایل‌های حاوی کد شی و
    اطلاعات نمادها را می‌خواند و یک فایل برنامه اجرایی می‌نویسد. NASM و
    لینک‌کننده روی چیزی بیش از متن ساده کار می‌کنند، اما مشکلی نیست. یک فایل،
    یک فایل، یک فایل است و دستگاه‌هایی که لینوکس برای کار با فایل‌ها استفاده
    می‌کند بین فایل‌های متنی و باینری تفاوتی قائل نمی‌شود.</p>
<p>برنامه‌های فیلتر همیشه از بازنشانی ورودی/خروجی برای تعیین ورودی‌ها و
    خروجی‌هایشان استفاده نمی‌کنند. NASM و بیشتر لینک‌کننده‌ها نام‌های فایل‌های
    منبع و مقصد خود را از خط فرمان دریافت می‌کنند، که یک ترفند مفید است که
    بعداً در این کتاب به آن خواهیم پرداخت. با این حال، بازنشانی ورودی/خروجی
    برنامه‌نویسی برنامه‌های فیلتر متنی ساده را بسیار ساده‌تر می‌کند.</p>
<p>وقتی شما درک کنید که برنامه‌های فیلتر چگونه کار می‌کنند، شروع به درک
    این موضوع می‌کنید که چرا فایل خطای استاندارد وجود دارد و چه کار می‌کند. یک
    برنامه فیلتر داده ورودی را به داده خروجی پردازش می‌کند. در این مسیر، ممکن
    است نیاز داشته باشد پیامی خطا ارسال کند یا فقط تأیید کند که هنوز در حال
    کار است و وارد یک حلقه بی‌پایان نشده است. برای این کار، به یک کانال
    ارتباطی نیاز داریم که مستقل از ورودی‌ها و خروجی‌های برنامه باشد. خطای
    استاندارد چنین کانال ارتباطی را فراهم می‌کند. برنامه شما می‌تواند پیام‌های
    وضعیت و خطا را به شبیه‌ساز ترمینال ارسال کند، با نوشتن آن‌ها به فایل خطای
    استاندارد، تمام مدت زمانی که در حال کار است و فایل خروجی استاندارد مشغول
    نوشتن خروجی برنامه به دیسک است.</p>
<p>خطای استاندارد دقیقاً مشابه خروجی استاندارد می‌تواند بازنشانی شود و اگر
    شما بخواهید وضعیت برنامه و/یا پیام‌های خطای آن را به فایلی به نام
    <code>joblog.txt</code> ذخیره کنید، می‌توانید برنامه را از خط فرمان
    ترمینال به این صورت اجرا کنید:</p>
<div class="sourceCode" id="cb7"><pre
        class="sourceCode bash"><code class="sourceCode bash"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="ex">uppercaser</span> <span class="op">&lt;</span> santafetrail.txt <span class="op">&gt;</span> vachelshouting.txt <span class="dv">2</span><span class="op">&gt;</span> joblog.txt</span></code></pre></div>
<p>در اینجا، عملگر <code>2&gt;</code> مشخص می‌کند که فایل توصیف‌گر ۲ (که
    اگر یادتان باشد، همان خطای استاندارد است) به <code>joblog.txt</code>
    بازنشانی می‌شود.</p>
<p>اگر خروجی (از هر منبعی که باشد) را به یک فایل دیسک موجود هدایت کنید،
    هدایت خروجی هر آنچه که قبلاً در فایل وجود دارد را با داده‌های جدید جایگزین
    می‌کند و داده‌های قبلی از بین می‌روند. اگر می‌خواهید داده‌های هدایت شده را به
    انتهای یک فایل موجود که قبلاً حاوی داده است اضافه کنید، باید از عملگر
    الحاق &gt;&gt; استفاده کنید.</p>
<p>استفاده از ورودی استاندارد و خروجی استاندارد از درون SASM</p>
<p>بیشتر برنامه‌های نمایشی ساده در این کتاب از ورودی استاندارد لینوکس
    (stdin) و خروجی استاندارد (stdout) استفاده می‌کنند. SASM یک پنجره اختصاصی
    برای هر دوی این‌ها دارد. زمانی که برنامه شما کاراکترها را به stdout ارسال
    می‌کند (همانطور که برنامه eatsyscall و بیشتر برنامه‌های دیگر این کار را
    انجام می‌دهند)، کاراکترها در پنجره خروجی نمایش داده خواهند شد.</p>
<p>چگونگی استفاده از پنجره ورودی کمتر واضح است. معمولاً، stdin کاراکترها
    را از یک فایل متنی روی دیسک می‌خواند. زمانی که برنامه‌ای که از stdin
    استفاده می‌کند را از طریق خط فرمان ترمینال اجرا می‌کنید، معمولاً از stdin
    به این شکل استفاده می‌کنید:</p>
<pre><code>hexdump2 &lt; texttestfile.txt</code></pre>
<p>در اینجا، برنامه hexdump2 (که بعداً در این کتاب به آن نگاه خواهیم کرد)
    داده‌ها را از فایلی به نام texttestfile.txt می‌گیرد و یک گزارش هگزادسیمال
    فرمت شده از فایل به stdout ارسال می‌کند.</p>
<p>این استفاده از خط فرمان ترمینال است. پس چطور باید از stdin در داخل
    SASM استفاده کرد؟</p>
<p>این ساده است: متنی که می‌خواهید برنامه شما آن را پردازش کند از یک فایل
    یا منبع متنی دیگر کپی کرده و در پنجره ورودی SASM پیست کنید. دستور پیست
    در منوی کلیک راست زمانی که موس در پنجره ورودی است قرار دارد. متن در
    پنجره ورودی ظاهر می‌شود. زمانی که برنامه شما نیاز به متن از stdin داشته
    باشد، از تماس سیستم 0 برای خواندن متن به صورت کاراکتر به کاراکتر استفاده
    خواهد کرد تا زمانی که همه متن خوانده شود. همچنین می‌توانید به سادگی متن
    را از صفحه‌کلید وارد پنجره ورودی کنید قبل از اینکه برنامه شروع به اجرا
    کند. متن تایپ شده به همان شکلی که متن پیست شده به پنجره برخورد می‌کند،
    پردازش خواهد شد.</p>
<p>برای پاک کردن پنجره ورودی، موس را در پنجره قرار دهید، کلیک راست کنید
    و Select All (میانبر Ctrl+A) را انتخاب کنید، سپس کلید Delete را فشار
    دهید.</p>
<p>توجه داشته باشید که خواندن متن از پنجره ورودی باعث حذف آن متن از
    پنجره نمی‌شود. تمام متن تا زمانی که آن را به صورت دستی پاک نکنید در آن
    باقی می‌ماند.</p>
<p>کنترل ترمینال با دنباله‌های Escape</p>
<p>به طور پیش‌فرض، خروجی به یک پنجره ترمینال امولاتور در انتهای سمت چپ خط
    پایین وارد می‌شود و خطوط قبلی به همراه اضافه شدن هر خط جدید در پایین به
    سمت بالا اسکرول می‌کنند. این کاملاً مفید است، اما زیبایی ندارد و قطعاً
    نمی‌توان آن را به عنوان یک «رابط کاربری» در هیچ معنای حقیقی آن در نظر
    گرفت. در زمان‌های قدیم، برنامه‌های «تمام صفحه» زیادی برای سیستم‌عامل یونیکس
    نوشته شده بود که تمامی فیلدها و درخواست‌های ورودی خود را روی صفحه نمایش
    می‌دادند. زمانی که ترمینال‌های رنگی در دسترس قرار گرفتند، متن می‌توانست در
    رنگ‌های مختلف نمایش داده شود، روی فیلدهایی با پس‌زمینه‌های سفید یا رنگ‌های
    دیگر که با متن تضاد داشتند.</p>
<p>چطور این کار انجام می‌شد؟ ترمینال‌های قدیمی DEC VT مانند VT100
    می‌توانستند از طریق دنباله‌های خاصی از کاراکترها که در جریان داده‌های
    ارسالی به ترمینال از طریق خروجی استاندارد یا خطای استاندارد جاسازی شده
    بودند، کنترل شوند. این دنباله‌های کاراکتری به نام دنباله‌های Escape شناخته
    می‌شدند، زیرا آنها یک «فرار» (هرچند موقت) از جریان معمول داده‌ها بودند که
    برای نمایش ارسال می‌شدند.</p>
<p>ترمینال‌های VT جریان داده‌هایی که نمایش می‌دادند را نظارت می‌کردند و
    کاراکترهای داخل دنباله‌های Escape را برای تفسیر جداگانه شناسایی می‌کردند.
    یک دنباله Escape به عنوان دستور پاک کردن نمایش تفسیر می‌شد. دنباله Escape
    دیگر به عنوان دستور نمایش کاراکترهای بعدی روی صفحه شروع از پنج خط بالاتر
    و سی کاراکتر از حاشیه چپ تفسیر می‌شد. دنباله‌های Escape شناخته شده زیادی
    وجود داشتند و به ترمینال‌های متنی ابتدایی آن زمان اجازه می‌دادند که متن را
    به صورت مرتب شده به کاربر نمایش دهند.</p>
<p>یک امولاتور ترمینال لینوکس مانند Konsole برنامه‌ای است که طوری نوشته
    شده است که «شبیه» یکی از آن ترمینال‌های قدیمی DEC باشد، حداقل از نظر نحوه
    نمایش داده‌ها روی مانیتورهای LCD کامپیوترهای قرن 21. اگر رشته کاراکتری
    «Eat at Joe’s!» را به Konsole ارسال کنید، Konsole آن را مطیعانه در پنجره
    خود نمایش می‌دهد، دقیقاً مثل همانطور که VT100 قدیمی‌ها این کار را می‌کردند.
    ما قبلاً این را در لیست 5-1 دیده‌ایم. Konsole، با این حال، جریان
    کاراکترهایی که به آن ارسال می‌کنیم را نظارت می‌کند و آن دنباله‌های Escape
    را نیز می‌شناسد. کلید هوشیاری Konsole در یک کاراکتر خاص است که معمولاً
    نامرئی است: Esc، معادل عددی آن که 27 در مبنای ده‌دهی یا 01Bh است. وقتی
    Konsole کاراکتر Esc را در جریان متنی که در حال نمایش است مشاهده می‌کند،
    خیلی دقیقاً به کاراکترهای بعدی نگاه می‌کند. اگر سه کاراکتر اول بعد از
    کاراکتر Esc عبارت “[2J” باشند، Konsole آن را به عنوان دنباله Escape
    شناسایی می‌کند که دستور می‌دهد نمایش را پاک کند. اگر، با این حال، چهار
    کاراکتر بعد از Esc عبارت “[11H” باشند، Konsole آن را به عنوان دنباله
    Escape شناسایی می‌کند که دستور می‌دهد مکان‌نما را به موقعیت خانه در گوشه
    بالای سمت چپ صفحه منتقل کند.</p>
<p>واقعا ده‌ها دنباله Escape مختلف وجود دارد که هرکدام نمایانگر دستوراتی
    برای جابه‌جایی مکان‌نما، تغییر رنگ‌های پیش‌زمینه و پس‌زمینه کاراکترها، تغییر
    فونت‌ها یا کدگذاری‌های کاراکتری، پاک کردن خطوط، بخشی از خطوط یا تمام صفحه
    نمایش و غیره هستند. برنامه‌هایی که در یک پنجره ترمینال اجرا می‌شوند
    می‌توانند با ارسال دقت شده دنباله‌های Escape به خروجی استاندارد، کنترل
    کامل نمایش را به دست بگیرند. (ما مقداری از این کار را کمی بعد انجام
    خواهیم داد، پس در نظر داشته باشید که هشدارهایی وجود دارد و کل این فرآیند
    به سادگی که به نظر می‌رسد نیست.) پیش از دوران برنامه‌های رابط کاربری
    گرافیکی (GUI)، ارسال دنباله‌های Escape به ترمینال‌ها (یا امولاتورهای
    ترمینال) دقیقاً همانطور که در یونیکس برنامه‌نویسی نمایش انجام می‌شد،
    بود.</p>
<p>توجه داشته باشید که پنجره خروجی SASM دنباله‌های Escape کاراکتری را درک
    نمی‌کند! اگر برنامه شما متنی را با استفاده از دنباله‌های Escape فرمت شده
    منتشر کند، فایل EXE را ذخیره کنید، از SASM خارج شوید و آن را تحت Konsole
    آزمایش کنید که دنباله‌های Escape ساده را می‌شناسد.</p>
<p>پس چرا برنامه‌های GUI نه؟</p>
<p>این ما را به یک سوال جالب می‌رساند. این کتاب بیش از 35 سال است که
    منتشر شده است (از بهار 1990) و من نامه‌های زیادی در مورد آن دریافت می‌کنم.
    سوال شماره یک این است: چگونه می‌توانم برنامه‌های GUI بنویسم؟ بیشتر مخاطبان
    من منظورشان برنامه‌های ویندوز هستند، اما گاهی اوقات کسانی هم هستند که در
    مورد نوشتن برنامه‌های اسمبلی برای GNOME یا KDE سوال می‌کنند. من سال‌ها پیش
    درس خود را گرفتم و هرگز جواب نمی‌دهم که «چرا بخواهید این کار را انجام
    دهید؟»، بلکه با حقیقت صادقانه جواب می‌دهم: این یک پروژه است که نیازمند
    تحقیق و تلاش فراوان است، برای بازدهی نسبتاً کم.</p>
<p>از طرف دیگر، اگر یاد بگیرید که برنامه‌های GUI برای ویندوز یا لینوکس
    بنویسید، خواهید فهمید که مکانیسم‌های رابط کاربری این سیستم‌عامل‌ها چگونه
    کار می‌کنند. و این قطعاً می‌تواند مفید باشد، اگر زمان و انرژی لازم را برای
    آن اختصاص دهید.</p>
<p>مشکل این است که یک مانع ورود عظیم وجود دارد. پیش از اینکه بتوانید
    اولین برنامه GUI خود را در اسمبلی بنویسید، باید بدانید که همه چیز چگونه
    کار می‌کند، برای مقادیر بسیار زیادی از «همه». برنامه‌های GUI نیاز دارند که
    «سیگنال‌ها» (در ویندوز، «رویدادها») را که توسط سیستم‌عامل ارسال می‌شود
    مدیریت کنند، نشان‌دهنده این که کلیدهایی فشرده شده یا دکمه‌های موس کلیک
    شده‌اند و غیره. برنامه‌های GUI باید مجموعه‌ای پیچیده از «ویجت‌ها» شامل
    دکمه‌ها، منوها، فیلدهای پر کردنی و تعداد بی‌شماری از تماس‌های رابط
    برنامه‌نویسی کاربردی (API) را مدیریت کنند. مدیریت حافظه و کشیدن مجدد
    پنجره‌ها زمانی که قسمتی از منطقه نمایش یک برنامه «کثیف» می‌شود (یعنی توسط
    چیزی دیگر پوشانده می‌شود یا توسط برنامه به روز می‌شود) یا زمانی که کاربر
    پنجره برنامه را تغییر اندازه می‌دهد یا پنجره‌ها را جابجا می‌کند نیز ضروری
    است.</p>
<p>داخلی برنامه‌نویسی GUI ویندوز یکی از زشت‌ترین چیزهایی است که من تا به
    حال دیده‌ام. (لینوکس هم به همین اندازه پیچیده است، اگرچه به این اندازه
    زشت نیست.) خوشبختانه، این یک نوع زشتی استاندارد است و به راحتی در
    کتابخانه‌های کد که زیاد از یک برنامه به برنامه دیگر تغییر نمی‌کنند، قرار
    می‌گیرد. این دلیل محبوبیت IDEهای گرافیکی و محصولات زبان‌های برنامه‌نویسی
    سطح بالا است: آنها بیشتر زشتی ارتباط با ماشین‌آلات GUI سیستم‌عامل را پشت
    کتابخانه‌های استاندارد کلاسی که در چارچوب برنامه‌نویسی کاربردی کار می‌کنند،
    پنهان می‌کنند. شما می‌توانید برنامه‌های بسیار خوبی در Delphi یا Visual
    Basic (برای ویندوز) یا Lazarus یا Gambas برای لینوکس بنویسید، با درک کمی
    از آنچه که در عمق سیستم اتفاق می‌افتد. اگر بخواهید در اسمبلی کار کنید،
    اساساً باید همه چیز را بدانید قبل از اینکه حتی شروع کنید.</p>
<p>این بدان معناست که شما باید از جای دیگری شروع کنید. اگر واقعاً
    می‌خواهید برنامه‌های GUI را با استفاده از assembly language برای یکی از
    مدیران دسکتاپ لینوکس بنویسید، به این شکل عمل کنید:</p>
<ol type="1">
    <li>لینوکس را در یک زبان سطح بالای native-code توانمند مانند Pascal، C
        یا C++ مطالعه کنید. زبان‌های با سطح میانی مانند Python، Basic یا Perl در
        اینجا چندان کمکی به شما نمی‌کنند.</li>
    <li>در آن زبان مهارت پیدا کنید. کدی که آن زبان تولید می‌کند را با
        بارگذاری در یک debugger مطالعه کنید، یا آن را به کد assembly ترجمه کنید
        و فایل‌های سورس assembly تولیدشده را بررسی کنید.</li>
    <li>یاد بگیرید چگونه توابع assembly language را به برنامه‌هایی که در زبان
        سطح بالای انتخابی‌تان نوشته شده‌اند، اضافه و لینک کنید.</li>
    <li>مکانیزم زیربنایی windowing را مطالعه کنید. برای لینوکس، این مکانیزم
        تکنولوژی X Window است که چندین کتاب خوب درباره‌اش نوشته شده است. (کتاب
        مورد علاقه‌ی من The Joy of X اثر Niall Mansfield؛ انتشارات
        Addison-Wesley، 1994 است.)</li>
    <li>جزئیات یک محیط دسکتاپ و مجموعه ویجت خاصی را بررسی کنید، چه GNOME،
        KDE، xfce یا غیره. بهترین راه این است که برنامه‌هایی برای آن در زبان سطح
        بالای انتخابی‌تان بنویسید و کد assembly را که کامپایلر تولید می‌کند بررسی
        کنید.</li>
    <li>در نهایت، سعی کنید با تقلید از آنچه کامپایلر تولید می‌کند، کد
        assembly خودتان را ایجاد کنید.</li>
</ol>
<p>انتظار نداشته باشید که به‌صورت آنلاین کمک زیادی پیدا کنید. Unix (و در
    نتیجه لینوکس) به‌شدت در فرهنگ portability سرمایه‌گذاری شده است، فرهنگی که
    مستلزم آن است که بخش عمده‌ی سیستم عامل و همه‌ی برنامه‌های نوشته‌شده برای آن،
    با یک کامپایل ساده، روی یک پلتفرم سخت‌افزاری جدید قابل جابجایی باشند.
    assembly language در دنیای Unix یک کودک یتیم منفور است (تقریباً به اندازه
    زبان سطح بالای مورد علاقه‌ی من، یعنی Pascal، منفور است) و بسیاری از
    قبیله‌گرایان فرهنگی سعی می‌کنند شما را از انجام هر کار جاه‌طلبانه‌ای در
    assembly منصرف کنند. مقاومت کنید—اما به یاد داشته باشید که شما تا حد
    زیادی روی پای خودتان هستید.</p>
<p>اگر فقط به دنبال یک چالش پیشرفته‌تر در assembly language هستید، نوشتن
    برنامه‌های شبکه‌ای با استفاده از Unix sockets را بررسی کنید. این کار تحقیق
    کمتری می‌طلبد و برنامه‌هایی که تولید می‌کنید ممکن است برای مدیریت سرورها یا
    دیگر بسته‌های نرم‌افزاری “پشت صحنه” که نیاز به رابط کاربری گرافیکی ندارند
    مفید باشد. چندین کتاب درباره‌ی sockets programming وجود دارد، اکثر آن‌ها
    توسط W. Richard Stevens نوشته شده‌اند. مطالعه کنید؛ این حوزه‌ای جذاب
    است.</p>
<p>استفاده از Linux Make</p>
<p>اگر تا به حال حتی کمی در C برنامه‌نویسی کرده باشید، تقریباً حتماً با
    مفهوم ابزار Make آشنا هستید. مکانیزم Make در دنیای C رشد کرد، و هرچند
    توسط بسیاری زبان‌ها و محیط‌های برنامه‌نویسی دیگر پذیرفته شده است، اما هرگز
    به اندازه‌ی دنیای C به‌طور کامل پذیرفته نشده است.</p>
<p>کاری که مکانیزم Make انجام می‌دهد این است که فایل‌های اجرایی را از
    اجزای تشکیل‌دهنده‌ی آن‌ها می‌سازد. ابزار Make یک عروسک‌گردان است که دیگر
    برنامه‌ها را مطابق با یک طرح اصلی که یک فایل متنی ساده به نام makefile
    است، اجرا می‌کند. makefile کمی شبیه یک برنامه‌ی کامپیوتری است از این جهت
    که مشخص می‌کند کار چگونه باید انجام شود. اما بر خلاف یک برنامه کامپیوتری،
    توالی دقیق عملیات را تعیین نمی‌کند. در عوض، مشخص می‌کند چه بخش‌هایی از یک
    برنامه برای ساخت بخش‌های دیگر مورد نیاز است و به این ترتیب در نهایت تعیین
    می‌کند که ساخت فایل اجرایی نهایی به چه چیزهایی نیاز دارد. این کار را با
    مشخص کردن قواعدی به نام dependencies انجام می‌دهد.</p>
<p>Dependencies</p>
<p>در ادامه‌ی این کتاب، ما به برنامه‌های کوچک و ریزی نگاه خواهیم کرد که
    عموماً کمتر از 100 خط کد دارند. در دنیای واقعی، برنامه‌های مفید می‌توانند
    هزاران، ده‌ها هزار، یا حتی میلیون‌ها خط کد منبع داشته باشند. مدیریت چنین
    حجم عظیمی از کد منبع، مسئله‌ی محوری در مهندسی نرم‌افزار است. نوشتن
    برنامه‌ها به شکل ماژولار، قدیمی‌ترین و پرکاربردترین روش برای مقابله با
    پیچیدگی برنامه است. تکه تکه کردن یک برنامه‌ی بزرگ به بخش‌های کوچکتر و کار
    کردن روی این بخش‌ها به صورت جداگانه بسیار کمک‌کننده است. در برنامه‌های
    جاه‌طلبانه، برخی از این بخش‌ها حتی بیشتر خرد می‌شوند، و گاهی اوقات بخش‌های
    مختلف در بیش از یک زبان برنامه‌نویسی نوشته می‌شوند. بدیهی است که این کار
    چالش اضافی شناخت نحوه‌ی ایجاد این بخش‌ها و چگونگی اتصال آن‌ها به یکدیگر را
    ایجاد می‌کند. برای این کار شما واقعاً به یک نقشه‌ی راه نیاز دارید.</p>
<p>یک makefile چنین نقشه‌ای است.</p>
<p>در یک برنامه‌ی ماژولار، هر بخش کد به نوعی تولید می‌شود، معمولاً با
    استفاده از یک کامپایلر یا اسمبلر. کامپایلرها، اسمبلرها و لینک‌کننده‌ها یک
    یا چند فایل را می‌گیرند و از آن‌ها فایل‌های جدید تولید می‌کنند. همان‌طور که
    آموخته‌اید، یک اسمبلر، یک فایل ASM پر از سورس کد assembly language را
    می‌گیرد و از آن یک فایل object قابل لینک شدن تولید می‌کند. شما بدون داشتن
    فایل سورس کد و کار بر روی آن نمی‌توانید فایل object code را ایجاد کنید.
    فایل object code برای وجود خود به فایل سورس کد وابسته است.</p>
<p>به طور مشابه، یک linker چندین فایل object code را به یک فایل اجرایی
    واحد متصل می‌کند. فایل اجرایی برای وجود خود به وجود فایل‌های object code
    وابسته است. محتوای یک makefile مشخص می‌کند کدام فایل‌ها برای ایجاد کدام
    فایل‌های دیگر لازم است و چه مراحلی برای ایجاد آن‌ها باید طی شود. ابزار
    Make به قوانین (dependencies) در makefile نگاه می‌کند و هر کامپایلر،
    اسمبلر، یا ابزار دیگری را که برای ساخت فایل اجرایی یا کتابخانه‌ی نهایی
    لازم است، فراخوانی می‌کند.</p>
<p>انواع مختلفی از ابزار Make وجود دارد و همه‌ی makefileها برای همه‌ی
    Makeهای موجود قابل فهم نیستند. با این حال، ابزار Make در Unix نسبتاً
    استاندارد است و همان ابزاری است که همراه با لینوکس ارائه می‌شود و ما در
    اینجا درباره‌ی آن بحث خواهیم کرد.</p>
<p>بیایید یک مثال بزنیم که در واقع یک برنامه‌ی assembly ساده را در لینوکس
    می‌سازد. معمولاً در ایجاد یک makefile، شما از تعیین فایل یا فایل‌هایی شروع
    می‌کنید که برای ایجاد فایل اجرایی لازم‌اند. فایل اجرایی در مرحله‌ی لینک
    ساخته می‌شود، بنابراین اولین dependency که باید تعریف کنید این است که
    کدام فایل‌ها برای لینک شدن به منظور ایجاد فایل اجرایی نیاز هستند. بیان
    dependency خود می‌تواند بسیار ساده باشد.</p>
<pre><code>eatsyscall: eatsyscall.o</code></pre>
<p>تمام آنچه این خط می‌گوید این است که برای تولید فایل اجرایی eatsyscall
    (که در فصل 5 به عنوان Listing 5.1 ارائه شده است) ابتدا به فایل
    eatsyscall.o نیاز داریم. خط قبلی در واقع یک خط dependency است که به صورت
    مناسب برای گنجاندن در یک makefile نوشته شده است. در هر برنامه‌ای جز
    کوچک‌ترین آن‌ها (مانند این نمونه)، linker باید بیش از یک فایل .o را لینک
    کند. بنابراین این احتمالاً ساده‌ترین نوع dependency است: یک فایل اجرایی به
    یک فایل object code وابسته است. اگر فایل‌های اضافه‌تری لازم باشد تا فایل
    اجرایی ایجاد شود، آن‌ها را در یک لیست، با فاصله از هم، قرار می‌دهید:</p>
<pre><code>linkbase: linkbase.o linkparse.o linkfile.o</code></pre>
<p>این خط به ما می‌گوید که فایل اجرایی linkbase به سه فایل object code
    نیاز دارد و هر سه این فایل‌ها باید قبل از تولید فایل اجرایی مورد نظر وجود
    داشته باشند.</p>
<p>خط‌هایی از این دست به ما می‌گویند چه فایل‌هایی لازم‌اند، اما نمی‌گویند با
    آن‌ها چه باید کرد. این بخش ضروری از نقشه‌ی راه در خطی که پس از خط
    dependency می‌آید مشخص می‌شود. این دو خط با هم کار می‌کنند. در اینجا هر دو
    خط را برای مثال ساده‌ی ما می‌بینید:</p>
<pre><code>eatsyscall: eatsyscall.o
     ld -o eatsyscall.o eatsyscall</code></pre>
<p>حداقل برای نسخه‌ی لینوکسی ابزار Make، خط دوم باید با یک کاراکتر tab در
    ابتدای خط تورفتگی داشته باشد. من این را تأکید می‌کنم چون Make در صورت
    نبود tab در ابتدای خط دوم به شما خطا می‌دهد. استفاده از space برای
    تورفتگی کار نمی‌کند. یک پیام خطای معمول “missing tab” (که مبتدی‌ها زیاد
    می‌بینند) شبیه این است:</p>
<pre><code>Makefile:2: *** missing separator. Stop.</code></pre>
<p>در اینجا، یک tab در ابتدای خط 2 وجود نداشته است.</p>
<p>این دو خط در makefile با هم باید نسبتاً ساده قابل فهم باشند: خط اول
    مشخص می‌کند کدام فایل یا فایل‌ها برای انجام کار لازم‌اند. خط دوم مشخص می‌کند
    که کار چگونه باید انجام شود: در این مورد، با استفاده از linker به نام ld
    برای لینک کردن eatsyscall.o به فایل اجرایی eatsyscall.</p>
<p>همه چیز مرتب و تمیز: ما مشخص می‌کنیم چه فایل‌هایی لازم است و چه باید
    کرد. با این حال، مکانیزم Make یک جنبه‌ی بسیار مهم دیگر هم دارد: این که
    بداند آیا لازم است کل کار در این لحظه انجام شود یا نه.</p>
<p>زمانی که یک فایل به‌روز است</p>
<p>ممکن است به نظر بی‌معنی بیاید که بخواهیم این موضوع را بیان کنیم، اما
    وقتی یک فایل کامپایل یا لینک می‌شود، تمام شده است و نیازی به انجام مجدد
    آن نیست… مگر اینکه یکی از فایل‌های کد منبع یا کد شیء مورد نیاز تغییر کند.
    ابزار Make این موضوع را می‌داند. این ابزار می‌تواند تشخیص دهد که آیا نیاز
    به انجام یک عملیات کامپایل یا لینک وجود دارد یا نه، و اگر نیازی به انجام
    آن نباشد، Make از انجام آن خودداری خواهد کرد.</p>
<p>چطور Make می‌فهمد که آیا نیاز به انجام کار وجود دارد؟ این وابستگی را
    در نظر بگیرید:</p>
<pre><code>eatsyscall: eatsyscall.o</code></pre>
<p>Make به این نگاه می‌کند و می‌فهمد که فایل اجرایی eatsyscall به فایل کد
    شیء eatsyscall.o وابسته است و نمی‌توان eatsyscall را بدون داشتن
    eatsyscall.o تولید کرد. همچنین می‌داند که آخرین بار هر دو فایل چه زمانی
    تغییر کرده‌اند و اگر فایل اجرایی eatsyscall جدیدتر از eatsyscall.o باشد،
    استنباط می‌کند که تغییرات ایجاد شده در eatsyscall.o قبلاً در eatsyscall
    اعمال شده‌اند. (این می‌تواند به طور قطعی مطمئن باشد چون تنها راه تولید
    eatsyscall پردازش eatsyscall.o است.)</p>
<p>ابزار Make به زمان‌بندهای لینوکس توجه زیادی دارد. هر زمان که شما یک
    فایل کد منبع را ویرایش کنید یا یک فایل کد شیء یا فایل اجرایی تولید کنید،
    لینوکس زمان‌بند آن فایل را به لحظه‌ای که تغییرات به طور کامل اعمال شده
    است، به‌روزرسانی می‌کند. و حتی اگر فایل اصلی را شش ماه پیش ایجاد کرده
    باشید، به طور قراردادی می‌گوییم که یک فایل جدیدتر از دیگری است اگر
    زمان‌سنج آن نسبت به دیگری که تنها 10 دقیقه پیش ایجاد شده باشد، جدیدتر
    باشد.</p>
<p>(اگر با مفهوم زمان‌سنج آشنا نیستید، باید بدانید که این یک مقدار است که
    سیستم‌عامل در دایرکتوری سیستم فایل برای هر فایل در دایرکتوری ذخیره می‌کند.
    زمان‌سنج یک فایل هر بار که فایل تغییر کند، به زمان فعلی ساعت به‌روزرسانی
    می‌شود.)</p>
<p>زمانی که یک فایل جدیدتر از تمامی فایل‌هایی است که به آن وابسته است (بر
    اساس وابستگی‌هایی که در فایل makefile مشخص شده‌اند)، گفته می‌شود که فایل
    به‌روز است. انجام مجدد آن هیچ فایده‌ای ندارد زیرا تمام اطلاعات موجود در
    فایل‌های وابسته در فایل وابسته منعکس شده است.</p>
<p>زنجیره‌های وابستگی</p>
<p>تا اینجا، ممکن است این موضوع به نظر برسد که تلاش زیادی برای هدفی
    بی‌فایده است. اما ارزش واقعی مکانیزم Make زمانی ظاهر می‌شود که یک فایل
    make شامل زنجیره‌هایی از وابستگی‌ها باشد. حتی در ساده‌ترین makefileها،
    وابستگی‌هایی وجود خواهند داشت که به وابستگی‌های دیگری وابسته‌اند. برنامه
    کاملاً ساده ما به دو دستور وابستگی در فایل make خود نیاز دارد.</p>
<p>در نظر بگیرید که دستور وابستگی زیر مشخص می‌کند چگونه یک فایل اجرایی از
    یک فایل کد شیء (.o) تولید شود:</p>
<pre><code>eatsyscall: eatsyscall.o
     ld -o eatsyscall.o eatsyscall</code></pre>
<p>مفهوم اصلی این است که برای ساخت فایل eatsyscall، ابتدا eatsyscall.o
    را شروع کرده و آن را طبق دستورالعمل در خط دوم پردازش می‌کنید. حالا
    eatsyscall.o از کجا می‌آید؟ برای این کار به دستور وابستگی دومی نیاز
    داریم.</p>
<pre><code>eatsyscall.o: eatsyscall.asm
     nasm -f elf64 -g -F dwarf eatsyscall.asm</code></pre>
<p>در اینجا توضیح می‌دهیم که برای تولید eatsyscall.o به eatsyscall.asm
    نیاز داریم و برای تولید آن دستورالعمل موجود در خط دوم را دنبال می‌کنیم.
    فایل کامل makefile هیچ چیزی جز این دو وابستگی نخواهد داشت:</p>
<pre><code>eatsyscall: eatsyscall.o
     ld -o eatsyscall.o eatsyscall
eatsyscall.o: eatsyscall.asm
     nasm -f elf64 -g -F dwarf eatsyscall.asm</code></pre>
<p>این دو دستور وابستگی دو مرحله‌ای را تعریف می‌کنند که باید برای تولید یک
    فایل اجرایی از فایل کد منبع بسیار ساده زبان اسمبلی eatlinux.asm انجام
    دهیم. اما از آنجا که این دو وابستگی را نشان داده‌ام، اینطور به نظر نمی‌رسد
    که همه این تلاش‌ها ارزشمند باشد. تبدیل eatlinux.asm به‌طور تقریبی نیاز به
    لینک کردن eatlinux.o برای تولید eatlinux دارد. این دو مرحله معمولاً با هم
    در تمامی موارد پیش می‌آیند.</p>
<p>اما در نظر بگیرید یک پروژه برنامه‌نویسی واقعی که در آن صدها فایل کد
    منبع جداگانه وجود دارد. فقط برخی از این فایل‌ها ممکن است در یک ویرایشگر
    باز بوده و در هر روز خاصی در حال تغییر باشند. با این حال، برای ساخت و
    تست برنامه نهایی، همه فایل‌ها لازم هستند. اما… آیا تمام مراحل کامپایل و
    اسمبلی لازم است؟ اصلاً نه.</p>
<p>یک برنامه اجرایی توسط لینک‌کننده از یک یا چندین فایل کد شیء—که اغلب
    خیلی بیشتر از این تعداد است—در کنار هم ساخته می‌شود. اگر تمام فایل‌های کد
    شیء (جز (بیایید بگوییم) دو فایل) به‌روز باشند، هیچ دلیلی برای اسمبل کردن
    دیگر 147 فایل کد منبع وجود ندارد. فقط دو فایل کد منبع که تغییر کرده‌اند
    را اسمبل کرده و سپس تمام 149 فایل کد شیء را به فایل اجرایی لینک
    می‌کنید.</p>
<p>چالش، البته، این است که کدام دو فایل تغییر کرده‌اند را به درستی به یاد
    بیاورید و مطمئن شوید که همه تغییرات اعمال شده به هر یک از 149 فایل کد
    منبع به درستی در فایل اجرایی نهایی اعمال شده است. این یک کار زیادی برای
    به یاد آوردن است یا باید به یادداشت‌ها مراجعه کرد. و این مشکل زمانی بدتر
    می‌شود که بیش از یک نفر روی پروژه کار می‌کند، که در بیشتر موارد در توسعه
    نرم‌افزار تجاری اتفاق می‌افتد. ابزار Make این یادآوری‌ها را بی‌نیاز می‌کند.
    Make خود این موضوعات را تشخیص می‌دهد و فقط کاری را انجام می‌دهد که باید
    انجام شود—نه بیشتر، نه کمتر.</p>
<p>ابزار Make به فایل makefile نگاه می‌کند و به زمان‌بند تمامی فایل‌های کد
    منبع و کد شیء که در فایل makefile ذکر شده‌اند نگاه می‌کند. اگر فایل اجرایی
    جدیدتر از تمام فایل‌های کد شیء باشد، هیچ کاری لازم نیست انجام شود. اما
    اگر هر یک از فایل‌های کد شیء جدیدتر از فایل اجرایی باشد، فایل اجرایی باید
    دوباره لینک شود. و اگر یکی یا چند فایل کد منبع جدیدتر از فایل اجرایی یا
    فایل‌های کد شیء مربوطه خود باشند، باید بعضی از مراحل اسمبلی یا کامپایل
    انجام شوند قبل از اینکه هر لینکینگی انجام شود.</p>
<p>آنچه که Make انجام می‌دهد این است که از فایل اجرایی شروع می‌کند و
    زنجیره‌های وابستگی را که از آن فاصله دارند دنبال می‌کند. فایل اجرایی به یک
    یا چندین فایل کد شیء وابسته است، که به نوبه خود به یک یا چند فایل کد
    منبع وابسته هستند. Make مسیر را در زنجیره‌های مختلف طی می‌کند، توجه می‌کند
    که کدام فایل‌ها جدیدتر از فایل اجرایی هستند و باید چه کاری انجام شود تا
    همه چیز درست شود. سپس Make کامپایلر، اسمبلر و لینک‌کننده را به‌طور انتخابی
    اجرا می‌کند تا اطمینان حاصل کند که فایل اجرایی در نهایت جدیدتر از تمام
    فایل‌هایی است که به آن وابسته‌اند. Make اطمینان می‌یابد که تمام کارهای لازم
    انجام می‌شود. همچنین، Make از صرف وقت غیرضروری برای کامپایل و اسمبل کردن
    فایل‌هایی که از قبل به‌روز هستند و نیازی به کامپایل یا اسمبل شدن ندارند،
    جلوگیری می‌کند. از آنجا که ساخت کامل (که منظور من از آن، بازترکیب/اسمبل و
    دوباره لینک کردن هر فایل در پروژه است) ممکن است ساعت‌ها طول بکشد، Make
    زمان زیادی را صرفه‌جویی می‌کند زمانی که شما تنها به تست تغییرات اعمال شده
    به یک قسمت کوچک از برنامه نیاز دارید.</p>
<p>در واقع امکانات بیشتری در سیستم Make یونیکس وجود دارد اما آنچه که من
    توصیف کردم اصول بنیادی آن است. شما توانایی انجام ساخت و کامپایل مشروط،
    درج مشروط فایل‌ها و بسیاری امکانات دیگر را دارید. برای پروژه‌های اولیه‌تان
    در زبان اسمبلی (یا حتی برنامه‌نویسی C) نیازی به نگرانی درباره این موضوعات
    نخواهید داشت، اما خوب است که بدانید این امکانات در دسترس هستند چرا که
    مهارت‌های برنامه‌نویسی شما پیشرفت می‌کند و پروژه‌های بزرگ‌تری را انجام
    می‌دهید.</p>
<p>اجرای Make</p>
<p>اجرای Make تقریباً ساده‌ترین کاری است که شما در برنامه‌نویسی انجام
    خواهید داد: شما دستور make را در خط فرمان ترمینال تایپ می‌کنید و Enter را
    فشار می‌دهید. Make باقی کارها را انجام می‌دهد. تنها یک گزینه در خط فرمان
    وجود دارد که برای مبتدیان مهم است و آن گزینه -k است. گزینه -k به Make
    دستور می‌دهد تا ساخت هر فایلی را که در آن خطا رخ داده متوقف کند و نسخه
    قبلی فایل هدف را بدون تغییر باقی بگذارد. (اما هر فایل دیگری که نیاز به
    ساخت داشته باشد، همچنان ساخته خواهد شد.) در صورت عدم وجود گزینه -k، Make
    ممکن است فایل‌های کد شیء و اجرایی موجود شما را با نسخه‌های ناقص بازنویسی
    کند، که این موضوع فاجعه‌آمیز نیست اما گاهی ممکن است آزاردهنده و گیج‌کننده
    باشد. اگر این موضوع در حال حاضر کاملاً برای شما روشن نیست، نگران
    نباشید—استفاده از گزینه -k زمانی که هنوز مطمئن نیستید که به آن نیاز
    ندارید، یک ایده خوب است.</p>
<p>با این حال، برای پروژه‌های ساده که هر پروژه در یک دایرکتوری است و یک
    makefile مناسب به نام makefile در هر دایرکتوری وجود دارد، به دایرکتوری
    پروژه‌ای که می‌خواهید روی آن کار کنید بروید و این دستور را تایپ کنید:</p>
<pre><code>make -k</code></pre>
<p>هر زمانی که تغییرات کوچکی در یکی از فایل‌های کد منبع خود ایجاد کنید،
    حتی اگر تغییرات جزئی باشد، باید Make را اجرا کنید تا پیامدهای آن تغییر
    را تست کنید. به عنوان یک مبتدی، احتمالاً با روش “تغییر و آزمایش” یاد
    خواهید گرفت، که به این معنی است که شما ممکن است تنها یک دستور ماشین را
    در یک خط از فایل کد منبع خود تغییر دهید و سپس ببینید که این تغییر چه
    تاثیری دارد.</p>
<p>اگر شما هم اینگونه یاد می‌گیرید (من اینطور یاد می‌گیرم و مشکلی با آن
    ندارم!)، به احتمال زیاد زیاد Make را اجرا خواهید کرد. تمام IDEهای لینوکس
    و بسیاری از ویرایشگرهای متنی لینوکس به شما این امکان را می‌دهند که Make
    را بدون ترک برنامه اجرا کنید. متاسفانه SASM این ویژگی را ندارد. سیستم
    ساخت خود را دارد که به اندازه Make قدرتمند نیست. اما وقتی از SASM به یک
    IDE کامل مانند KDevelop یا Eclipse منتقل می‌شوید، می‌توانید روش‌هایی برای
    اجرای Make از طریق منو یا ترکیب کلید پیدا کنید.</p>
<p>و اگر از یک شبیه‌ساز ترمینال قابل تنظیم مانند Konsole استفاده کنید،
    نیازی به IDE ندارید. شما می‌توانید Make را تنها با یک فشار کلید اجرا
    کنید. Konsole به شما این امکان را می‌دهد که کلیدهای میانبر دلخواه خود را
    ایجاد کنید. یک کلید میانبر یک ارتباط بین یک فشار کلید یا ترکیب فشار کلید
    و یک رشته متنی است که هنگام فشار دادن کلید میانبر در کنسول ترمینال وارد
    می‌شود.</p>
<p>ایجاد کلید میانبر سفارشی برای Make</p>
<p>برای ایجاد یک کلید برای Make، باید یک کلید میانبر به Konsole اضافه
    کنید. جالب اینجاست که Konsole در برخی ویرایشگرهای متنی مانند ویرایشگر
    Kate گنجانده شده است. افزودن کلید میانبر به Konsole به طور خودکار آن را
    به Kate اضافه می‌کند. در واقع، هر برنامه‌ای که از Konsole برای شبیه‌ساز
    ترمینال خود استفاده کند، کلید میانبر Make شما را به ارث خواهد برد.</p>
<p>در اینجا نحوه ایجاد یک کلید میانبر در Konsole آمده است. این گزینه در
    منوی Konsole مخفی است، بنابراین با دقت بخوانید.</p>
<ol type="1">
    <li>Konsole را از صفحه‌کار راه‌اندازی کنید، نه از درون برنامه دیگری.</li>
    <li>از منوی اصلی Konsole به Settings ➪ Manage profiles بروید.</li>
    <li>اگر قبلاً پروفایل جدیدی ایجاد نکردید، یک پروفایل جدید ایجاد کنید. در
        این فصل قبلاً توضیح داده‌ام که چگونه یک پروفایل جدید برای Konsole برای
        پشتیبانی از کدگذاری کاراکتر IBM-850 (برای مجموعه کاراکترهای مرز جعبه
        قدیمی) ایجاد کنید و اگر آن زمان پروفایل جدیدی ایجاد کرده‌اید، پروفایل
        جدید را انتخاب کرده و آن را باز کنید.</li>
    <li>وقتی دیالوگ Edit Profile ظاهر شد، به تب Keyboard بروید.</li>
    <li>وقتی دیالوگ Key Bindings ظاهر شد، مطمئن شوید که xFree 4 انتخاب شده
        است. این مجموعه پیش‌فرض کلیدهای میانبری است که توسط Konsole استفاده
        می‌شود. روی دکمه Edit کلیک کنید.</li>
    <li>وقتی دیالوگ Edit Key Binding List ظاهر شد، لیست کلیدهای میانبر را
        پیمایش کنید تا ببینید آیا برای کلید ScrollLock کلید میانبری وجود دارد یا
        نه.</li>
</ol>
<p>با این حال، گاهی اوقات پیش می‌آید که شما می‌خواهید Make حتی زمانی که
    فایل اجرایی به‌روز است، عمل بیلد را انجام دهد. یکی از موقعیت‌هایی که
    احتمالاً به‌عنوان یک مبتدی با آن مواجه خواهید شد، زمانی است که در حال
    دستکاری خود makefile هستید. اگر شما makefile خود را تغییر داده‌اید و
    می‌خواهید آن را تست کنید، اما فایل اجرایی به‌روز است، باید کمی متقاعدسازی
    انجام دهید. لینوکس دستوری به نام Touch دارد که تنها یک کار انجام می‌دهد:
    به‌روز رسانی زمان‌سنجی یک فایل به زمان فعلی ساعت. اگر دستور Touch را روی
    فایل کد منبع خود اجرا کنید، به طور معجزه‌آسا “جدیدتر” از فایل اجرایی
    می‌شود و Make به طور فرمان‌بردارانه عمل بیلد را انجام خواهد داد.</p>
<p>دستور touch را در پنجره ترمینال وارد کنید، سپس نام فایلی که می‌خواهید
    “تغییر داده” شود را وارد کنید.</p>
<pre><code>touch eatsyscall.asm</code></pre>
<p>سپس دوباره دستور Make را وارد کنید و بیلد انجام خواهد شد—مشروط بر
    اینکه makefile شما وجود داشته باشد و درست باشد!</p>
<p><strong>اشکال‌زدایی با SASM</strong></p>
<p>ویژگی‌های اشکال‌زدایی SASM تا زمانی که به‌طور صریح وارد حالت اشکال‌زدایی
    نشوید، فعال نمی‌شوند. برای وارد شدن به این حالت می‌توانید از منوی Debug ➪
    Debug استفاده کنید، دکمه F5 را روی کیبورد فشار دهید، یا روی آیکن Debug
    در نوار ابزار کلیک کنید. SASM اولین خط کد در برنامه را هایلایت خواهد
    کرد، که برای ویژگی‌های بیلد SASM باید به صورت زیر باشد:</p>
<pre><code>mov rbp,rsp</code></pre>
<p>برنامه در خط هایلایت شده متوقف می‌شود. در این مرحله شما می‌توانید یکی
    از سه کار را انجام دهید.</p>
<ul>
    <li>اجرای کد تا رسیدن به نقطه توقف.</li>
    <li>گام به گام اجرا کردن.</li>
    <li>خاتمه دادن به اشکال‌زدایی و برگشت به ویرایش کد منبع.</li>
</ul>
<p>برای تنظیم یک نقطه توقف، روی شماره خط کدی که می‌خواهید اجرای برنامه در
    آن متوقف شود کلیک کنید. یک دایره قرمز در سمت راست شماره خط ظاهر می‌شود.
    این دایره به شما می‌گوید که یک نقطه توقف در آن خط فعال است. برای اجرای کد
    تا نقطه توقف، می‌توانید از منوی Debug ➢ Continue استفاده کنید، روی آیکن
    Debug در نوار ابزار کلیک کنید، یا دکمه F5 را فشار دهید. هر سه این
    اقدامات سوئیچ‌هایی هستند: زمانی که در حالت ویرایش باشید، آنها SASM را
    وارد حالت اشکال‌زدایی می‌کنند و زمانی که در حالت اشکال‌زدایی باشید، اجرای
    برنامه تا نقطه توقف بعدی ادامه می‌یابد. اگر نقاط توقف دیگری وجود نداشته
    باشد، اجرای برنامه ادامه خواهد یافت تا زمانی که برنامه خاتمه یابد.
    هنگامی که برنامه خاتمه یابد، پنجره گزارش خواهد گفت “Debugging finished”
    و SASM به حالت ویرایش باز می‌گردد.</p>
<p>مهم است که به خاطر داشته باشید که شما نمی‌توانید کد منبع را هنگام
    اشکال‌زدایی ویرایش کنید، هرچند که این کار در برخی مواقع ممکن است مفید به
    نظر برسد. این دو حالت به صورت متقابل از هم جدا هستند. برای برگشت به حالت
    ویرایش، ابتدا باید وارد آن شوید—و این کار به سادگی با کلیک روی دکمه قرمز
    Stop انجام می‌شود.</p>
<p>گام به گام اجرا کردن بسیار ساده است. شما می‌توانید دو گزینه گام به گام
    را از منوی Debug انتخاب کنید یا روی دکمه‌های گام‌زدن در نوار ابزار کلیک
    کنید. دو دکمه گام‌زدن عبارتند از Step Over و Step Into. وقتی که با
    برنامه‌های خیلی ساده کار می‌کنید، از دستور Step Over استفاده خواهید کرد.
    هر بار که روی Step Over کلیک می‌کنید، دستور هایلایت شده اجرا خواهد شد و
    هایلایت به دستور ماشین بعدی منتقل می‌شود. به یاد داشته باشید که دستور زیر
    هایلایت هنوز اجرا نشده است. شما باید به دستور بعدی گام بزنید تا دستور
    هایلایت شده اجرا شود.</p>
<p>گزینه Step Into همان کار Step Over را انجام می‌دهد تا زمانی که دستور
    بعدی که قرار است اجرا شود، دستور CALL باشد. وقتی دستور CALL هایلایت شد،
    شما سه انتخاب دارید.</p>
<ul>
    <li>روی Step Over کلیک کنید و از دستور CALL عبور کنید.</li>
    <li>روی Step Into کلیک کنید و دستور CALL را دنبال کرده و وارد زیرروال
        نام‌گذاری شده توسط CALL شوید. اجرای برنامه وارد زیرروال خواهد شد تا زمانی
        که دستور RET (بازگشت) اجرا شود. سپس دستور بلافاصله بعد از دستور CALL
        هایلایت خواهد شد. (در مورد زیرروال‌ها در ادامه این کتاب توضیح بیشتری داده
        خواهد شد.)</li>
    <li>همانطور که همیشه، می‌توانید با کلیک روی آیکن قرمز Stop در نوار ابزار
        از حالت اشکال‌زدایی خارج شوید.</li>
</ul>
<p>هنگام گام به گام اجرا کردن، پنجره Registers را مشاهده کنید. زمانی که
    چیزی در کد شما یک ریجستر را تغییر دهد، آن تغییر فوراً در پنجره نشان داده
    خواهد شد. نام‌های ریجسترها در ستون چپ پنجره Registers به صورت هگزادسیمال
    نمایش داده می‌شوند. ستون راست، ستون Info است. بیشتر اوقات، ستون Info
    ریجسترها را به صورت ده‌دهی نمایش می‌دهد.</p>
<p>بزرگ‌ترین استثنا، ریجستر EFlags است. در فصل 7 در مورد فلگ‌ها به تفصیل
    صحبت خواهیم کرد. برای اکنون، به EFlags به عنوان مجموعه‌ای از ریجسترهای 1
    بیتی فکر کنید که وضعیت دودویی (یکی از دو حالت) را نشان می‌دهند. شما
    می‌توانید وضعیت هر یک از فلگ‌ها را تست کرده و بسته به حالت یک فلگ، به بخش
    دیگری از برنامه بروید.</p>
<p>یک نکته جانبی: در x64، EFlags به 64 بیت گسترش یافته و به RFlags تبدیل
    شده است، همانطور که احتمالاً انتظار دارید. با این حال، در حال حاضر، 32
    بیت بالایی RFlags مسئولیتی ندارند و برای استفاده‌های آینده اینتل رزرو
    شده‌اند. به همین دلیل، پنجره Registers در SASM EFlags را به جای RFlags
    نمایش می‌دهد. این بدان معنا نیست که شما هیچ فلگی را از دست داده‌اید. تمام
    فلگ‌هایی که وجود دارند در EFlags هستند.</p>
<p>پنجره Registers نام فلگ‌هایی که تنظیم شده‌اند (مساوی با 1) را در داخل
    براکت‌ها نمایش می‌دهد. در پنجره Info، EFlags چیزی شبیه به این خواهد
    بود:</p>
<pre><code>[ PF ZF IF ]</code></pre>
<p>(این فقط یک مثال است؛ ممکن است فلگ‌های بیشتری یا کمتری ببینید.)
    دستورهای انشعاب زیادی وجود دارند که فلگ‌های فردی را تست می‌کنند و دیدن
    اینکه کدام فلگ‌ها تنظیم شده‌اند (یا نشده‌اند) قبل از اجرای یک دستور انشعاب
    بسیار مفید است.</p>
<p>حالا، در مقایسه با بیشتر اشکال‌زدایان، گزینه نمایش حافظه در SASM بسیار
    محدود است. در فصل 7 نحوه نمایش داده‌ها را توضیح می‌دهم. نمایش حافظه‌های
    پیوسته به حدی پیچیده است که من شما را به یک اشکال‌زدای قدرتمندتر (هرچند
    که دسترسی به آن بسیار دشوارتر است) ارجاع می‌دهم که عملکرد بهتری در نمایش
    محتویات یک منطقه حافظه دارد (به پیوست A مراجعه کنید).</p>
<p><strong>ابزارهای خود را بردارید…</strong></p>
<p>در این نقطه، شما پیش‌زمینه و ابزارهایی که نیاز دارید را دارید. وقت آن
    رسیده است (بالاخره!) که بنشینید و دستورالعمل‌های x64 را به تفصیل بررسی
    کنید و سپس شروع به نوشتن برنامه‌ها به طور جدی کنید.</p>

</body>
</html>