<!doctype html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Document</title>
</head>
<body>
<p>فصل ۳: برداشتن درپوش؛ کشف اینکه کامپیوترها واقعاً چه هستند</p>
<p><strong>RAX عزیز، ما به سختی تو را شناختیم</strong></p>
<p>در ژانویه ۱۹۷۰، من در اواخر سال آخر دبیرستان بودم و مدارس عمومی
    شیکاگو در جایی یک کامپیوتر نصب کرده بودند. یک کامیون پر از این دستگاه‌های
    تایپ لوکس آی‌بی‌ام به مدرسه لین تک تحویل داده شد و یک معلم ریاضی گیج برای
    تدریس علوم کامپیوتر (همانطور که جرات کردند آن را بنامند) به دبیرستانی پر
    از پسران شلوغ (و بیشتر خوره) منصوب شد.</p>
<p>من به سرعت موضوع را فهمیدم. شما یک دسته کارت‌های کامپیوتری عجیب را با
    دستگاه پانچ کارت تایپ می‌کردید، آنها را در هاپر کارت یکی از دستگاه‌های
    تایپ قرار می‌دادید و با شگفتی تماشا می‌کردید که چگونه تایپ‌کننده توپ گلفی
    کوچک خود را روی کاغذ سبز حرکت می‌دهد و لیست اجتناب‌ناپذیر پیام‌های خطای شما
    را چاپ می‌کند. این سرگرم‌کننده بود. من نمره‌های عالی گرفتم. حتی اولین
    برنامه‌ای که نوشتم و کاری مفید انجام می‌داد را نگه داشتم؛ در آن زمان
    ستاره‌شناسی علاقه من بود: یک دسته کارت کوچک که جدولی از عوامل تصحیح سهمی
    برای محاسبه دستی آینه‌های تلسکوپ تولید می‌کرد. (من هنوز آن دسته کارت را
    دارم، هرچند که چسبندگی باقی‌مانده از نوارهای لاستیکی متلاشی شده برای یک
    کارت‌خوان سالم نیست، فرض بر این که یکی هنوز وجود داشته باشد.)</p>
<p>سوالی که مدام مرا آزار می‌داد این بود که دقیقاً RAX (نام بسیار مناسبی
    برای کامپیوتر) چه جور موجودی بود. آنچه ما داشتیم تایپ‌کننده‌هایی بود که با
    رم شارژ شده بودند و RAX آنها را از طریق خطوط تلفن کنترل می‌کرد—تا آنجا را
    فهمیدم. اما خود RAX چه بود؟</p>
<p>از مدرس پرسیدم. به طور خلاصه، مکالمه چیزی شبیه به این بود:</p>
<p><strong>من</strong>: «ببخشید، آقا، دقیقاً RAX چیست؟»</p>
<p><strong>او</strong>: «ها؟ ام، یک کامپیوتر. یک کامپیوتر
    الکترونیکی.»</p>
<p><strong>من</strong>: «این چیزی است که در یادداشت‌های دوره گفته شده
    است. اما من می‌خواهم بدانم RAX از چه ساخته شده و چگونه کار می‌کند.»</p>
<p><strong>او</strong>: «خب، مطمئنم که RAX کاملاً حالت جامد است.»</p>
<p><strong>من</strong>: «یعنی داخلش اهرم‌ها و چرخ‌دنده‌ها نیست.»</p>
<p><strong>او</strong>: «اوه، شاید چند تا باشد. اما لامپ خلاء
    ندارد.»</p>
<p><strong>من</strong>: «من نگران لامپ‌ها نبودم. حدس می‌زنم جایی یک ماشین
    حساب در آن باشد. اما چه چیزی باعث می‌شود که به یاد بیاورد A قبل از B
    می‌آید؟ چگونه می‌داند FORMAT به چه معناست؟ چگونه زمان را تشخیص می‌دهد؟ برای
    پاسخ به تلفن چه کاری باید انجام دهد؟»</p>
<p><strong>او</strong>: «حالا، بیا، به همین دلیل است که کامپیوترها عالی
    هستند! آنها همه چیز را کنار هم قرار می‌دهند تا ما نگران این چیزها نباشیم!
    چه کسی اهمیت می‌دهد که RAX چیست؟ RAX فورترن را می‌داند و هر برنامه فورترن
    صحیحی را اجرا می‌کند. این مهم است، نیست؟»</p>
<p>او شروع به عرق کردن کرد. من هم همینطور. پایان مکالمه.</p>
<p>آن ژوئن با ۳ اینچ کارت‌های پانچ شده فورترن که دیباگ و کار می‌کردند از
    مدرسه فارغ‌التحصیل شدم و هنوز هیچ سرنخی نداشتم که RAX واقعاً چه بود.</p>
<p>این موضوع تا به امروز مرا اذیت کرده است.</p>
<p><strong>گاس به نجات می‌آید</strong></p>
<p>شش سال بعد، در حال فکر کردن به RAX بودم، در حالی که در اتوبوس خیابان
    دوون شیکاگو به سمت محل کار می‌رفتم و آخرین نسخه مجله Popular Electronics
    در دامنم بود. داستان اصلی پروژه‌ای به نام COSMAC ELF را توصیف می‌کرد که
    شامل یک تکه برد سوراخ‌دار پر از تراشه‌های مدار مجتمع، همه به هم سیم‌کشی
    شده، به‌علاوه چند سوئیچ تلگرافی و یک جفت نمایشگر عددی LED بود.</p>
<p>این یک کامپیوتر بود. (درست روی برچسب نوشته شده بود، هه.) مقاله به ما
    گفت که چگونه آن را کنار هم قرار دهیم، و همین بود. آن تراشه‌ها چه می‌کردند؟
    کل دستگاه چه می‌کرد؟ هیچ تایپ‌کننده روباتیک فانتزی در دید نبود. داشت من را
    دیوانه می‌کرد.</p>
<p>مثل همیشه، دوستم گاس فلاسیگ در خیابان اشلند سوار اتوبوس شد و کنارم
    نشست. از او پرسیدم که COSMAC ELF چه کاری انجام می‌دهد. او اولین انسانی
    بود که مفهوم یک کامپیوتر فیزیکی را برای من روشن کرد:</p>
<hr/>
<p>«اینها تراشه‌های حافظه هستند. شما اعداد را به حافظه بارگذاری می‌کنید با
    تلگرافی کردن این سوئیچ‌ها در الگوهای کد باینری مختلف، جایی که “بالا” به
    معنی یک بیت ۱ و “پایین” به معنی یک بیت ۰ است. هر عدد در حافظه برای تراشه
    CPU معنی خاصی دارد. یک عدد باعث می‌شود جمع کند؛ عدد دیگری باعث می‌شود
    تفریق کند؛ عدد دیگری باعث می‌شود اعداد مختلفی را در حافظه بنویسد، و
    چیزهای زیادی دیگر. یک برنامه شامل تعدادی از این اعداد دستورالعمل در یک
    ردیف در حافظه است. کامپیوتر اولین عدد را می‌خواند، کاری را که عدد به آن
    می‌گوید انجام می‌دهد، سپس دومین را می‌خواند، کاری را که آن عدد می‌گوید انجام
    می‌دهد، و همینطور ادامه می‌دهد تا اینکه اعداد تمام شوند.»</p>
<hr/>
<p>اگر این برای شما کاملاً روشن نیست؛ نگران نباشید. من مزیت این را داشتم
    که یک علاقه‌مند به الکترونیک بودم (پس می‌دانستم برخی از تراشه‌ها چه می‌کنند)
    و قبلاً چند برنامه در فورترن RAX نوشته بودم. اما برای من، خدای من، همه
    چیز ناگهان به جرم بحرانی رسید و در سرم منفجر شد تا اینکه بخار از گوش‌هایم
    بیرون آمد. فهمیدم!</p>
<p>مهم نبود که RAX چه بود، می‌دانستم که باید چیزی شبیه به COSMAC ELF
    باشد، فقط در مقیاس بزرگتر. یک ELF ساختم. این یک آموزش عالی بود و به من
    اجازه داد تا ماهیت کامپیوترها را در سطحی بسیار عمیق درک کنم. دیگر به کسی
    توصیه نمی‌کنم که کامپیوتر خود را از تراشه‌های جداگانه بسازد، اگرچه این کار
    در اواسط تا اواخر دهه ۱۹۷۰ کار رایجی بود.</p>
<p>در این فصل برخی از بینش‌هایی را که هنگام ساخت کامپیوتر خودم به سختی به
    دست آوردم، در اختیار شما قرار می‌دهم. (می‌خواهید بدانید “سخت” در
    “سخت‌افزار” از کجا می‌آید؟ قول می‌دهم از صدایی که هنگام کوبیدن آن روی میز
    ایجاد می‌کند، نیست.)</p>
<p><strong>سوئیچ‌ها، ترانزیستورها، و حافظه</strong></p>
<p>سوئیچ‌ها به خاطر می‌سپارند.</p>
<p>به آن فکر کنید: شما کلید دیواری کنار در را فشار می‌دهید و چراغ وسط سقف
    روشن می‌شود. روشن می‌ماند. وقتی از اتاق خارج می‌شوید، دوباره کلید را پایین
    می‌زنید و چراغ خاموش می‌شود. خاموش می‌ماند. با صرف نظر از ارواح، کلید در
    موقعیتی که آخرین بار آن را ترک کرده‌اید باقی می‌ماند تا زمانی که شما یا
    شخص دیگری بازگردید و آن را به موقعیت دیگرش تغییر دهید. حتی اگر لامپ
    بسوزد، می‌توانید به موقعیت دسته کلید نگاه کنید و بدانید که مدار روشنایی
    روشن است یا خاموش.</p>
<p>به یک معنا، کلید به یاد می‌آورد که آخرین فرمانش چه بود تا زمانی که شما
    آن را تغییر دهید و فرمان قبلی را با یک فرمان جدید “بازنویسی” کنید. از
    این نظر، یک کلید روشنایی نمایانگر نوعی عنصر حافظه ابتدایی است.</p>
<p>کلیدهای روشنایی بیشتر مکانیکی هستند تا الکتریکی. این مانع از عمل به
    عنوان حافظه نمی‌شود. در واقع، اولین کامپیوتر (موتور تفاضلی بابیج در قرن
    نوزدهم) کاملاً مکانیکی بود. در واقع، نسخه بسیار بزرگتری که او طراحی کرد
    اما هرگز تکمیل نکرد قرار بود با بخار کار کند. ماشین بابیج تعداد زیادی
    بادامک کوچک داشت که می‌توانستند توسط بادامک‌های دیگر از یک موقعیت به
    موقعیت دیگر تغییر کنند. اعداد به عنوان الگوهای موقعیت بادامک‌ها کدگذاری و
    به خاطر سپرده می‌شدند.</p>
<p><strong>یکی اگر از راه زمینی…</strong></p>
<p>فرقی نمی‌کند که یک سوئیچ مکانیکی، الکتریکی، هیدرولیکی یا چیز دیگری
    باشد. آنچه مهم است این است که یک سوئیچ حاوی یک الگوی دوطرفه است: روشن یا
    خاموش؛ بالا یا پایین؛ جریان یا بدون جریان. به آن الگو می‌توان معنایی
    اختصاص داد. پل ریویر به دوستش گفت که در کلیسای قدیمی شمال یک کد تنظیم
    کند: «یکی اگر از راه زمینی، دو تا اگر از راه دریایی.» وقتی چراغ‌ها روشن
    شدند، در مناره روشن ماندند (و بنابراین آن کد بسیار مهم را به خاطر
    سپردند) تا پل بتواند شبه‌نظامیان را صدا بزند و بریتانیایی‌ها را شکست
    دهد.</p>
<p>به طور کلی، چیزی که ما آن را حافظه می‌نامیم، مجموعه‌ای از سوئیچ‌ها است
    که الگوی خود را به اندازه کافی طولانی نگه می‌دارند تا آن الگو توسط یک شخص
    یا مکانیزم خوانده و درک شود. برای اهداف ما، آن سوئیچ‌ها الکتریکی خواهند
    بود، اما به یاد داشته باشید که هم کامپیوترهای مکانیکی و هم هیدرولیکی
    پیشنهاد شده و با درجات مختلف موفقیت ساخته شده‌اند.</p>
<p>حافظه شامل محفظه‌هایی برای الگوهای قابل تغییر است که یک الگوی وارد شده
    را حفظ می‌کنند تا زمانی که کسی یا چیزی آن الگو را تغییر دهد.</p>
<p><strong>سوئیچ‌های ترانزیستوری</strong></p>
<p>یکی از مشکلات ساخت سیستم حافظه کامپیوتر از کلیدهای روشنایی این است که
    کلیدهای روشنایی بسیار تخصصی هستند: آنها نیاز به انگشتان برای تنظیم دارند
    و خروجی آنها یک مسیر جریان برای الکتریسیته است. ایده‌آل این است که یک
    سوئیچ حافظه کامپیوتر باید توسط همان نیرویی که کنترل می‌کند عمل کند. این
    اجازه می‌دهد تا الگوهای ذخیره شده در حافظه به مکان‌های ذخیره‌سازی حافظه
    دیگر منتقل شوند. در دنیای الکترومکانیکی، چنین سوئیچی رله نامیده
    می‌شود.</p>
<p>یک رله یک سوئیچ مکانیکی است که توسط الکتریسیته برای کنترل الکتریسیته
    عمل می‌کند. شما با تغذیه یک پالس الکتریکی به آن، رله را “فشار” می‌دهید، که
    یک چکش کوچک را قدرت می‌دهد تا اهرمی را به یک طرف یا طرف دیگر بزند. سپس
    این اهرم مجموعه‌ای از تماس‌های الکتریکی را باز یا بسته می‌کند، درست مانند
    کلید روشنایی معمولی شما. کامپیوترهایی از رله‌ها ساخته شده‌اند، اگرچه
    همانطور که می‌توانید تصور کنید، این مدت‌ها پیش بود و (با یک رله معمولی به
    اندازه یک مکعب یخ) آنها کامپیوترهای به‌خصوص قدرتمندی نبودند.</p>
<p>کامپیوترهای کاملاً الکترونیکی از سوئیچ‌های ترانزیستوری ساخته می‌شوند.
    ترانزیستورها کریستال‌های کوچکی از سیلیکون هستند که از خواص الکتریکی خاص
    سیلیکون برای عمل به عنوان سوئیچ استفاده می‌کنند. سعی نمی‌کنم توضیح دهم که
    آن خواص خاص چیست، زیرا این کار نیاز به یک کتاب کامل دارد. بیایید یک
    سوئیچ ترانزیستوری را به صورت یک جعبه سیاه الکتریکی در نظر بگیریم و آن را
    از نظر ورودی‌ها و خروجی‌ها توصیف کنیم.</p>
<p>شکل ۳.۱ یک سوئیچ ترانزیستوری را نشان می‌دهد. (این یک ترانزیستور اثر
    میدانی است که در حقیقت تنها یکی از انواع ترانزیستور است، اما نوعی است که
    کامپیوترهای امروزی ما از آن ساخته شده‌اند.) وقتی یک ولتاژ الکتریکی به
    پایه ۱ اعمال می‌شود، جریان بین پایه‌های ۲ و ۳ جریان می‌یابد. وقتی ولتاژ از
    پایه ۱ برداشته می‌شود، جریان بین پایه‌های ۲ و ۳ متوقف می‌شود.</p>
<p>در زندگی واقعی، تعداد کمی از اجزای دیگر (معمولاً دیودها و خازن‌ها) برای
    کار روان در زمینه حافظه کامپیوتر لازم هستند. این‌ها لزوماً گیزموهای کوچکی
    نیستند که با سیم به بیرون ترانزیستور متصل شده‌اند (اگرچه در کامپیوترهای
    ترانزیستوری اولیه اینگونه بودند) بلکه از همان کریستال سیلیکونی که خود
    ترانزیستور از آن بریده شده است ساخته شده‌اند و تقریباً هیچ فضایی اشغال
    نمی‌کنند. ترانزیستور سوئیچ و اجزای پشتیبانی آن با هم یک سلول حافظه نامیده
    می‌شوند. من پیچیدگی الکتریکی سلول حافظه را در یک نماد جعبه سیاه مناسب در
    شکل ۳.۱ پنهان کرده‌ام.</p>
<figure>
    <img src="link_to_figure_3_1"
         alt="تصویر سوئیچ‌های ترانزیستوری و سلول‌های حافظه."/>
    <figcaption aria-hidden="true">تصویر سوئیچ‌های ترانزیستوری و سلول‌های
        حافظه.
    </figcaption>
</figure>
<p><strong>شکل ۳.۱: سوئیچ‌های ترانزیستوری و سلول‌های حافظه</strong></p>
<p>یک سلول حافظه جریان را از طریق خود به حداقل می‌رساند زیرا جریان
    الکتریکی گرما تولید می‌کند و گرما دشمن اجزای الکتریکی است. مدار سلول
    حافظه به گونه‌ای تنظیم شده است که اگر یک ولتاژ کوچک به پایه ورودی آن و یک
    ولتاژ مشابه به پایه انتخاب آن اعمال کنید، یک ولتاژ روی پایه خروجی آن
    ظاهر می‌شود و باقی می‌ماند. آن ولتاژ خروجی در حالت تنظیم خود باقی می‌ماند
    تا زمانی که ولتاژ از سلول به طور کلی برداشته شود یا ولتاژ از پایه ورودی
    در حالی که ولتاژ روی پایه انتخاب اعمال می‌شود، برداشته شود.</p>
<p>ولتاژ “روشن” که به همه این پایه‌ها اعمال می‌شود در یک سطح ثابت نگه
    داشته می‌شود (البته به جز زمانی که به طور کامل برداشته می‌شود). به عبارت
    دیگر، شما ۱۲ ولت به پایه ورودی اعمال نمی‌کنید و سپس آن را به ۶ ولت یا ۱۷
    ولت تغییر نمی‌دهید. طراحان کامپیوتر یک ولتاژ را انتخاب می‌کنند و به آن
    پایبند هستند. الگو به صورت باینری است: یا ولتاژی را به پایه ورودی اعمال
    می‌کنید، یا به طور کامل ولتاژ را حذف می‌کنید. پایه خروجی آن را تکرار
    می‌کند: یا یک ولتاژ ثابت را نگه می‌دارد یا هیچ ولتاژی ندارد.</p>
<p>ما به این حالت یک کد اعمال می‌کنیم: حضور ولتاژ نشان‌دهنده یک ۱ باینری
    است، و عدم وجود ولتاژ نشان‌دهنده یک ۰ باینری است. این کد دلخواه است. ما
    می‌توانستیم بگوییم که عدم وجود ولتاژ نشان‌دهنده یک ۱ باینری است و برعکس (و
    کامپیوترهایی به این شکل ساخته شده‌اند به دلایل مبهم)، اما انتخاب با ماست.
    داشتن حضور چیزی به عنوان یک ۱ باینری طبیعی‌تر است و اینگونه است که در
    جریان اصلی محاسبات تکامل یافته است.</p>
<p>یک سلول حافظه کامپیوتر منفرد، مانند آنچه در مورد آن صحبت می‌کنیم، یک
    رقم باینری را نگه می‌دارد، یا ۱ یا ۰. این یک بیت نامیده می‌شود. یک بیت اتم
    تجزیه‌ناپذیر اطلاعات است. هیچ نیم بیت و بیت و نیم وجود ندارد.</p>
<p>یک بیت یک رقم باینری منفرد است، یا ۱ یا ۰.</p>
<p><strong>بیت شگفت‌انگیز در حال کوچک شدن</strong></p>
<p>یک بیت چیز زیادی به ما نمی‌گوید. برای مفید بودن، ما باید تعداد زیادی
    سلول حافظه را کنار هم قرار دهیم. ترانزیستورها با اندازه نسبتاً کوچک شروع
    شدند (نمونه‌های اولیه از دهه ۱۹۵۰ بسیار شبیه به کلاه‌های اجاق برای سربازان
    قلع بودند) و از آنجا کوچک شدند. اولین ترانزیستورها از تراشه‌های کوچک
    ژرمانیوم یا سیلیکون در حدود یک هشتم اینچ مربع ساخته شدند. اندازه تراشه
    کریستالی از آن زمان به طرز فاحشی تغییر نکرده است، اما خود ترانزیستورها
    به طرز باورنکردنی کوچک شده‌اند.</p>
<p>در حالی که در ابتدا یک تراشه یک ترانزیستور را در خود جای می‌داد، با
    گذشت زمان طراحان نیمه‌هادی تراشه را به چهار ناحیه مساوی تقسیم کردند و هر
    ناحیه را به یک ترانزیستور مستقل تبدیل کردند. از آنجا یک جهش آسان بود به
    اضافه کردن سایر اجزای بسیار کوچک مورد نیاز برای تبدیل یک ترانزیستور به
    یک سلول حافظه کامپیوتر.</p>
<p>تراشه سیلیکونی یک چیز کوچک و شکننده بود و در یک محفظه پلاستیکی
    قالب‌گیری شده مستطیلی قرار می‌گرفت، مانند یک آدامس کوچک با پایه‌های فلزی
    برای اتصالات الکتریکی.</p>
<p>آنچه اکنون داشتیم نوعی کارتن تخم‌مرغ الکتریکی بود: چهار خانه کوچک، که
    هر کدام می‌توانستند حاوی یک بیت باینری باشند. سپس فرآیند کوچک‌سازی آغاز
    شد. ابتدا ۸ بیت، سپس ۱۶ بیت، سپس مضرب‌های ۸ و ۱۶، همه روی همان تراشه کوچک
    سیلیکون. تا اواخر دهه ۱۹۶۰، ۲۵۶ سلول حافظه می‌توانستند روی یک تراشه
    سیلیکون ساخته شوند، معمولاً در آرایه‌ای از ۸ سلول در ۳۲ سلول. در سال ۱۹۷۶،
    کامپیوتر COSMAC ELF من شامل دو تراشه حافظه بود. روی هر تراشه یک آرایه از
    سلول‌های حافظه به عرض ۴ و طول ۲۵۶ قرار داشت. (تصور کنید یک کارتن تخم‌مرغ
    واقعاً بلند.) هر تراشه می‌توانست ۱۰۲۴ بیت را در خود جای دهد.</p>
<p>این یک ظرفیت تراشه حافظه نسبتاً معمول در آن زمان بود. ما آنها را
    “تراشه‌های رم ۱K” می‌نامیدیم زیرا حدود ۱۰۰۰ بیت حافظه دسترسی تصادفی (RAM)
    را در خود داشتند. K از کیلوبیت می‌آید، یعنی ۱۰۰۰ بیت. بعداً به مفهوم اینکه
    حافظه دسترسی تصادفی چیست باز خواهیم گشت.</p>
<p>به سمت اواسط دهه ۱۹۷۰، عمل کوچک‌سازی بزرگ حافظه به سرعت در حال افزایش
    بود. تراشه‌های ۱ کیلوبایت به ۴ قسمت تقسیم شدند و به تراشه‌های ۴K تبدیل
    شدند که حاوی ۴۰۹۶ بیت حافظه بودند. تراشه‌های ۴K تقریباً بلافاصله به
    تراشه‌های ۱۶K تقسیم شدند (۱۶۳۸۴ بیت حافظه). این تراشه‌های ۱۶K استاندارد
    زمانی بودند که کامپیوتر IBM PC در سال ۱۹۸۱ ظاهر شد. تا سال ۱۹۸۲، تراشه‌ها
    دوباره تقسیم شدند و ۱۶K به ۶۴K تبدیل شد، با ۶۵۵۳۶ بیت در داخل همان آدامس
    کوچک. به خاطر داشته باشید که ما در مورد بیش از ۶۵۰۰۰ ترانزیستور (به
    علاوه سایر اجزای عجیب) صحبت می‌کنیم که روی یک مربع سیلیکونی در حدود یک
    چهارم اینچ در یک طرف قرار گرفته‌اند.</p>
<p>تا سال ۱۹۹۰، تراشه ۲۵۶K تاریخ شده بود و تراشه ۱ مگابیت حالت هنر بود.
    (مگا در یونانی به معنای میلیون است.) تا سال ۱۹۹۲، تراشه ۴ مگابیت جایگزین
    شده بود. موجود کوچک دارای مجموع عظیم ۴۱۹۴۳۰۴ بیت در داخل بود، هنوز هم
    بزرگ‌تر از آن آدامس دارچینی نبود. در حدود آن زمان، خود تراشه‌ها به اندازه
    کافی کوچک و شکننده شده بودند که چهار یا هشت تا از آنها روی بردهای مدار
    چاپی کوچک لحیم شوند تا از دست زدن انسان‌های دست و پا چلفتی جان سالم به در
    ببرند. این “استیک‌های حافظه” چیزی است که کامپیوترهای مدرن از آنها استفاده
    می‌کنند. آنها این مزیت را دارند که در بسیاری از موارد می‌توانید آنها را
    بردارید و با استیک‌های حافظه حتی بزرگتر جایگزین کنید.</p>
<p>بازی تراشه‌های حافظه همچنان ادامه دارد، و در سال ۲۰۲۲، تراشه‌های ۱۶
    گیگابیتی جریان اصلی هستند. این یعنی ۱۶ میلیارد بیت در هر تراشه.</p>
<p>آیا اینجا متوقف خواهد شد؟ بعید است. در این دنیای بازی‌های ویدیویی
    بلادرنگ و ویدیوهای 4K، بیشتر بهتر است، و ما در حال به کارگیری برخی
    فناوری‌های شگفت‌انگیز برای ایجاد سیستم‌های حافظه با تراکم بیشتر هستیم. برخی
    فیزیکدانان هشدار می‌دهند که قوانین فیزیک ممکن است به زودی در بازی وقفه‌ای
    ایجاد کنند، زیرا ترانزیستورها اکنون آنقدر کوچک هستند که عبور بیش از یک
    الکترون در یک زمان از آنها سخت می‌شود. در آن نقطه، برخی محدودیت‌های واقعاً
    زشت زندگی به نام مکانیک کوانتومی شروع به دخالت می‌کنند. ما راهی برای دور
    زدن این محدودیت‌ها پیدا خواهیم کرد (همیشه این کار را می‌کنیم)، اما در این
    فرآیند ممکن است کل ماهیت حافظه کامپیوتر تغییر کند.</p>
<p>اگر تلاش برای پیگیری آنچه در دنیای کامپیوتر “جریان” است سر شما را درد
    می‌آورد، خوب، تنها نیستید.</p>
<p><strong>دسترسی تصادفی</strong></p>
<p>تازه‌واردان گاهی اوقات کلمه تصادفی را با احترام به حافظه گیج‌کننده و
    نگران‌کننده می‌یابند، زیرا اغلب دلالت بر هرج و مرج یا غیرقابل پیش‌بینی بودن
    دارد. آنچه کلمه واقعاً در اینجا به معنای “به طور تصادفی” است، نشان می‌دهد
    که شما می‌توانید به یک تراشه حافظه دسترسی تصادفی دست دراز کنید و هر یک از
    بیت‌های آن را بدون مختل کردن بقیه انتخاب کنید، همانطور که ممکن است یک
    کتاب را به طور تصادفی از بین قفسه‌های متعدد هزاران کتاب در کتابخانه عمومی
    خود انتخاب کنید بدون اینکه آنها را به ترتیب غربال کنید یا مکان سایر
    کتاب‌ها را روی قفسه‌ها مختل کنید.</p>
<p>حافظه همیشه اینگونه کار نمی‌کرد. قبل از اینکه حافظه روی تراشه‌های
    سیلیکونی قرار گیرد، روی ماشین‌های الکترومغناطیسی از نوعی ذخیره می‌شد،
    معمولاً درام‌ها یا دیسک‌های چرخان که به دور از درایوهای سختی که امروز
    استفاده می‌کنیم نبودند. حافظه مغناطیسی چرخان مجموعه‌ای دایره‌ای از بیت‌ها را
    زیر یک سنسور مغناطیسی می‌فرستد. بیت‌ها یکی یکی زیر سنسور عبور می‌کنند، و
    اگر بیت مورد نظر را از دست بدهید، مانند اتوبوس شیکاگو در ژانویه، فقط
    باید منتظر بمانید تا دوباره بیاید. این‌ها دستگاه‌های دسترسی سریالی هستند.
    آنها بیت‌های خود را به صورت سریالی، به ترتیب ثابت، یکی یکی به شما ارائه
    می‌دهند، و شما باید منتظر بمانید تا بیت مورد نظر شما به ترتیب خود
    بیاید.</p>
<p>نیازی به یادآوری آن نیست؛ ما از مدت‌ها پیش دستگاه‌های دسترسی سریالی را
    برای حافظه اصلی کامپیوتر کنار گذاشته‌ایم. ما هنوز از چنین سیستم‌هایی برای
    ذخیره‌سازی انبوه استفاده می‌کنیم، همانطور که چند صفحه بعد توضیح خواهم داد.
    (هارد دیسک شما در قلب خود یک دستگاه دسترسی سریالی است.)</p>
<p>دسترسی تصادفی اینگونه کار می‌کند: داخل تراشه، هر بیت در سلول حافظه خاص
    خود ذخیره می‌شود، همانطور که سلول حافظه در شکل ۳.۱ نشان داده شده است. هر
    یک از سلول‌های حافظه، هر چند تا که باشد، یک عدد منحصر به فرد دارد. این
    عدد آدرس سلول (و بنابراین بیت) است. این مانند آدرس‌های یک خیابان است: بیت
    در گوشه شماره ۰ کوچه سیلیکون است، و بیت کناری ۱ است، و همینطور ادامه
    دارد. شما نیازی ندارید که به در بیت ۰ بزنید و بپرسید کدام بیت است و سپس
    به در بعدی بروید و آنجا هم بپرسید، تا زمانی که بیت مورد نظر را پیدا
    کنید. اگر آدرس را داشته باشید، می‌توانید مستقیم به سمت بیت مورد نظر
    بروید.</p>
<p>هر تراشه تعدادی پایه بیرون زده دارد. بخش عمده‌ای از این پایه‌ها به
    عنوان پایه‌های آدرس شناخته می‌شوند. یک پایه به عنوان پایه داده شناخته
    می‌شود. (شکل ۳.۲ را ببینید.) پایه‌های آدرس خطوط الکتریکی هستند که یک کد
    آدرس باینری را حمل می‌کنند. این آدرس یک عدد باینری است، که فقط با ۱ و ۰
    بیان می‌شود. شما این آدرس را به پایه‌های آدرس اعمال می‌کنید با کدگذاری یک ۱
    باینری به عنوان (مثلاً) ۵ ولت، و یک ۰ باینری به عنوان ۰ ولت. بسیاری
    ولتاژهای دیگر در سخت‌افزار کامپیوتر استفاده شده‌اند و هنوز هم استفاده
    می‌شوند. آنچه مهم است این است که همه موافقیم که یک ولتاژ خاص روی یک پایه
    نشان‌دهنده یک ۱ باینری است. مدارهای ویژه داخل تراشه RAM این آدرس را به
    یکی از ورودی‌های انتخاب سلول‌های حافظه متعدد داخل تراشه رمزگشایی می‌کنند.
    برای هر آدرسی که به پایه‌های آدرس اعمال می‌شود، فقط یک ورودی انتخاب به ۵
    ولت افزایش می‌یابد، بنابراین آن سلول حافظه انتخاب می‌شود.</p>
<p>بسته به اینکه قصد دارید یک بیت را بخوانید یا بنویسید، پایه داده بین
    ورودی‌ها یا خروجی‌های سلول‌های حافظه سوئیچ می‌شود، همانطور که در شکل ۳.۲
    نشان داده شده است.</p>
<p>اما همه این‌ها به صورت داخلی در تراشه انجام می‌شود. تا آنجا که شما در
    بیرون نگران هستید، وقتی آدرس را به پایه‌های آدرس اعمال کردید، voilà! پایه
    داده حاوی ولتاژی است که نشان‌دهنده مقدار بیتی است که درخواست کرده‌اید. اگر
    آن بیت حاوی یک ۱ باینری بود، پایه داده حاوی یک سیگنال ۵ ولت خواهد بود؛
    در غیر این صورت، بیت ۰ باینری با ۰ ولت نشان داده می‌شود.</p>
<figure>
    <img src="link_to_figure_3_2" alt="تصویر یک تراشه RAM."/>
    <figcaption aria-hidden="true">تصویر یک تراشه RAM.</figcaption>
</figure>
<p><strong>شکل ۳.۲: یک تراشه RAM</strong></p>
<p><strong>زمان دسترسی به حافظه</strong></p>
<p>تراشه‌ها بر اساس مدت زمانی که طول می‌کشد تا داده پس از اعمال آدرس به
    پایه‌های آدرس روی پایه داده ظاهر شود، درجه‌بندی می‌شوند. بدیهی است که هر چه
    سریع‌تر بهتر، اما برخی تراشه‌ها (به دلایل الکتریکی که دوباره توضیح آنها
    دشوار است) سریع‌تر از دیگران هستند.</p>
<p>سال‌ها پیش، زمانی که کامپیوترها از تراشه‌های جداگانه‌ای که به مادربردهای
    خود وصل می‌شدند استفاده می‌کردند، زمان دسترسی به حافظه عمدتاً زمانی بود که
    طول می‌کشید تا داده پس از اعمال آدرس به تراشه‌ها ظاهر شود. حتی در آن زمان،
    مسائل دیگری وجود داشت که به سرعت تراشه CPU و نحوه طراحی کلی سیستم حافظه
    مربوط می‌شد.</p>
<p>امروزه، سیستم‌های حافظه PC بر روی استیک‌های حافظه متمرکز شده‌اند (بعداً
    بیشتر در مورد آن صحبت خواهیم کرد)، که چندین تراشه حافظه را با مقدار
    زیادی مدار پشتیبانی ترکیب می‌کنند. استیک‌ها به سرعت CPU کامپیوتری که در آن
    کار می‌کنند و به انواع سوکت‌هایی که در آن قرار می‌گیرند حساس هستند.
    زمان‌بندی حافظه در ۲۰ سال گذشته بسیار پیچیده‌تر شده است. چندین عامل تعیین
    می‌کنند که تراشه‌های حافظه چقدر سریع می‌توانند یک آدرس را بپذیرند و کالاها
    را تحویل دهند. در اینجا یک توضیح خوب است، با این هشدار که یک ارائه بسیار
    فنی است:</p>
<p><a
        href="https://appuals.com/ram-timings-cas-ras-trcd-trp-tras-explained">https://appuals.com/ram-timings-cas-ras-trcd-trp-tras-explained</a>
</p>
<p>می‌توانم به شما اطمینان دهم که برای یادگیری زبان اسمبلی نیازی به درک
    کامل پیچیدگی‌های سخت‌افزار حافظه PC ندارید. همانطور که درباره داخلی‌های PC
    بیشتر یاد می‌گیرید، کم‌کم همه چیز سر جای خود قرار می‌گیرد.</p>
<p><strong>بایت‌ها، کلمات، دابل‌وردها، و کواد‌وردها</strong></p>
<p>روزهایی که یک کامپیوتر جدی را می‌شد با تنها یک تراشه حافظه ساخت
    مدت‌هاست گذشته است (در واقع دهه‌هاست). کامپیوتر کوچکم COSMAC ELF در سال
    ۱۹۷۶ حداقل به دو تراشه نیاز داشت. کامپیوترهای امروزی به تعداد زیادی نیاز
    دارند، صرف نظر از این واقعیت که تراشه‌های حافظه امروزی می‌توانند میلیاردها
    بیت را در خود جای دهند، نه ۲۰۴۸ بیت ناچیز ELF.</p>
<p>سیستم حافظه ما باید اطلاعات ما را ذخیره کند. نحوه سازماندهی یک سیستم
    حافظه از یک دسته تراشه‌های حافظه عمدتاً توسط نحوه سازماندهی اطلاعات ما
    تعیین می‌شود.</p>
<p>پاسخ با چیزی به نام بایت شروع می‌شود. این واقعیت که پدربزرگ همه مجلات
    کامپیوتری این کلمه را برای عنوان خود انتخاب کرد اهمیت آن را در طرح کلی
    کامپیوتر نشان می‌دهد. (افسوس، مجله Byte در اواخر سال ۱۹۹۸ منتشر شدن را
    متوقف کرد.) از دیدگاه عملکردی، حافظه بر حسب بایت اندازه‌گیری می‌شود. یک
    بایت هشت بیت است. دو بایت کنار هم یک کلمه نامیده می‌شوند، و دو کلمه کنار
    هم یک دابل‌ورد نامیده می‌شوند. یک کواد‌ورد، همانطور که می‌توانید تصور کنید،
    از دو دابل‌ورد تشکیل شده است، یعنی در مجموع چهار کلمه یا هشت بایت. در جهت
    دیگر، در گذشته برخی افراد به گروهی از چهار بیت به عنوان نیبل اشاره
    می‌کردند—نیبل نیمی از یک بایت است. (این اصطلاح اکنون تا حد زیادی منسوخ
    شده است.)</p>
<p>در اینجا یک مرور سریع است:</p>
<ul>
    <li>یک بیت یک رقم باینری منفرد است، ۰ یا ۱.</li>
    <li>یک بایت ۸ بیت کنار هم است.</li>
    <li>یک کلمه ۲ بایت کنار هم است: ۱۶ بیت.</li>
    <li>یک دابل‌ورد ۲ کلمه کنار هم است: ۳۲ بیت.</li>
    <li>یک کواد‌ورد ۲ دابل‌ورد کنار هم است: ۶۴ بیت.</li>
</ul>
<p>کامپیوترها برای ذخیره و دستکاری اطلاعات انسانی طراحی شده‌اند. عناصر
    اساسی گفتار انسانی از یک مجموعه نمادها ساخته شده‌اند که شامل حروف الفبا
    (دو تا از هر کدام برای حروف بزرگ و کوچک)، ارقام، و نمادهایی مانند کاما،
    دونقطه، نقطه، علامت تعجب و غیره است. به اینها انواع تغییرات بین‌المللی
    حروف مانند ä و ò را اضافه کنید به علاوه نمادهای ریاضی دقیق‌تر، و خواهید
    دید که اطلاعات انسانی به یک مجموعه نماد با بیش از ۲۰۰ نماد نیاز دارد.
    (مجموعه نماد مورد استفاده در تقریباً تمام کامپیوترهای سبک PC در ضمیمه C
    ارائه شده است.)</p>
<p>بایت‌ها در این طرح مرکزی هستند زیرا یک نماد از آن مجموعه نماد را
    می‌توان به زیبایی در یک بایت بیان کرد. یک بایت ۸ بیت است، و ۲⁸ برابر است
    با ۲۵۶. این بدان معناست که یک عدد باینری ۸ بیتی می‌تواند یکی از ۲۵۶ مقدار
    مختلف باشد، از ۰ تا ۲۵۵ شماره‌گذاری شده است. از آنجا که ما این نمادها را
    بسیار استفاده می‌کنیم، بیشتر آنچه در برنامه‌های کامپیوتری انجام می‌دهیم به
    صورت تکه‌های به اندازه بایت بیان می‌شود که اعداد یا متن را نشان می‌دهد. این
    بدان معنا نیست که کامپیوترها فقط بر روی بایت‌های منفرد عمل می‌کنند. در
    واقع، بیشتر کامپیوترهای امروزی می‌توانند اطلاعات را به اندازه یک کواد‌ورد
    (هشت بایت یا ۶۴ بیت) در یک زمان پردازش کنند. ماشین‌های ۳۲ بیتی که ۲۰ سال
    پیش شکست‌ناپذیر به نظر می‌رسیدند به سرعت در حال محو شدن در مه تاریخ
    هستند.</p>
<p>برای عملی کردن بین‌المللی‌سازی و بومی‌سازی نرم‌افزار، یک استاندارد برای
    مجموعه کاراکترها به نام یونی‌کد وجود دارد، که خود مجموعه‌ای از استانداردها
    است. مجموعه کاراکترهای یونی‌کد ممکن است در یک تا چهار بایت بیان شوند، که
    اولین بایت آن تقریباً با مجموعه کاراکتر استاندارد ASCII که مدت‌هاست تثبیت
    شده است یکسان است. توضیح اینکه کدگذاری یونی‌کد چگونه کار می‌کند خارج از
    مأموریت این کتاب است، اما برای برنامه‌نویسان خارج از ایالات متحده ارزش
    مطالعه دارد.</p>
<p><strong>تراشه‌های زیبا همه در یک ردیف</strong></p>
<p>یکی از چیزهای گیج‌کننده برای مبتدیان این است که یک تراشه RAM منفرد حتی
    یک بایت هم ندارد… هرچند ممکن است چندین میلیارد بیت داشته باشد. بیشتر
    تراشه‌های RAM منفردی که امروزه استفاده می‌کنیم بیش از هشت پایه داده
    ندارند، و برخی فقط یک پایه داده دارند. کل سیستم‌های حافظه با ترکیب
    تراشه‌های حافظه منفرد به روش‌های هوشمندانه به صورت الکتریکی ایجاد
    می‌شوند.</p>
<p>یک مثال ساده کمک خواهد کرد. شکل ۳.۳ را در نظر بگیرید. من یک سیستم
    حافظه را کشیده‌ام که یک بایت ذخیره شده را در هشت تراشه RAM جداگانه توزیع
    می‌کند. هر یک از مستطیل‌های سیاه یک تراشه RAM مانند آنچه در شکل ۳.۲ نشان
    داده شده است را نشان می‌دهد. یک بیت از بایت در هر یک از هشت تراشه ذخیره
    می‌شود، در همان آدرس در تمام هشت تراشه. پایه‌های آدرس ۲۰ پایه برای هر هشت
    تراشه به هم متصل شده‌اند، “به صورت موازی” همانطور که یک برقکار ممکن است
    بگوید. هنگامی که کامپیوتر یک آدرس حافظه را به ۲۰ خط آدرس اعمال می‌کند،
    آدرس به طور همزمان روی پایه‌های آدرس هر هشت تراشه حافظه در سیستم حافظه
    ظاهر می‌شود. به این ترتیب، یک آدرس واحد به طور همزمان به پایه‌های آدرس هر
    هشت تراشه اعمال می‌شود، که هشت بیت را به طور همزمان روی هشت خط داده تحویل
    می‌دهند، با یک بیت از هر تراشه.</p>
<figure>
    <img src="link_to_figure_3_3"
         alt="تصویر یک سیستم حافظه ۱ مگابایتی ساده."/>
    <figcaption aria-hidden="true">تصویر یک سیستم حافظه ۱ مگابایتی
        ساده.
    </figcaption>
</figure>
<p><strong>شکل ۳.۳: یک سیستم حافظه ۱ مگابایتی ساده</strong></p>
<p>در دنیای واقعی، چنین سیستم‌های حافظه ساده دیگر وجود ندارند، و روش‌های
    زیادی برای توزیع تراشه‌ها (و بیت‌های ذخیره شده آنها) در یک سیستم حافظه
    وجود دارد. همه تراشه‌های حافظه امروزی در واقع بیش از یک بیت را در هر آدرس
    ذخیره می‌کنند. تراشه‌هایی که یک، دو، سه، چهار یا هشت بیت در هر آدرس ذخیره
    می‌کنند نسبتاً رایج هستند. نحوه طراحی یک سیستم حافظه کامپیوتری سریع و
    کارآمد یک زیرشاخه کامل در مهندسی برق است، و همانطور که تراشه‌های حافظه ما
    بهبود می‌یابند تا سلول‌های حافظه بیشتری را در خود جای دهند، “بهترین” راه
    برای طراحی یک سیستم حافظه فیزیکی ممکن است تغییر کند، شاید به طور
    رادیکال.</p>
<p>به هر حال، مدت زیادی است که مجبور نبوده‌ایم تراشه‌های حافظه منفرد را به
    کامپیوترهای خود وصل کنیم. امروزه، تراشه‌های حافظه تقریباً همیشه در
    ماژول‌های حافظه دو خطی پلاگین (DIMM) با ظرفیت‌های مختلف جمع می‌شوند. این
    ماژول‌ها بردهای مدار سبز رنگ کوچکی هستند که حدود ۵ اینچ طول و ۱ اینچ
    ارتفاع دارند. از حدود سال ۱۹۹۰، تمام کامپیوترهای سازگار با PC رومیزی از
    چنین ماژول‌هایی استفاده می‌کنند، معمولاً به صورت جفت. هر ماژول که در حال
    حاضر استفاده می‌شود معمولاً ۶۴ بیت را در هر آدرس حافظه ذخیره می‌کند.</p>
<p>امروزه در سال ۲۰۲۲، مجموعه گیج‌کننده‌ای از ماژول‌های حافظه DIMM مختلف
    وجود دارد، با تعداد پین‌های مختلف و ترکیبات مختلف تراشه‌ها برای پذیرش
    انواع مختلف کامپیوترها. نکته مهمی که باید به خاطر داشت این است که نحوه
    ترکیب تراشه‌های حافظه در یک سیستم حافظه بر نحوه عملکرد برنامه‌های شما
    تأثیری ندارد. وقتی یک برنامه که نوشته‌اید به یک بایت حافظه در یک آدرس خاص
    دسترسی پیدا می‌کند، کامپیوتر وظیفه آوردن آن را از مکان مناسب در آن جنگل
    تراشه‌ها و بردهای مدار DIMM بر عهده دارد. یک سیستم حافظه که به یک روش خاص
    مرتب شده است ممکن است داده‌ها را از حافظه سریع‌تر از یک سیستم حافظه که به
    روش دیگری مرتب شده است برگرداند، اما آدرس‌ها یکسان هستند، و داده‌ها یکسان
    هستند. از دیدگاه برنامه شما، هیچ تفاوت عملکردی وجود ندارد مگر اینکه سرعت
    اجرای برنامه‌های شما مهم باشد.</p>
<p>برای خلاصه کردن، به صورت الکتریکی، حافظه کامپیوتر شما از یک یا چند
    ردیف تراشه‌های حافظه روی بردهای کوچک (و عموماً قابل جابجایی) مدار ساخته
    شده است، هر تراشه حاوی تعداد زیادی سلول حافظه ساخته شده از ترانزیستورها
    و سایر اجزای الکتریکی کوچک است. بیشتر اوقات، برای جلوگیری از سردرگمی،
    فراموش کردن ترانزیستورها و حتی ردیف‌های تراشه‌های فیزیکی مفید است. (معلم
    فورترن دبیرستان من کاملاً اشتباه نمی‌کرد… اما او به دلایل اشتباه درست
    بود.)</p>
<p>در طول سال‌ها، سیستم‌های حافظه به روش‌های مختلفی دسترسی پیدا کرده‌اند.
    کامپیوترهای ۸ بیتی (اکنون باستانی و تقریباً منقرض شده) به حافظه ۸ بیت (یک
    بایت) در یک زمان دسترسی داشتند. کامپیوترهای ۱۶ بیتی به حافظه ۱۶ بیت (یک
    کلمه) در یک زمان دسترسی دارند، و کامپیوترهای ۳۲ بیتی به حافظه ۳۲ بیت (یک
    دابل‌ورد) در یک زمان دسترسی دارند. کامپیوترهای مدرن مبتنی بر پردازنده‌های
    ۶۴ بیتی x64 به حافظه ۶۴ بیت (یک کواد‌ورد) در یک زمان دسترسی دارند. این
    می‌تواند گیج‌کننده باشد، بنابراین بهتر است در بیشتر موارد یک ردیف بسیار
    طولانی از محفظه‌های به اندازه بایت را تصور کنیم که هر کدام آدرس منحصر به
    فرد خود را دارند. فرض نکنید که در کامپیوترهایی که اطلاعات را یک کلمه در
    یک زمان پردازش می‌کنند فقط کلمات آدرس دارند. این یک قرارداد در معماری PC
    است که هر بایت آدرس عددی منحصر به فرد خود را دارد، صرف نظر از تعداد
    بایت‌هایی که در یک عملیات از حافظه خارج می‌شوند.</p>
<p>هر بایت حافظه در کامپیوتر دارای آدرس منحصر به فرد خود است، حتی در
    کامپیوترهایی که ۲، ۴ یا ۸ بایت اطلاعات را در یک زمان پردازش می‌کنند.</p>
<p>اگر این ضد شهودی به نظر می‌رسد، یک مثال دیگر کمک خواهد کرد. وقتی به
    کتابخانه می‌روید تا سه جلد از فانتزی عظیم تالکین، “ارباب حلقه‌ها” را
    بردارید، خواهید دید که هر یک از سه جلد دارای شماره فهرست کارت خود است
    (در اصل آدرس آن جلد در کتابخانه)، اما شما همه سه تا را یکجا برمی‌دارید و
    آنها را به عنوان یک موجودیت واحد پردازش می‌کنید. اگر واقعاً بخواهید،
    می‌توانید فقط یکی از کتاب‌ها را در یک زمان از کتابخانه امانت بگیرید، اما
    انجام این کار نیاز به دو سفر دیگر به کتابخانه دارد تا دو جلد دیگر را
    بگیرید، که باعث هدر رفتن زمان و تلاش شما می‌شود.</p>
<p>بنابراین با کامپیوترهای ۶۴ بیتی اینگونه است. هر بایت آدرس خود را
    دارد، اما وقتی یک کامپیوتر ۶۴ بیتی به یک بایت در حافظه اصلی دسترسی پیدا
    می‌کند، در واقع ۶۴ بایت را می‌خواند، با بایت درخواست شده در جایی در داخل
    بلوکی که خوانده شده است. این بلوک ۶۴ بایت به عنوان یک خط کش نامیده
    می‌شود. کش اساساً یک بلوک از مکان‌های حافظه داخل خود تراشه CPU است، و نه در
    خارج در DIMM‌های روی مادربرد. خواندن داده‌ها یا دستورالعمل‌ها از کش بسیار
    سریع‌تر از خواندن آنها از حافظه خارجی است. همانطور که برنامه شما ادامه
    می‌دهد، خواندن، نوشتن و اجرا می‌کند، بیشتر آنچه برنامه استفاده می‌کند قبلاً
    در کش وجود دارد. CPU دارای برخی ماشین‌های بسیار پیشرفته برای مدیریت کش
    است. این ماشین به طور مداوم حافظه را از حافظه خارجی وارد می‌کند و تمام
    تلاش خود را می‌کند تا پیش‌بینی کند که برنامه شما در مرحله بعد از چه
    حافظه‌ای استفاده خواهد کرد.</p>
<p>توصیف چگونگی کار این ماشین مدیریت کش شامل چیزهای پیچیده دیگری مانند
    حافظه مجازی، صفحه‌بندی و پیش‌بینی شاخه می‌شود، که خارج از محدوده یک کتاب
    مقدماتی مانند این است. خبر خوب این است که تمام این ماشین‌ها توسط یک
    مشارکت بین CPU و سیستم عامل کنترل می‌شوند. برنامه شما همانطور اجرا خواهد
    شد صرف نظر از اینکه چه چیزی در کش است و چه چیزی نیست. (دوباره، ممکن است
    سریع‌تر یا کندتر اجرا شود بسته به اینکه CPU چقدر باید از حافظه خارجی
    بیاورد.) به عنوان یک برنامه‌نویس مبتدی، نیازی نیست که با خطوط کش و سایر
    موارد نگران باشید. با این حال، هنگامی که به اندازه کافی از یک کارشناس
    اسمبلی هستید تا درک کنید که کش و سایر مکانیزم‌های مدیریت حافظه چگونه بر
    سرعت برنامه تأثیر می‌گذارند، باید آن مکانیزم‌ها را از بالا به پایین یاد
    بگیرید.</p>
<p><strong>سرپرست کارگاه و خط مونتاژ</strong></p>
<p>تمام این صحبت‌ها درباره خواندن چیزها از حافظه و نوشتن چیزها به حافظه
    تا کنون به دقت از این سوال که چه کسی در حال خواندن و نوشتن است دوری کرده
    است. “چه کسی” تقریباً همیشه یک تراشه منفرد است، و تراشه قابل توجهی هم
    هست: واحد پردازش مرکزی یا CPU. اگر شما رئیس و مدیر عامل کامپیوتر شخصی
    خود هستید، CPU سرپرست کارگاه شماست که می‌بیند دستورات شما در میان تراشه‌ها
    که کار در آنجا انجام می‌شود اجرا می‌شود.</p>
<p>برخی می‌گویند که CPU همان چیزی است که در واقع کار را انجام می‌دهد، اما
    در حالی که تا حد زیادی درست است، یک ساده‌سازی است. کار واقعی زیادی در
    سیستم حافظه و همچنین در چیزی که به عنوان محیط‌های جانبی نامیده می‌شود،
    مانند بردهای نمایش ویدئویی، پورت‌های USB و شبکه و غیره انجام می‌شود.
    بنابراین، در حالی که CPU کار زیادی را انجام می‌دهد، همچنین کار زیادی را
    به سایر اجزای داخل کامپیوتر تقسیم می‌کند، عمدتاً برای این که CPU بتواند
    آنچه را که بهترین کار را انجام می‌دهد سریع‌تر انجام دهد. مانند هر مدیر
    خوب، سرپرست کارگاه هر چه را که می‌تواند به سایر زیرسیستم‌های کامپیوتر
    واگذار می‌کند.</p>
<p>بیشتر تراشه‌های CPU که در ماشین‌هایی استفاده می‌کنیم که به صورت گروهی
    آنها را PC می‌نامیم توسط شرکتی به نام اینتل طراحی شده‌اند که تقریباً در
    اوایل دهه ۱۹۷۰ پردازنده CPU تک تراشه را اختراع کرد. CPUهای اینتل از آن
    زمان به سرعت تکامل یافته‌اند، همانطور که کمی بعد در این فصل توضیح خواهم
    داد. تغییرات زیادی در جزئیات در طول سال‌ها وجود داشته است، اما از یک سطح
    بالا، آنچه هر CPU اینتل یا سازگار با اینتل انجام می‌دهد تا حد زیادی یکسان
    است.</p>
<p><strong>صحبت با حافظه</strong></p>
<p>مهم‌ترین وظیفه تراشه CPU ارتباط با سیستم حافظه کامپیوتر است. مانند یک
    تراشه حافظه، تراشه CPU یک مربع کوچک از سیلیکون است که روی آن تعداد زیادی
    ترانزیستور—امروزه، میلیاردها ترانزیستور!—قرار گرفته‌اند. تراشه سیلیکونی
    شکننده در یک محفظه فلزی/سرامیکی با تعداد زیادی پایه اتصال الکتریکی که از
    سطح پایین یا لبه‌های آن بیرون زده‌اند قرار دارد. مانند پایه‌های تراشه‌های
    حافظه، پایه‌های CPU اطلاعات را به صورت سطح ولتاژ منتقل می‌کنند، معمولاً ۳
    تا ۵ ولت. پنج ولت روی یک پایه نشان‌دهنده یک ۱ باینری است، و صفر ولت روی
    یک پایه نشان‌دهنده یک ۰ باینری است.</p>
<p>مانند تراشه‌های حافظه، تراشه CPU تعدادی پایه اختصاص داده شده به
    آدرس‌های حافظه دارد، و این پایه‌ها به سیستم حافظه کامپیوتر متصل هستند. من
    این را در شکل ۳.۴ کشیده‌ام، و سیستم حافظه در سمت چپ تراشه CPU همان سیستمی
    است که در شکل ۳.۳ کشیدم، فقط آن را روی پهلو قرار داده‌ام. وقتی CPU
    می‌خواهد یک بایت (یا یک کلمه، دابل‌ورد یا کواد‌ورد) را از حافظه بخواند،
    آدرس حافظه بایتی را که می‌خواهد بخواند را به پایه‌های آدرس خود می‌فرستد،
    کدگذاری شده به عنوان یک عدد باینری. کسری بسیار کوچکی از یک ثانیه بعد،
    بایت درخواست شده (همچنین به عنوان یک عدد باینری) روی پایه‌های داده
    تراشه‌های حافظه ظاهر می‌شود. تراشه CPU همچنین دارای پایه‌های داده است و
    بایتی را که توسط تراشه‌های حافظه ارائه شده است از طریق پایه‌های داده خود
    جذب می‌کند.</p>
<p>این فرآیند، البته، برعکس هم کار می‌کند. برای نوشتن یک بایت در حافظه،
    CPU ابتدا آدرس حافظه‌ای را که می‌خواهد در آن بنویسد را روی پایه‌های آدرس
    خود قرار می‌دهد. پس از چند نانوثانیه (که بسته به سرعت کلی سیستم و نحوه
    ترتیب حافظه از سیستمی به سیستم دیگر متفاوت است) CPU بایتی را که می‌خواهد
    در حافظه بنویسد را روی پایه‌های داده خود قرار می‌دهد. سیستم حافظه با اطاعت
    بایت را در داخل خود در آدرس درخواست شده ذخیره می‌کند.</p>
<p>شکل ۳.۴، البته، کاملاً مفهومی است. سیستم‌های حافظه مدرن بسیار پیچیده‌تر
    از آنچه در شکل نشان داده شده است هستند، اما از یک ارتفاع همه آنها به یک
    روش کار می‌کنند: CPU یک آدرس را به سیستم حافظه می‌فرستد، و سیستم حافظه یا
    داده‌ها را از CPU برای ذخیره در آن آدرس می‌پذیرد یا داده‌های یافت شده در آن
    آدرس را روی گذرگاه داده کامپیوتر قرار می‌دهد تا CPU آن را پردازش کند.</p>
<figure>
    <img src="link_to_figure_3_4" alt="تصویر CPU و حافظه."/>
    <figcaption aria-hidden="true">تصویر CPU و حافظه.</figcaption>
</figure>
<p>شکل ۳.۴: پردازنده (CPU) و حافظه</p>
<p><strong>سوار شدن بر گذرگاه داده</strong></p>
<p>این تعامل بین پردازنده (CPU) و سیستم حافظه بخش عمده‌ای از آنچه در داخل
    کامپیوتر شما رخ می‌دهد را تشکیل می‌دهد. اطلاعات از حافظه به پردازنده جریان
    می‌یابد و بالعکس. اطلاعات در مسیرهای دیگری نیز جریان دارد. کامپیوتر شما
    دستگاه‌های اضافی به نام تجهیزات جانبی (پریفرال‌ها) دارد که یا منبع یا مقصد
    (یا هر دو) برای اطلاعات هستند.</p>
<p>کارت‌های نمایش ویدئویی، درایوهای دیسک، پورت‌های USB و پورت‌های شبکه از
    متداول‌ترین تجهیزات جانبی در کامپیوترهای نوع PC هستند. مانند پردازنده و
    حافظه، همه آن‌ها در نهایت دستگاه‌های الکتریکی هستند. بیشتر تجهیزات جانبی
    مدرن از یک یا دو تراشه بزرگ و شاید چند تراشه کوچکتر که از تراشه‌های
    بزرگ‌تر پشتیبانی می‌کنند، تشکیل شده‌اند. مانند تراشه‌های پردازنده و حافظه،
    این دستگاه‌های جانبی نیز دارای پین‌های آدرس و پین‌های داده هستند. برخی از
    تجهیزات جانبی، به‌ویژه کارت‌های ویدئویی، تراشه‌های حافظه خود را دارند و
    امروزه حتی پردازنده‌های اختصاصی خود را نیز دارند. (کارت ویدئویی مدرن با
    کارایی بالا خود یک کامپیوتر قدرتمند است، هرچند با وظیفه‌ای خاص و
    محدود.)</p>
<p>تجهیزات جانبی با پردازنده “صحبت” می‌کنند (یعنی داده را به پردازنده
    می‌فرستند یا از آن دریافت می‌کنند) و گاهی با یکدیگر نیز ارتباط دارند. این
    مکالمات از طریق اتصالات الکتریکی که پین‌های آدرس و داده را که همه
    دستگاه‌های کامپیوتر مشترکاً دارند، به هم متصل می‌کنند، انجام می‌شود. این
    خطوط الکتریکی “گذرگاه داده” نامیده می‌شوند و نوعی خط ارتباطی مشترک را
    تشکیل می‌دهند که پردازنده را به سایر قسمت‌های کامپیوتر متصل می‌کند. سیستم
    پیچیده‌ای از داوری الکتریکی وجود دارد که تعیین می‌کند کِی و به چه ترتیبی
    دستگاه‌های مختلف می‌توانند از این خط مشترک برای ارتباط با یکدیگر استفاده
    کنند. اما به طور کلی به همین شکل عمل می‌کند: یک آدرس بر روی گذرگاه قرار
    می‌گیرد و به دنبال آن مقداری داده می‌آید. (مقدار داده‌ای که در یک زمان
    منتقل می‌شود به تجهیزات جانبی مربوطه بستگی دارد.) سیگنال‌های ویژه‌ای همراه
    با آدرس بر روی گذرگاه ارسال می‌شوند تا نشان دهند که آیا آدرس مربوط به یک
    مکان در حافظه است یا یکی از تجهیزات جانبی متصل به گذرگاه داده. آدرس یک
    دستگاه جانبی “آدرس ورودی/خروجی (I/O)” نامیده می‌شود تا آن را از یک آدرس
    حافظه مانند آنچه تا کنون بحث کرده‌ایم، متمایز کند.</p>
<p>گذرگاه داده عنصر اصلی در اسلات‌های توسعه‌ای است که در بسیاری از
    کامپیوترهای نوع PC وجود دارد، هرچند اکنون کمتر از دهه‌های گذشته است.
    بسیاری از تجهیزات جانبی (به‌ویژه آداپتورهای نمایش ویدئویی) بردهای مدار
    چاپی هستند که به این اسلات‌ها متصل می‌شوند. تجهیزات جانبی از طریق اتصالات
    گذرگاه داده که به صورت پین‌های الکتریکی در اسلات‌های توسعه خارج شده‌اند، با
    پردازنده و حافظه ارتباط برقرار می‌کنند.</p>
<p>با وجود اینکه اسلات‌های توسعه بسیار مفید هستند، اما باعث ایجاد تأخیر
    در سیستم کامپیوتری می‌شوند. هر چه زمان می‌گذرد، تجهیزات جانبی بیشتر و
    بیشتر فقط شامل چند تراشه روی گوشه‌ای از برد مدار اصلی (مادربرد) داخل
    کامپیوتر می‌شوند. این‌گونه تجهیزات جانبی “تجهیزات جانبی یکپارچه” نامیده
    می‌شوند که معمول‌ترین آن‌ها گرافیک یکپارچه است که از یک یا چند تراشه با
    کاربرد خاص روی مادربرد تشکیل شده است. امروزه در سال ۲۰۲۲، کامپیوترهای
    شخصی مدرنی وجود دارند که به‌طور خاص برای گرافیک‌های انیمیشنی بلادرنگ با
    وضوح بالا (عمدتاً برای بازی‌ها) طراحی شده‌اند، و چنین ماشین‌هایی معمولاً
    دارای اسلات‌های توسعه ویژه‌ای هستند که به‌طور خاص برای نگه‌داری کارت‌های
    گرافیک طراحی شده‌اند.</p>
<p><strong>جیب‌های سرکارگر</strong></p>
<p>هر پردازنده چند محفظه ذخیره‌سازی داده به نام “ثبات” (رجیستر) دارد. این
    ثبات‌ها هم‌زمان جیب‌ها و میز کار سرکارگر هستند. وقتی پردازنده نیاز دارد
    چیزی را برای مدت کوتاهی کنار بگذارد، یک ثبات خالی دقیقاً همان‌جاست.
    پردازنده همیشه می‌تواند داده را در حافظه ذخیره کند، اما این کار به‌طور
    قابل‌توجهی بیشتر از قرار دادن داده در یک ثبات زمان می‌برد. از آنجا که
    ثبات‌ها در واقع داخل پردازنده هستند، قرار دادن داده در یک ثبات یا خواندن
    مجدد آن از ثبات سریع است.</p>
<p>اما مهم‌تر از آن، ثبات‌ها میز کار سرکارگر هستند. وقتی پردازنده نیاز
    دارد دو عدد را با هم جمع کند، آسان‌ترین و سریع‌ترین راه این است که اعداد
    را در دو ثبات قرار دهد و دو ثبات را با هم جمع کند. حاصل جمع (در روش
    معمول پردازنده) جایگزین یکی از دو عدد اصلی می‌شود که جمع شده بودند، اما
    پس از آن می‌توان حاصل جمع را در ثبات دیگری قرار داد، به عدد دیگری در ثبات
    دیگر اضافه کرد، در حافظه ذخیره کرد، یا در هر یک از بسیاری عملیات دیگر
    شرکت کند.</p>
<p>کار فوری پردازنده در حال انجام، در محفظه‌های ذخیره‌سازی موقتی به نام
    ثبات‌ها نگهداری می‌شود.</p>
<p>کارهایی که شامل ثبات‌ها هستند همیشه سریع‌اند، زیرا ثبات‌ها داخل پردازنده
    هستند و به‌طور ویژه به یکدیگر و به ماشین‌آلات داخلی پردازنده متصل‌اند. حرکت
    داده بسیار کمی لازم است—و داده‌ای که حرکت می‌کند نیازی ندارد فاصله زیادی
    طی کند.</p>
<p>مانند سلول‌های حافظه و در واقع مانند کل پردازنده، ثبات‌ها از ترانزیستور
    ساخته شده‌اند. اما به جای داشتن آدرس‌های عددی، ثبات‌ها نام‌های جداگانه‌ای
    مانند RAX یا RDI دارند. برای پیچیده‌تر کردن امور، در حالی که همه ثبات‌های
    پردازنده دارای خواص مشترکی هستند، برخی ثبات‌ها قدرت‌های ویژه و منحصر به
    فردی دارند که سایر ثبات‌ها ندارند. درک روش‌ها و محدودیت‌های ثبات‌های
    پردازنده مانند دنبال کردن یک کنفرانس صلح جهانی است: شراکت‌ها، اتحادها، و
    همیشه مجموعه‌ای گیج‌کننده از برنامه‌های مخفی که هر ثبات دنبال می‌کند. هیچ
    سیستم کلی برای توصیف چنین چیزهایی وجود ندارد؛ مانند افعال بی‌قاعده، شما
    باید آن‌ها را به سادگی حفظ کنید.</p>
<p>اکثر تجهیزات جانبی نیز ثبات دارند، و ثبات‌های تجهیزات جانبی حتی از نظر
    دامنه محدودتر از ثبات‌های پردازنده هستند. برنامه‌های آن‌ها کاملاً صریح و به
    هیچ وجه مخفی نیستند. این مانع از گیج‌کننده بودن آن‌ها نمی‌شود، همان‌طور که
    هرکسی که سعی کرده باشد یک کارت ویدئویی را در سطح ثبات برنامه‌نویسی کند،
    تأیید خواهد کرد. خوشبختانه، امروزه تقریباً تمام ارتباطات با دستگاه‌های
    جانبی توسط سیستم عامل مدیریت می‌شود، همان‌طور که بعداً در این کتاب توضیح
    خواهم داد.</p>
<p><strong>خط مونتاژ</strong></p>
<p>اگر پردازنده سرکارگر باشد، تجهیزات جانبی کارگران خط مونتاژ هستند، و
    گذرگاه داده خود خط مونتاژ است. (با این تفاوت که برخلاف اکثر خطوط مونتاژ،
    سرکارگر خیلی بیشتر از بقیه کارکنان کار می‌کند!)</p>
<p>به عنوان مثال، اطلاعات از طریق یک دستگاه جانبی پورت شبکه وارد
    کامپیوتر می‌شود، که بیت‌های دریافتی از یک کابل شبکه کامپیوتری را به
    بایت‌های داده‌ای که نمایانگر حروف و ارقام هستند، تبدیل می‌کند. سپس پورت
    شبکه بایت مونتاژ شده را روی گذرگاه داده قرار می‌دهد، که پردازنده از آنجا
    آن را برمی‌دارد، می‌شمارد، یا به روش‌های دیگر پردازش می‌کند، و سپس آن را به
    گذرگاه داده بازمی‌گرداند. سپس کارت نمایش بایت را از گذرگاه داده بازیابی
    می‌کند و آن را در حافظه ویدئویی می‌نویسد تا بتوانید آن را روی صفحه نمایش
    خود ببینید.</p>
<p>این توصیفی به‌شدت ساده‌شده است، اما آشکارا، چیزهای زیادی در داخل جعبه
    در حال رخ دادن است. ارتباطات پیوسته و پرشور در امتداد گذرگاه داده بین
    پردازنده، حافظه و تجهیزات جانبی همان چیزی است که کارهایی را که کامپیوتر
    انجام می‌دهد، محقق می‌سازد. سپس این سؤال پیش می‌آید: چه کسی به سرکارگر و
    کارکنان می‌گوید چه کاری انجام دهند؟ شما این کار را می‌کنید. چگونه این کار
    را می‌کنید؟ شما یک برنامه می‌نویسید. برنامه کجاست؟ در حافظه است، همراه با
    تمام داده‌های دیگری که در حافظه ذخیره شده‌اند. در واقع، برنامه داده است، و
    این همان قلب تمام ایده برنامه‌نویسی است که ما می‌شناسیم.</p>
<p><strong>جعبه‌ای که از یک طرح پیروی می‌کند</strong></p>
<p>سرانجام، به جوهره محاسبات می‌رسیم: ماهیت برنامه‌ها و اینکه چگونه آن‌ها
    پردازنده را هدایت می‌کنند تا کامپیوتر را کنترل کند و کار شما را انجام
    دهد.</p>
<p>دیدیم که چگونه می‌توان از حافظه برای ذخیره بایت‌های اطلاعات استفاده
    کرد. این بایت‌ها همه کدهای دودویی هستند، الگوهایی از بیت‌های ۱ و ۰ که به
    صورت سطوح ولتاژ الکتریکی بسیار کوچک ذخیره می‌شوند و در مجموع اعداد دودویی
    را تشکیل می‌دهند. همچنین درباره نمادها صحبت کردیم و اینکه چگونه برخی
    کدهای دودویی ممکن است به‌عنوان معنایی برای ما انسان‌ها تفسیر شوند، چیزهایی
    مانند حروف، ارقام، علائم نگارشی و غیره.</p>
<p>همان‌طور که حروف الفبا و ارقام عددی مجموعه‌ای از کدها و نمادها را نشان
    می‌دهند که برای ما انسان‌ها معنایی دارند، مجموعه‌ای از کدها وجود دارد که
    برای پردازنده معنایی دارند. این کدها “دستورات ماشین” نامیده می‌شوند، و
    نام آن‌ها یادآور آن چیزی است که در واقع هستند: دستورات به پردازنده. وقتی
    پردازنده در حال اجرای یک برنامه است، یک دنباله از اعداد را از گذرگاه
    داده برمی‌دارد، یکی در یک زمان. هر عدد به پردازنده می‌گوید کاری انجام دهد.
    پردازنده می‌داند چگونه. وقتی اجرای یک دستور را تمام می‌کند، دستور بعدی را
    برمی‌دارد و آن را اجرا می‌کند. این کار را ادامه می‌دهد تا زمانی که چیزی (یک
    فرمان در برنامه، یا سیگنال الکتریکی مانند دکمه تنظیم مجدد) به آن بگوید
    که متوقف شود.</p>
<p>بیایید یک یا دو مثال از تراشه‌های پردازنده ۳۲ بیتی قدیمی‌تر اینتل
    بیاوریم. (من از آن‌ها به‌عنوان مثال در اینجا استفاده می‌کنم، زیرا نکته این
    است که یک دستور ماشین عددی است که به‌عنوان یک فرمان به پردازنده عمل
    می‌کند. دستورات ماشین خاص در این بحث خاص مهم نیستند.)</p>
<p>کد دودویی ۸ بیتی 01000000 (40H) برای پردازنده معنایی دارد. این یک
    دستور است: ۱ را به ثبات AX اضافه کن و مجموع را دوباره در AX قرار بده.
    این تقریباً به سادگی ممکن است. بیشتر دستورات ماشین بیش از یک بایت را
    اشغال می‌کنند. بسیاری دو بایت طول دارند، و تعداد قابل توجهی چهار بایت طول
    دارند. در واقع، طولانی‌ترین آن‌ها ۱۵ بایت طول دارند. کدهای دودویی 11010110
    01110011 (0D6H 073H) دستور دیگری را تشکیل می‌دهند: مقدار 73H را در ثبات
    DH بارگذاری کن. در سوی دیگر طیف، کدهای دودویی 11110011 10100100 (0F3H
    0A4H) پردازنده را به انجام کار زیر هدایت می‌کنند (نفس عمیق بکشید): شروع
    به انتقال تعداد بایت‌های مشخص شده در ثبات CX از آدرس ۳۲ بیتی ذخیره شده در
    ثبات‌های DS و SI به آدرس ۳۲ بیتی ذخیره شده در ثبات‌های ES و DI کن، آدرس را
    در هر دو SI و DI پس از انتقال هر بایت به‌روزرسانی کن، و همچنین در هر بار
    CX را یک واحد کاهش بده، و در نهایت وقتی CX به صفر رسید متوقف شو.</p>
<p>در فصل‌های بعدی به جزئیات دستورات ماشین بازخواهم گشت، زمانی که به
    نوشتن کد اسمبلی واقعی x64 می‌پردازیم. نکته در اینجا این است که دستورات
    ماشین اعدادی (یا توالی‌های کوتاه از اعداد) هستند که پردازنده آن‌ها را
    به‌عنوان فرمان‌هایی برای انجام کاری درک می‌کند. دستورات وجود دارند که
    عملیات حسابی (جمع، تفریق، ضرب و تقسیم) و عملیات منطقی (AND، OR، XOR، و
    غیره) را انجام می‌دهند، و دستورات که اطلاعات را در حافظه جابجا می‌کنند.
    برخی دستورات به “هدایت” مسیر اجرای برنامه در منطق برنامه در حال اجرا
    خدمت می‌کنند. برخی دستورات دارای عملکردهای بسیار پیچیده‌ای هستند و خارج از
    درونیات سیستم عامل خیلی به چشم نمی‌آیند. نکته مهمی که در حال حاضر باید به
    یاد داشته باشید این است که هر دستور به پردازنده می‌گوید یک کار عموماً کوچک
    و محدود را انجام دهد. بسیاری از دستورات که به ترتیب به پردازنده داده
    می‌شوند، پردازنده را هدایت می‌کنند تا وظایف بسیار پیچیده‌تری را انجام دهد.
    نوشتن آن توالی از دستورات همان چیزی است که برنامه‌نویسی زبان اسمبلی واقعاً
    هست.</p>
<p>بیایید بیشتر در مورد آن صحبت کنیم.</p>
<p><strong>بازیابی و اجرا</strong></p>
<p>یک برنامه کامپیوتری چیزی نیست جز یک توالی از این دستورات ماشین که در
    حافظه ذخیره شده‌اند. هیچ چیز خاصی در مورد این توالی وجود ندارد، و نه در
    مورد جایی که در حافظه قرار گرفته است. می‌تواند تقریباً هر جایی باشد، و
    بایت‌های موجود در توالی چیزی نیستند جز اعداد دودویی.</p>
<p>اعداد دودویی تشکیل‌دهنده یک برنامه کامپیوتری تنها در روشی که پردازنده
    با آن‌ها برخورد می‌کند، خاص هستند. هنگامی که یک پردازنده ۶۴ بیتی مدرن شروع
    به اجرای یک برنامه می‌کند، با بازیابی بایت‌ها (نه کلمات، دابل‌وردها، یا
    کواد‌وردها) از یک آدرس توافق‌شده در حافظه شروع می‌کند. (چگونگی توافق بر سر
    این آدرس شروع یک مسئله سیستم عامل است و در حال حاضر مهم نیست.) این
    بایت‌های اولیه شروع یک جریان از دستورات هستند که از حافظه برای اجرا وارد
    می‌شوند. این جریان در یک سیستم حافظه ویژه درون پردازنده به نام “کش
    دستورالعمل” (instruction cache) بارگذاری می‌شود، که پردازنده می‌تواند به
    سرعت به آن دسترسی داشته باشد. همان‌طور که پردازنده دستورات موجود در کش را
    پردازش می‌کند، دستورات بیشتری به‌طور خودکار از حافظه بارگذاری می‌شوند تا کش
    را همیشه پر (یا نزدیک به پر) نگه دارند.</p>
<p>نکته مهمی که باید در اینجا به خاطر داشته باشید این است که همه دستورات
    ماشین طول یکسانی ندارند. در x64، یک دستور می‌تواند از ۱ تا ۱۵ بایت طول
    داشته باشد. پردازنده جریان ورودی بایت‌های دستورالعمل ماشین در کش را بررسی
    می‌کند تا تعیین کند هر دستور از کجا شروع و کجا پایان می‌یابد. وقتی
    پردازنده یک دستور را در جریان تشخیص می‌دهد، آن دستور را اجرا می‌کند و سپس
    به بررسی جریان برای شناسایی دستور بعدی ادامه می‌دهد.</p>
<p>در داخل پردازنده یک ثبات ویژه به نام “اشاره‌گر دستورالعمل”
    (instruction pointer) وجود دارد که به معنای واقعی کلمه حاوی آدرس دستور
    بعدی برای اجرا است. در پردازنده‌های x64، اشاره‌گر دستورالعمل “RIP” نامیده
    می‌شود. هر بار که یک دستور اجرا می‌شود، اشاره‌گر دستورالعمل به‌روزرسانی
    می‌شود تا به دستور بعدی در حافظه اشاره کند. در داخل پردازنده‌های مدرن یک
    جادوی سیلیکونی در جریان است که “حدس می‌زند” چه چیزی باید بعداً بازیابی شود
    و آن را در یک قفسه جانبی نگه می‌دارد تا وقتی که بازیابی می‌شود، فقط بسیار
    سریع‌تر در دسترس باشد—اما فرآیندی که توضیح دادم از نظر نتیجه درست
    است.</p>
<p>همه این کارها به معنای واقعی کلمه مانند ساعت‌کاری انجام می‌شود.
    کامپیوتر یک زیرسیستم الکتریکی به نام “ساعت سیستم” دارد، که در واقع یک
    نوسان‌ساز است که پالس‌های موج مربعی را در فواصل بسیار دقیق منتشر می‌کند.
    تعداد زیادی از کلیدهای ترانزیستوری میکروسکوپی داخل پردازنده، اقدامات خود
    را بر اساس پالس‌های تولید شده توسط ساعت سیستم هماهنگ می‌کنند. در سال‌های
    گذشته، اغلب چندین چرخه ساعت (اساساً پالس‌های ساعت) طول می‌کشید تا یک دستور
    واحد اجرا شود. با سریع‌تر شدن کامپیوترها و پیچیده‌تر شدن طراحی داخلی آن‌ها،
    اکثر دستورات ماشین در یک چرخه ساعت اجرا می‌شوند. پردازنده‌های مدرن
    می‌توانند دستورات را به‌صورت موازی اجرا کنند، بنابراین چندین دستور اغلب
    می‌توانند در یک چرخه ساعت اجرا شوند.</p>
<p>بنابراین فرآیند این‌گونه است: بازیابی و اجرا؛ بازیابی و اجرا. پردازنده
    مسیر خود را در حافظه طی می‌کند، با ثبات اشاره‌گر دستورالعمل که راه را
    هدایت می‌کند. همان‌طور که پیش می‌رود، کار می‌کند: داده‌ها را در حافظه جابجا
    می‌کند، مقادیر را در ثبات‌ها جابجا می‌کند، داده‌ها را به تجهیزات جانبی
    می‌فرستد، داده‌ها را در عملیات حسابی یا منطقی پردازش می‌کند.</p>
<p>برنامه‌های کامپیوتری فهرستی از دستورات ماشین دودویی ذخیره‌شده در حافظه
    هستند. آن‌ها هیچ تفاوتی با هر فهرست دیگری از بایت‌های داده ذخیره‌شده در
    حافظه ندارند، جز در نحوه تفسیر آن‌ها هنگام بازیابی توسط پردازنده.</p>
<p><strong>داخل و درون سرکارگر</strong></p>
<p>قبلاً اشاره کردم که دستورات ماشین کدهای دودویی هستند. این چیزی است که
    ما اغلب از آن عبور می‌کنیم، اما برای درک ماهیت واقعی پردازنده، باید از
    تصویر مداوم دستورات ماشین به‌عنوان اعداد فاصله بگیریم. آن‌ها اعداد نیستند.
    آن‌ها الگوهای دودویی هستند که برای فعال کردن کلیدهای الکتریکی طراحی
    شده‌اند. ما به آن‌ها به‌عنوان اعداد اشاره می‌کنیم تا مجبور نباشیم یاد بگیریم
    با توالی‌های (بزرگ) از یک‌ها و صفرها سر و کار داشته باشیم. 01010001 یا
    51H؟ شما بگویید.</p>
<p>در داخل پردازنده تعداد بسیار زیادی ترانزیستور وجود دارد. پردازنده
    Intel Core i5 Quad که روی میز من است حاوی ۵۸۲ میلیون ترانزیستور است، و
    تراشه‌های پردازنده با بیش از یک میلیارد ترانزیستور اکنون متداول هستند.
    پردازنده ۱۰ هسته‌ای i7 Broadwell E که در سال ۲۰۱۶ معرفی شد، ۳.۳ میلیارد
    ترانزیستور دارد. از آن زمان فقط افزایش یافته است.</p>
<p>یک نکته فرعی سریع: چرا من هنوز از یک ماشین ۱۰ ساله با ۵۸۲ میلیون
    ترانزیستور ناچیز استفاده می‌کنم؟ چون تمام کاری که نیاز دارم را انجام
    می‌دهد، و خنک کار می‌کند. خنک بودن مهم است. تمام چیزی که نیاز ندارم این
    است که در تابستان فینیکس وقتی بیرون ۱۱۸ درجه است، یک جعبه پر از فن داشته
    باشم که گرما را به دفترم پمپاژ می‌کنند تا من به شرکت برق پول بدهم تا
    دوباره آن را بیرون پمپاژ کند. اگر من یک توسعه‌دهنده بازی‌های ویدئویی یا
    دانشمندی بودم که مدل‌های کامپیوتری قابل توجهی را اجرا می‌کند، خوب، یک
    پردازنده با تمام ترانزیستورهایی که می‌توانستم بخرم تهیه می‌کردم و
    صورتحساب‌های برق را به‌عنوان هزینه کسب‌وکار در نظر می‌گرفتم. آنچه نیاز دارید
    بستگی به کاری دارد که انجام می‌دهید. توان کامپیوتری با هزینه‌ای در هر دو
    دلار و گرما همراه است.</p>
<p>تعدادی از همه آن ترانزیستورها صرف ساخت جیب‌های سرکارگر می‌شوند: ثبات‌های
    ماشین برای نگه‌داری اطلاعات. در معماری x64، این ثبات‌ها همگی ۶۴ بیت (۸
    بایت) اندازه دارند. تعداد قابل توجهی از ترانزیستورها برای ساخت حافظه
    کوتاه‌مدتی به نام “کش” صرف می‌شوند که بعداً آن را توضیح خواهم داد. (فعلاً،
    کش را به‌عنوان یک مجموعه کوچک از قفسه‌های ذخیره‌سازی در نظر بگیرید که همیشه
    درست کنار دست سرکارگر هستند، و او را از عبور از اتاق برای دریافت مواد
    بیشتر بی‌نیاز می‌کند.) با این حال، اکثریت عظیمی از ترانزیستورهای پردازنده،
    کلیدهایی هستند که به کلیدهای دیگر متصل‌اند، که آن‌ها نیز به کلیدهای بیشتری
    در یک شبکه با پیچیدگی گیج‌کننده متصل‌اند.</p>
<p>این یکی از مواردی است که یک مثال “نمای از ارتفاع” ضروری است. دستور
    ماشین بسیار ساده یک بایتی 01010001 (51H) پردازنده را هدایت می‌کند تا
    مقدار ذخیره‌شده در ثبات ۶۴ بیتی RCX را روی پشته قرار دهد. پردازنده این را
    به دو مرحله جداگانه تقسیم می‌کند. اول، پردازنده ۸ را از مقدار موجود در
    ثبات اشاره‌گر پشته (RSP) کم می‌کند تا برای ثبات ۶۴ بیتی روی پشته جا باز
    کند. سپس، مقدار موجود در RCX به موقعیت حافظه‌ای که اکنون توسط ثبات
    اشاره‌گر پشته ارجاع داده می‌شود، کپی می‌شود. سپس کار تمام است، و پردازنده
    آماده است تا به دستور بعدی برود. شما به زودی خواهید دید که چگونه دستورات
    فردی توسط پردازنده به‌عنوان توالی از یک یا چند گام ریزدانه تفسیر می‌شوند.
    فکر کردن به اجرای دستور ماشین 01010001 به این روش بسیار آموزنده از ماهیت
    واقعی کامپیوترها است.</p>
<p>توضیح دقیق اینکه همه این‌ها چگونه از نظر الکتریکی اتفاق می‌افتد بسیار
    دشوار است، اما باید به یاد داشته باشید که هر عددی که داخل پردازنده ذخیره
    شده است را می‌توان به‌عنوان یک کد دودویی در نظر گرفت، از جمله مقادیر
    ذخیره‌شده در ثبات‌ها. همچنین، اکثر کلیدهای داخل پردازنده بیش از یک دستگیره
    دارند. این کلیدها “گیت” نامیده می‌شوند و بر اساس قوانین منطق کار می‌کنند.
    شاید دو، سه، یا حتی بیشتر کلید “بالا” باید هم‌زمان به یک گیت خاص برسند تا
    یک کلید “پایین” بتواند از آن گیت عبور کند.</p>
<p>این گیت‌ها برای ساخت ماشین‌آلات داخلی پیچیده در داخل پردازنده استفاده
    می‌شوند. مجموعه‌ای از گیت‌ها می‌توانند دو عدد را در دستگاهی به نام جمع‌کننده
    (adder) اضافه کنند، که باز هم چیزی نیست جز گروهی از صدها کلید کوچک که
    ابتدا به‌عنوان گیت‌ها و سپس به‌عنوان گیت‌هایی که با هم کار می‌کنند تا یک
    جمع‌کننده را تشکیل دهند، کار می‌کنند. مکانیسم‌های دیگری نیز در داخل
    پردازنده وجود دارند، که همه آن‌ها از کلیدها و گیت‌های ترانزیستوری ساخته
    شده‌اند.</p>
<p>بنابراین، سرکارگر کامپیوتر شما از کلیدها ساخته شده است—درست مانند همه
    قسمت‌های دیگر کامپیوتر. حاوی تعداد سرسام‌آوری از چنین کلیدهایی است که به
    روش‌هایی حتی سرسام‌آورتر به هم متصل شده‌اند. اما نکته مهم این است که، چه
    گیج شوید یا (مثل من، در روزهای کم‌کاری) صرفاً بی‌حوصله باشید، پردازنده، و
    در نهایت کامپیوتر، دقیقاً همان کاری را انجام می‌دهد که ما به آن می‌گوییم.
    ما یک فهرست از دستورات ماشین را به‌عنوان یک جدول در حافظه تنظیم می‌کنیم، و
    سپس، به لطف آن، آن آجر سیلیکونی گنگ جان می‌گیرد و شروع به کسب درآمد
    می‌کند.</p>
<p><strong>تغییر مسیر</strong></p>
<p>اولین قطعه جادوی واقعی در ماهیت کامپیوترها این است که یک رشته از
    کدهای دودویی در حافظه به کامپیوتر می‌گوید چه کاری انجام دهد، گام به گام.
    دومین قطعه از آن جادو در واقع نگین تاج است: دستورات ماشین وجود دارند که
    ترتیب بازیابی و اجرای دستورات ماشین را تغییر می‌دهند.</p>
<p>به عبارت دیگر، وقتی پردازنده یک دستور ماشین را اجرا کرده که کاری مفید
    انجام می‌دهد، دستور ماشین بعدی ممکن است به پردازنده بگوید که برگردد و
    دوباره آن را اجرا کند—و دوباره، و دوباره، به تعداد دفعاتی که لازم است.
    پردازنده می‌تواند تعداد دفعاتی را که آن دستور یا فهرست دستورالعمل خاص را
    اجرا کرده است بشمارد و آن‌ها را تکرار کند تا زمانی که یک شمارش از پیش
    تعیین‌شده برآورده شود.</p>
<p>یا می‌تواند ترتیب دهد تا به‌طور کامل از برخی توالی‌های دستورات ماشین
    صرف‌نظر کند، اگر اصلاً نیازی به اجرای آن‌ها نیست.</p>
<p>این بدان معنی است که فهرست دستورات ماشین در حافظه لزوماً از بالا شروع
    نمی‌شود و بدون انحراف به پایین ادامه نمی‌یابد. پردازنده می‌تواند اولین ۵۰
    یا ۱۰۰ یا ۱۰۰۰ دستور را اجرا کند و سپس به انتهای برنامه بپرد—یا به ابتدا
    برگردد و دوباره شروع کند. می‌تواند مانند سنگی که روی یک برکه آرام پرتاب
    شده است، بالا و پایین فهرست را بپرد. می‌تواند چند دستور را اینجا اجرا
    کند، سپس به جای دیگری برود و چند دستور دیگر را اجرا کند، و سپس بازگردد و
    از جایی که متوقف شده بود ادامه دهد، بدون از دست دادن یک ضربان یا حتی هدر
    دادن زمان زیاد.</p>
<p>این چگونه انجام می‌شود؟ به یاد داشته باشید که پردازنده شامل یک ثبات
    ویژه است که همیشه حاوی آدرس دستور بعدی برای اجرا است. این ثبات، اشاره‌گر
    دستورالعمل، اساساً با هیچ یک از ثبات‌های دیگر در پردازنده تفاوتی ندارد.
    همان‌طور که یک دستور ماشین می‌تواند یک واحد به ثبات RCX اضافه کند، دستور
    ماشین دیگری می‌تواند مقداری را به آدرس ذخیره‌شده در اشاره‌گر دستورالعمل
    اضافه یا از آن کم کند. اگر ۱۰۰ (اعشاری) به اشاره‌گر دستورالعمل اضافه
    کنید، پردازنده بلافاصله ۱۰۰ بایت در فهرست دستورات ماشین به پایین می‌پرد
    قبل از اینکه ادامه دهد. اگر ۱۰۰ را از آدرس ذخیره‌شده در اشاره‌گر
    دستورالعمل کم کنید، پردازنده بلافاصله ۱۰۰ بایت در فهرست دستورات ماشین به
    بالا می‌پرد.</p>
<p>در نهایت، سومین ضربه: پردازنده می‌تواند مسیر اجرای خود را بر اساس کاری
    که انجام داده است تغییر دهد. پردازنده می‌تواند تصمیم بگیرد که آیا یک
    دستور یا گروهی از دستورات را اجرا کند یا نه، بر اساس مقادیر ذخیره‌شده در
    حافظه، یا بر اساس حالت فردی چند ثبات ویژه یک‌بیتی پردازنده به نام “فلگ”
    (پرچم). پردازنده می‌تواند بشمارد که چند بار نیاز دارد کاری را انجام دهد و
    سپس آن کار را آن تعداد دفعات انجام دهد. یا می‌تواند کاری را انجام دهد و
    سپس دوباره، و دوباره، و دوباره آن را انجام دهد، هر بار بررسی کند (با
    نگاه کردن به برخی داده‌ها در جایی) که آیا تمام شده است یا نیاز دارد یک
    بار دیگر از طریق وظیفه عبور کند.</p>
<p>بنابراین، نه تنها می‌توانید به پردازنده بگویید چه کاری انجام دهد،
    می‌توانید به آن بگویید به کجا برود. بهتر از آن، گاهی می‌توانید به پردازنده
    اجازه دهید، مانند یک سگ شکاری وفادار، بهترین مسیر پیش رو را برای انجام
    کار به سریع‌ترین روش ممکن کشف کند.</p>
<p>در فصل ۱، درباره یک برنامه کامپیوتری به‌عنوان یک توالی از گام‌ها و
    آزمون‌ها صحبت کردم. بیشتر دستورات ماشین که توسط پردازنده درک می‌شوند گام‌ها
    هستند، اما برخی دیگر آزمون هستند. آزمون‌ها همیشه دوطرفه هستند، و در واقع
    انتخاب کاری که باید انجام شود همیشه یکسان است: بپر یا نپر. همین. شما
    می‌توانید برای هر یک از شرایط مختلف درون پردازنده آزمون کنید، اما انتخاب
    همیشه یکی از پریدن به جای دیگری در برنامه یا ادامه مسیر است.</p>
<p><strong>چه چیزی در مقابل چگونه: معماری و ریزمعماری</strong></p>
<p>این کتاب واقعاً درباره برنامه‌نویسی به زبان اسمبلی برای پردازنده‌های ۶۴
    بیتی اینتل و همچنین آن دسته از پردازنده‌هایی است که توسط شرکت‌های دیگر
    ساخته شده‌اند تا با پردازنده‌های اینتل سازگار باشند. انواع مختلفی از
    تراشه‌های پردازنده خانواده x86 اینتل و سازگار با اینتل وجود دارند. یک
    فهرست کامل شامل 8086، 8088، 80186، 80286، 80386، 80486، سلرون، پنتیوم،
    پنتیوم پرو، پنتیوم MMX، پنتیوم II، پنتیوم D، پنتیوم III، پنتیوم 4،
    پنتیوم زئون، زئون، کور، اثلون، و واقعاً ده‌ها مورد دیگر در خانواده‌هایی با
    نام‌هایی مانند هزول (Haswell) و کافی لیک (Coffee Lake) می‌شود. علاوه بر
    این، آن‌ها تنها تراشه‌های پردازنده‌ای هستند که توسط اینتل طراحی و فروخته
    شده‌اند. شرکت‌های دیگر (عمدتاً AMD) تراشه‌های پردازنده سازگار با اینتل خود
    را طراحی کرده‌اند، که ده‌ها مورد دیگر به فهرست کامل اضافه می‌کند. و در داخل
    یک نوع پردازنده واحد، اغلب سه یا چهار نوع دیگر وجود دارد، با نام‌های عجیب
    و غریب مانند کپرماین (Coppermine)، کت‌مای (Katmai)، کانرو (Conroe)، هزول،
    کافی لیک، و غیره.</p>
<p>چگونه کسی همه این موارد را پیگیری می‌کند؟</p>
<p>پاسخ کوتاه: واقعاً هیچ‌کس این کار را نمی‌کند. چرا؟ زیرا در تقریباً تمام
    موارد، حجم عظیمی از جزئیات مهم نیستند. روح یک CPU به‌طور نسبتاً پاکیزه‌ای
    به دو بخش تقسیم می‌شود: آنچه CPU انجام می‌دهد و چگونه CPU آن را انجام
    می‌دهد. ما به‌عنوان برنامه‌نویس‌ها آن را از بیرون می‌بینیم: آنچه CPU انجام
    می‌دهد. مهندسین الکترونیک و طراحان سیستمی که مادربوردهای کامپیوتر و سایر
    سیستم‌های سخت‌افزاری را که پردازنده‌های اینتل را در خود جای می‌دهند ایجاد
    می‌کنند، نیاز دارند تا بخشی از بقیه را بدانند، اما آن‌ها یک گروه کوچک و
    مقاوم هستند و می‌دانند که چه کسانی هستند.</p>
<p>معماری‌های در حال تکامل</p>
<p>دید ما به‌عنوان برنامه‌نویس از بیرون شامل رجیسترهای CPU، مجموعه
    دستورالعمل‌های ماشینی که CPU می‌فهمد، و زیرسیستم‌های خاص مانند پردازنده‌های
    ریاضی سریع است که عموماً شامل دستورالعمل‌های ماشینی و رجیسترهای خودشان
    هستند. تمام این موارد به‌طور مفصل توسط اینتل تعریف شده‌اند و به‌صورت آنلاین
    و در کتاب‌های بزرگ منتشر شده‌اند تا برنامه‌نویسان بتوانند آن‌ها را مطالعه و
    درک کنند. این تعاریف در مجموع به‌عنوان معماری CPU شناخته می‌شوند.</p>
<p>یک معماری CPU با گذشت زمان تکامل می‌یابد، زیرا فروشندگان دستورالعمل‌ها،
    رجیسترها و ویژگی‌های جدیدی را به خط تولید اضافه می‌کنند. ایده‌آل این است که
    این کار با نگاه به سازگاری به عقب انجام شود، به این معنی که ویژگی‌های
    جدید عموماً جایگزین، غیرفعال یا اثرات ظاهری ویژگی‌های قدیمی‌تر را تغییر
    نمی‌دهند. اینتل در خط تولید اصلی x86 خود که در سال 1978 با CPU 8086 آغاز
    شد، در زمینه سازگاری به عقب بسیار خوب عمل کرده است. در محدودیت‌های معینی،
    حتی برنامه‌هایی که برای 8086 باستانی نوشته شده‌اند، بر روی CPU مدرن 64
    بیتی Core i5 Quad روی میز من اجرا می‌شوند. هرگونه ناسازگاری که به وجود
    می‌آید بیشتر مربوط به سیستم‌عامل‌های مختلف است تا جزئیات خود CPUها.</p>
<p>البته عکس آن صادق نیست. دستورالعمل‌های ماشینی جدید به‌تدریج در طول
    سال‌ها به خط تولید اینتل نفوذ می‌کنند. یک دستورالعمل ماشینی که اولین بار
    در سال 1996 معرفی شده است، توسط یک CPU طراحی‌شده در سال 1993 شناخته
    نمی‌شود. اما یک دستورالعمل ماشینی که اولین بار در سال 1993 معرفی شده است،
    تقریباً همیشه در CPUهای جدیدتر وجود دارد و به‌طور یکسان عمل می‌کند.</p>
<p>علاوه بر افزودن دوره‌ای به مجموعه دستورالعمل‌ها، معماری‌ها گاهی جهش‌های
    کوانتومی می‌کنند. چنین جهش‌های کوانتومی معمولاً شامل تغییری در “عرض” CPU
    است. در سال 1986، معماری 16 بیتی اینتل با معرفی CPU 80386 به 32 بیت
    گسترش یافت که دستورالعمل‌ها و حالت‌های عملیاتی متعددی را اضافه کرد و عرض
    رجیسترهای CPU را دو برابر کرد. در سال 2003، معماری اصلی اینتل بار دیگر
    گسترش یافت، این بار به 64 بیت، با دستورالعمل‌های جدید، حالت‌های عملیاتی و
    رجیسترهای گسترش‌یافته. با این حال، CPUهایی که به معماری گسترش‌یافته 64
    بیتی پایبند هستند، همچنان نرم‌افزاری را که برای معماری قدیمی‌تر 32 بیتی
    نوشته شده است اجرا می‌کنند.</p>
<p>معماری 32 بیتی اینتل IA-32 (معماری اینتل 32 بیتی) نامیده می‌شود.
    معماری جدیدتر 64 بیتی به دلایل خاصی که اصلی‌ترین آن این است که اینتل آن
    را ابداع نکرده است، x64 نامیده می‌شود. رقیب اصلی اینتل، AMD، یک معماری 64
    بیتی x86 سازگار به عقب را در اوایل دهه 2000 ایجاد کرد و آنقدر خوب انجام
    شد که اینتل مجبور شد غرورش را فرو ببرد و آن را بپذیرد. غرور زیادی برای
    فرو خوردن وجود داشت: معماری 64 بیتی خود اینتل، به نام IA-64 Itanium، به
    دلایل فنی که فراتر از توضیح من در این کتاب است، به‌طور گسترده‌ای توسط
    بازار رد شد.</p>
<p>با وجود تنها اشکالات جزئی، معماری 64 بیتی جدیدتر اینتل شامل معماری
    IA-32 است که به نوبه خود شامل معماری x86 16 بیتی قدیمی‌تر است. دانستن
    اینکه کدام CPUها چه دستورالعمل‌هایی را به معماری اضافه کرده‌اند مفید است،
    با در نظر گرفتن این نکته که وقتی از یک دستورالعمل “جدید” استفاده می‌کنید،
    کد شما بر روی تراشه‌های CPU ساخته‌شده قبل از ظهور آن دستورالعمل جدید اجرا
    نمی‌شود.</p>
<p>ماشین‌آلات مخفی در زیرزمین</p>
<p>به دلیل مسئله سازگاری به عقب، طراحان CPU بدون دلیل بسیار خوب
    دستورالعمل‌ها یا رجیسترهای جدیدی را به یک معماری اضافه نمی‌کنند. راه‌های
    بهتر دیگری برای بهبود یک خانواده از CPUها وجود دارد. مهم‌ترین آن‌ها افزایش
    توان عملیاتی پردازنده است که افزایش ساده نرخ کلاک CPU نیست. دیگری کاهش
    مصرف انرژی است. این حتی بیشتر یک مسئله “سبز” نیست. همان‌طور که قبلاً اشاره
    کردم، مقدار معینی از توان مصرفی توسط CPU به‌عنوان گرما هدر می‌رود و گرمای
    هدررفته، اگر به حداقل نرسد، می‌تواند یک تراشه CPU را بپزد و به اجزای
    اطراف آسیب برساند. همچنین باعث جعبه‌های پر از فن‌های پر سر و صدا و قبوض
    بالاتر آب و برق می‌شود. بنابراین طراحان همیشه به دنبال راه‌هایی برای کاهش
    توان مورد نیاز برای انجام همان وظایف هستند.</p>
<p>افزایش توان عملیاتی پردازنده به معنای افزایش تعداد دستورالعمل‌هایی است
    که CPU در طول زمان اجرا می‌کند. ترفندهای پیچیده زیادی با نام‌هایی مانند
    پیش‌واکشی، حافظه پنهان L1، L2 و L3، پیش‌بینی شاخه، هایپر-پایپلاینینگ،
    فیوژن ماکرو-عملیات و بسیاری دیگر با افزایش توان عملیاتی مرتبط هستند.
    برخی از این تکنیک‌ها برای کاهش یا حذف گلوگاه‌ها در داخل CPU ایجاد شده‌اند
    تا CPU و سیستم حافظه تقریباً همیشه مشغول بمانند. تکنیک‌های دیگر توانایی
    CPU را برای پردازش چندین دستورالعمل به‌طور همزمان افزایش می‌دهند.</p>
<p>در مجموع، تمام مکانیزم‌های الکتریکی مرموزی که توسط آن‌ها CPU آنچه را که
    دستورالعمل‌هایش به آن می‌گویند انجام می‌دهد، ریزمعماری CPU نامیده می‌شود.
    این ماشین‌آلات مخفی در زیرزمین است که شما نمی‌توانید آن را ببینید. استعاره
    سرکارگر در اینجا کمی خراب می‌شود. اجازه دهید استعاره دیگری به شما ارائه
    دهم.</p>
<p>فرض کنید شما صاحب شرکتی هستید که قطعات جعبه‌دنده اتوماتیک برای فورد
    تولید می‌کند. شما دو کارخانه جداگانه دارید. یکی 40 سال قدمت دارد و دیگری
    به‌تازگی ساخته شده است. هر دو کارخانه دقیقاً همان قطعات را تولید
    می‌کنند—باید هم این‌گونه باشد زیرا فورد آن‌ها را در جعبه‌دنده‌های خود قرار
    می‌دهد بدون اینکه بداند یا اهمیت بدهد که کدام یک از دو کارخانه شما آن‌ها
    را تولید کرده است. یک بادامک یا یک محفظه بنابراین در حدود 10/1000 اینچ
    یکسان هستند، چه در کارخانه قدیمی شما ساخته شده باشند و چه در کارخانه
    جدید.</p>
<p>کارخانه قدیمی شما مدتی است که وجود دارد. کارخانه جدید شما بر اساس همه
    چیزهایی که در حین کار کارخانه قدیمی در این 40 سال آموخته‌اید، طراحی و
    ساخته شده است. این کارخانه دارای چیدمان منطقی‌تر، نورپردازی بهتر و
    ابزارهای خودکار مدرنی است که به افراد کمتری برای کار نیاز دارد و مدت
    طولانی‌تری بدون تنظیم کار می‌کند.</p>
<p>نتیجه این است که کارخانه جدید شما می‌تواند آن بادامک‌ها و محفظه‌ها را
    بسیار سریع‌تر و کارآمدتر تولید کند، با هدر رفتن کمتر انرژی و مواد خام و
    نیاز به افراد کمتر برای انجام آن. روزی خواهد رسید که شما یک کارخانه سوم
    حتی کارآمدتر بر اساس آنچه در حال اجرای کارخانه دوم آموخته‌اید خواهید ساخت
    و کارخانه اول را تعطیل خواهید کرد.</p>
<p>با این حال، بادامک‌ها و محفظه‌ها یکسان هستند، مهم نیست که کجا ساخته
    شده‌اند. چگونگی ساخته شدن آن‌ها هیچ ربطی به فورد یا هیچ‌کس دیگری ندارد. تا
    زمانی که بادامک‌ها از همان مواد و با همان مشخصات و تحمل‌های ابعادی ساخته
    شوند، “چگونگی” مهم نیست.</p>
<p>تمام ابزارها، چیدمان خط تولید و ساختار کلی هر کارخانه را می‌توان
    به‌عنوان ریزمعماری آن کارخانه در نظر گرفت. هر بار که کارخانه جدیدی
    می‌سازید، ریزمعماری کارخانه جدید در انجام همان کارهایی که کارخانه‌های
    قدیمی انجام می‌دادند کارآمدتر است.</p>
<p>پس CPUها نیز همین‌طور هستند. اینتل و AMD به‌طور مداوم ریزمعماری CPUهای
    خود را بازطراحی می‌کنند تا آن‌ها را کارآمدتر کنند. این تلاش‌ها توسط
    تکنیک‌های بهبود یافته ساخت سیلیکون هدایت می‌شود که اجازه می‌دهد
    ترانزیستورهای بیشتری بر روی یک دای CPU قرار گیرند. ترانزیستورهای بیشتر
    به معنای سوئیچ‌های بیشتر و راه‌حل‌های بالقوه بیشتر برای همان مشکلات قدیمی
    توان عملیاتی و بهره‌وری انرژی است.</p>
<p>دستور اصلی در بهبود ریزمعماری‌ها، البته، این است که از “شکستن”
    برنامه‌های موجود با تغییر نحوه عمل دستورالعمل‌های ماشینی یا رجیسترها
    جلوگیری شود. به همین دلیل است که ماشین‌آلات مخفی در زیرزمین هستند. طراحان
    CPU تلاش زیادی می‌کنند تا یک خط بسیار روشن بین آنچه CPU انجام می‌دهد و
    چگونگی انجام آن وظایف در جنگل آن میلیاردها ترانزیستور نگه دارند.</p>
<p>تمام نام‌های کد عجیب و غریبی مانند Conroe، Katmai، Haswell یا Coffee
    Lake در واقع نشان‌دهنده تغییرات در ریزمعماری هستند. تغییرات عمده در
    ریزمعماری نیز نام دارند: P6، Netburst، Core و غیره. این‌ها به‌طور مفصل
    آنلاین توصیف شده‌اند، اما اگر همه آن‌ها را به‌طور کامل دنبال نکنید احساس
    بدی نداشته باشید. بیشتر اوقات من هم با ناخن‌هایم آویزان هستم.</p>
<p>همه این‌ها را می‌گویم تا شما به‌عنوان یک برنامه‌نویس تازه‌کار بیش از حد از
    تفاوت‌های ریزمعماری اینتل استفاده نکنید. این یک مورد بسیار نادر است (مثلاً
    تقریباً هرگز) که تفاوت در جزئیات ریزمعماری به شما یک مزیت قابل استفاده در
    نحوه کدنویسی برنامه‌هایتان بدهد. خوب، ریزمعماری مخفی نگه داشته نمی‌شود
    (مقدار زیادی اطلاعات در مورد آن به‌صورت آنلاین در دسترس است)، اما به خاطر
    سلامت عقلتان، احتمالاً باید در حال حاضر آن را یک راز بدانید. ما در حال
    حاضر چیزهای بسیار مهم‌تری برای یادگیری داریم.</p>
<p>ورود مدیر کارخانه</p>
<p>آنچه تا کنون توصیف کرده‌ام کمتر “یک کامپیوتر” است تا “محاسبه”. یک CPU
    که یک برنامه را اجرا می‌کند کامپیوتر نمی‌سازد. دستگاه 8 بیتی COSMAC ELF که
    در سال 1976 ساختم، یک آزمایش بود و در بهترین حالت یک نوع اسباب‌بازی
    آموزشی بود.</p>
<p>ELF یک CPU با مقداری حافظه و تنها پشتیبانی الکتریکی کافی (از طریق
    سوئیچ‌ها و ارقام LED) بود که می‌توانستم دستورالعمل‌های ماشینی دودویی را
    وارد کنم و ببینم داخل رجیسترها و تراشه‌های حافظه چه می‌گذرد. من چیزهای
    زیادی از آن یاد گرفتم، اما به هیچ معنایی از کلمه مفید نبود.</p>
<p>اولین کامپیوتر مفید من چند سال بعد آمد. این دستگاه دارای یک صفحه‌کلید،
    یک نمایشگر CRT (اگرچه قادر به گرافیک نبود)، یک جفت درایو فلاپی دیسک 8
    اینچی و یک چاپگر چرخ دیزی بود. علاقه‌مندان به تکنولوژی قدیمی قدردانی
    خواهند کرد که قلب تپنده آن یک CPU 8080 با فرکانس 1 مگاهرتز بود! این
    ماشین فوق‌العاده مفید بود و من مقالات مجله‌ای بی‌شماری و سه کتاب اولم را با
    آن نوشتم. من تعدادی برنامه کاربردی ساده برای آن داشتم، مانند پردازشگر
    متن ابتدایی WordStar. اما آنچه آن را مفید می‌کرد چیز دیگری بود: یک
    سیستم‌عامل.</p>
<p>سیستم‌عامل‌ها: دفتر گوشه‌ای</p>
<p>یک سیستم‌عامل برنامه‌ای است که عملیات یک سیستم کامپیوتری را مدیریت
    می‌کند. مانند هر برنامه دیگری است به این معنا که از یک دنباله
    دستورالعمل‌های ماشینی تشکیل شده است که توسط CPU اجرا می‌شود. سیستم‌عامل‌ها
    متفاوت هستند زیرا قدرت‌های ویژه‌ای دارند که عموماً به پردازشگرهای کلمه و
    برنامه‌های صفحه‌گسترده داده نمی‌شود. اگر استعاره CPU به‌عنوان سرکارگر را
    ادامه دهیم، سیستم‌عامل مدیر کارخانه است. کل کارخانه فیزیکی تحت کنترل آن
    است. بر آوردن مواد خام به کارخانه نظارت می‌کند. بر کاری که در داخل
    کارخانه انجام می‌شود (از جمله کاری که توسط سرکارگر انجام می‌شود) نظارت
    می‌کند و محصولات نهایی را برای ارسال به مشتریان بسته‌بندی می‌کند.</p>
<p>در حقیقت، سیستم‌عامل‌های میکروکامپیوتر اولیه ما چندان قدرتمند نبودند و
    کار زیادی انجام نمی‌دادند. آن‌ها “دیسک‌ها را می‌چرخاندند” و ذخیره داده‌ها را
    روی درایوهای دیسک مدیریت می‌کردند و هنگام درخواست داده‌ها را از دیسک‌ها
    می‌آوردند. آن‌ها کلیدهای صفحه‌کلید را دریافت می‌کردند و کاراکترها را به
    نمایشگر ویدئویی می‌فرستادند. با کمی دستکاری، آن‌ها می‌توانستند کاراکترها را
    به یک چاپگر ارسال کنند. و این تقریباً تمام ماجرا بود.</p>
<p>سیستم‌عامل CP/M در سال 1979 برای میکروکامپیوترهای رومیزی “اوج
    تکنولوژی” بود. اگر نام یک برنامه را در صفحه‌کلید وارد می‌کردید، CP/M به
    دیسک می‌رفت، برنامه را از یک فایل دیسک به حافظه بارگذاری می‌کرد و سپس عملاً
    تمام قدرت ماشین را به برنامه بارگذاری‌شده تحویل می‌داد. هنگامی که WordStar
    اجرا می‌شد، پردازنده فرمان سیستم‌عامل را در حافظه بازنویسی می‌کرد زیرا
    حافظه در آن دوره بسیار گران بود و مقدار زیادی از آن وجود نداشت. هنگامی
    که WordStar خارج می‌شد، پردازنده فرمان CP/M دوباره از فلاپی دیسک بارگذاری
    می‌شد و به سادگی منتظر یک فرمان دیگر از صفحه‌کلید می‌ماند.</p>
<p>BIOS: نرم‌افزار، فقط نه به نرمی</p>
<p>همان‌طور که سیستم‌های کامپیوتری ما سریع‌تر و حافظه ارزان‌تر شد،
    سیستم‌عامل‌های ما درست در کنار پردازشگرهای کلمه و صفحه‌گسترده‌هایمان بهبود
    یافتند. هنگامی که IBM PC در سال 1981 ظاهر شد، PC DOS تقریباً یک شبه
    جایگزین CP/M شد. فضای حافظه بسیار بزرگ‌تر PC (16 برابر CP/M) بسیاری از
    چیزها را ممکن و بیشتر چیزها را سریع‌تر کرد. DOS می‌توانست کارهای بیشتری
    نسبت به CP/M انجام دهد. این ممکن بود زیرا DOS کمک داشت.</p>
<p>IBM کد برنامه‌ای که صفحه‌کلید، نمایشگر، پورت‌های سریال و درایوهای دیسک
    را مدیریت می‌کرد گرفته و آن را در یک نوع خاص از تراشه حافظه به نام حافظه
    فقط خواندنی (ROM) رایت کرده بود. حافظه دسترسی تصادفی معمولی زمانی که برق
    آن خاموش می‌شود پاک می‌شود. ROM داده‌های خود را حفظ می‌کند، خواه برق داشته
    باشد یا نه. نرم‌افزار روی ROM به نام سیستم ورودی/خروجی پایه (BIOS) نامیده
    می‌شد زیرا ورودی‌ها (مانند صفحه‌کلید) و خروجی‌های کامپیوتر (مانند نمایشگر و
    چاپگر) را مدیریت می‌کرد.</p>
<p>برای کاملاً منصف بودن به CP/M، باید گفت که آن نیز یک BIOS داشت، اما
    دامنه آن بسیار محدودتر از BIOS DOS بود و باید با سیستم‌عامل به حافظه
    بارگذاری می‌شد. در یک معنا، BIOS CP/M بخشی از سیستم‌عامل بود، در حالی که
    BIOS DOS بخشی از خود کامپیوتر بود.</p>
<p>در جایی در طول مسیر، نرم‌افزاری مانند BIOS که روی تراشه‌های ROM “غیر
    فرار” وجود داشت، میان‌افزار نامیده شد زیرا در حالی که هنوز نرم‌افزار بود،
    به نرمی نرم‌افزاری که در حافظه ذخیره می‌شد نبود. تمام کامپیوترهای مدرن یک
    BIOS میان‌افزار دارند، اگرچه نرم‌افزار BIOS اکنون کارهای متفاوتی نسبت به
    سال 1981 انجام می‌دهد.</p>
<p>جادوی چندوظیفه‌ای</p>
<p>PC DOS دوره طولانی‌ای داشت. نسخه‌های اول ویندوز واقعاً سیستم‌عامل‌های
    جدیدی نبودند، بلکه به سادگی مدیران فایل و پرتاب‌کننده‌های برنامه‌ای بودند
    که در حالت گرافیکی روی صفحه نمایش داده می‌شدند. پایین در زیرزمین زیر
    آیکون‌ها، DOS هنوز آنجا بود و همان کاری را می‌کرد که همیشه انجام
    می‌داد.</p>
<p>تا سال 1995 نبود که چیزها به‌طور رادیکال تغییر کردند. در آن سال،
    مایکروسافت ویندوز 95 را منتشر کرد که نه تنها یک رابط کاربری گرافیکی جدید
    داشت، بلکه چیزی بسیار رادیکال‌تر در زیرزمین داشت. ویندوز 95 در حالت
    محافظت‌شده 32 بیتی عمل می‌کرد و برای اجرا حداقل به یک CPU کلاس 80386 نیاز
    داشت. (در فصل 4 توضیح خواهم داد که “حالت محافظت‌شده” به چه معناست.) در
    حال حاضر، حالت محافظت‌شده را به‌عنوان اجازه دادن به سیستم‌عامل برای قطعاً
    رئیس بودن در نظر بگیرید و دیگر صرفاً هم‌رتبه پردازشگرهای کلمه و
    صفحه‌گسترده‌ها نباشد. ویندوز 95 از حالت محافظت‌شده به‌طور کامل استفاده نکرد
    زیرا هنوز با DOS و برنامه‌های DOS سروکار داشت، و چنین نرم‌افزارهای “ارثی”
    مدت‌ها قبل از اینکه حالت محافظت‌شده یک گزینه باشد نوشته شده بودند. با این
    حال، ویندوز 95 چیزی داشت که قبلاً در دنیای کامپیوتر شخصی کم‌هزینه دیده
    نشده بود: چندوظیفه‌ای پیشگیرانه.</p>
<p>حافظه تا سال 1995 آنقدر ارزان شده بود که ممکن بود نه فقط یکی یا دو،
    بلکه چندین برنامه در حافظه همزمان مقیم باشند. در یک همکاری پیچیده با
    CPU، ویندوز 95 توهم قانع‌کننده‌ای ایجاد کرد که همه برنامه‌های در حافظه
    به‌طور همزمان در حال اجرا هستند. این کار با دادن یک “بخش” کوتاه از زمان
    CPU به هر برنامه بارگذاری‌شده در حافظه انجام می‌شد. یک برنامه شروع به اجرا
    بر روی CPU می‌کرد و تعدادی از دستورالعمل‌های ماشینی آن اجرا می‌شد. با این
    حال، پس از یک دوره زمانی معین (معمولاً کسری کوچک از ثانیه)، ویندوز 95 آن
    برنامه اول را “پیشگیرانه” متوقف می‌کرد و کنترل CPU را به برنامه دوم در
    لیست می‌داد. آن برنامه برای چند میلی‌ثانیه دستورالعمل‌ها را اجرا می‌کرد تا
    اینکه آن هم پیشگیرانه متوقف می‌شد. ویندوز 95 لیست را پایین می‌رفت، به هر
    برنامه اجازه می‌داد برای مدت کوتاهی اجرا شود. هنگامی که به پایین لیست
    می‌رسید، دوباره از بالا شروع می‌کرد و به اجرای لیست ادامه می‌داد، به‌صورت
    دورانی، به هر برنامه اجازه می‌داد برای مدت کوتاهی اجرا شود. CPUهای 32
    بیتی آن دوره به اندازه کافی سریع بودند که کاربری که در مقابل نمایشگر
    نشسته بود فکر می‌کرد همه برنامه‌ها به‌طور همزمان در حال اجرا هستند.</p>
<p>استعاره در شکل 3.5 ممکن است این را روشن‌تر کند. یک سوئیچ چرخشی را تصور
    کنید که در آن یک روتور به‌طور مداوم می‌چرخد و به ترتیب به هر یک از چندین
    تماس متصل می‌شود، یک بار در هر چرخش. هر بار که به تماس یکی از برنامه‌ها
    می‌رسد، به آن برنامه اجازه داده می‌شود اجرا شود. وقتی روتور به تماس بعدی
    حرکت می‌کند، برنامه قبلی در مسیر خود متوقف می‌شود و برنامه بعدی کمی زمان
    برای اجرا می‌گیرد.</p>
<p>[تصویر مفهوم چندوظیفه‌ای.]</p>
<p>شکل 3.5: مفهوم چندوظیفه‌ای</p>
<p>سیستم‌عامل می‌تواند اولویتی برای هر برنامه در لیست تعریف کند تا برخی
    زمان بیشتری برای اجرا بگیرند و برخی کمتر. وظایف با اولویت بالا سیکل‌های
    کلاک بیشتری برای اجرا می‌گیرند، در حالی که وظایف با اولویت پایین‌تر کمتر
    می‌گیرند.</p>
<p>ارتقاء به هسته</p>
<p>بسیار در مورد توانایی چندوظیفه‌ای ویندوز 95 گفته شد، اما در سال 1995
    تعداد کمی از مردم در مورد سیستم‌عامل شبیه یونیکس به نام لینوکس شنیده
    بودند که یک جوان فنلاندی به نام لینوس توروالدز تقریباً به‌عنوان یک شوخی آن
    را نوشته و در سال 1991 منتشر کرده بود.</p>
<p>اولین نسخه لینوکس در حالت متنی اجرا می‌شد و رابط کاربری گرافیکی
    پیچیده‌ای که ویندوز 95 داشت را نداشت، اما می‌توانست چندوظیفه‌ای را مدیریت
    کند و ساختار داخلی بسیار قدرتمندتری داشت. هسته لینوکس یک بلوک کد بود که
    به‌طور کامل از حالت محافظت‌شده IA-32 استفاده می‌کرد. هسته لینوکس کاملاً از
    رابط کاربری جدا بود و از آسیب ناشی از برنامه‌های خراب در جای دیگری در
    سیستم محافظت می‌شد. حافظه سیستم به‌عنوان فضای هسته یا فضای کاربر
    علامت‌گذاری شده بود و هیچ چیزی که در فضای کاربر اجرا می‌شد نمی‌توانست به
    چیزی که در فضای هسته ذخیره شده بود بنویسد (و عموماً نمی‌توانست بخواند).
    ارتباط بین فضای هسته و فضای کاربر از طریق فراخوانی‌های سیستمی که به‌طور
    دقیق کنترل می‌شدند انجام می‌شد. (بیشتر در مورد این در ادامه کتاب.)</p>
<p>دسترسی مستقیم به سخت‌افزار فیزیکی، از جمله حافظه، ویدئو و دستگاه‌های
    جانبی، به نرم‌افزار در حال اجرا در فضای هسته محدود شده بود. برنامه‌هایی که
    می‌خواستند از دستگاه‌های جانبی سیستم استفاده کنند، فقط از طریق درایورهای
    دستگاه در حالت هسته می‌توانستند به آن‌ها دسترسی پیدا کنند.</p>
<p>مایکروسافت سیستم‌عامل الهام‌گرفته از یونیکس خود را در سال 1993 منتشر
    کرد. ویندوز NT ساختار داخلی بسیار شبیه به لینوکس داشت، با هسته و
    درایورهای دستگاه که در فضای هسته اجرا می‌شدند و همه چیز دیگر در فضای
    کاربر اجرا می‌شد. این طراحی اساسی هنوز هم برای هر دو لینوکس و جانشینان
    ویندوز NT از ویندوز 2000 تا ویندوز 11 امروزی استفاده می‌شود. طراحی کلی
    برای سیستم‌عامل‌های واقعی حالت محافظت‌شده به‌طور شماتیک در شکل 3.6 نشان داده
    شده است.</p>
<p>انفجار هسته‌ها</p>
<p>در اوایل دهه 2000، کامپیوترهای رومیزی با دو سوکت CPU شروع به فروش
    کردند. ویندوز 2000/XP/Vista و لینوکس هر دو از استفاده از چندین تراشه CPU
    در یک سیستم از طریق مکانیزمی به نام چندپردازشی متقارن (SMP) پشتیبانی
    می‌کردند. چندپردازشی زمانی “متقارن” است که همه پردازنده‌ها یکسان باشند. در
    بیشتر موارد، هنگامی که دو CPU در دسترس هستند، سیستم‌عامل کد خود را در یک
    CPU اجرا می‌کند و برنامه‌های حالت کاربر در دیگری اجرا می‌شوند.</p>
<p>با بهبود فناوری، اینتل و AMD توانستند دو واحد اجرای کد یکسان اما
    کاملاً مستقل را روی یک تراشه قرار دهند. نتیجه اولین CPUهای دو هسته‌ای بود،
    AMD Athlon 64 X2 (2005) و Intel Core 2 Duo (2006). CPUهای چهار هسته‌ای در
    سال 2007 به‌طور معمول در دسترس قرار گرفتند. CPUهای هشت هسته‌ای در سال 2014
    با ریزمعماری Haswell وارد شدند. در سال 2016، i7-6950X با 10 هسته و
    ریزمعماری جدید Broadwell وارد صنعت شد.</p>
<p>[تصویر یک سیستم‌عامل حالت محافظت‌شده بالغ.]</p>
<p>شکل 3.6: یک سیستم‌عامل حالت محافظت‌شده بالغ</p>
<p>مهم است به خاطر داشته باشید که عملکرد همه درباره هسته‌ها نیست، بلکه
    درباره توان عملیاتی پردازنده و تا حدودی حافظه پنهان است. (بیشتر در مورد
    حافظه پنهان بعداً.) در زمان نوشتن این مطلب (2023) بیشتر دسکتاپ‌های تجاری
    دارای چهار یا هشت هسته هستند. این برای پردازشگرهای کلمه، صفحه‌گسترده‌ها و
    مرورگرهای وب معمولی بیش از حد کافی است.</p>
<p>آنچه تعداد زیادی از هسته‌ها را ممکن می‌کند، عمدتاً پردازش بسیاری از
    چیزهای نسبتاً ساده به‌صورت موازی است. در یک مزرعه سرور اینترنت، بسیاری از
    ماشین‌های سرور هر کدام با تعداد زیادی هسته در حال ارائه سرسختانه صفحات وب
    به انبوهی از کاربران اینترنت هستند. ارائه یک صفحه وب از نظر محاسباتی
    فشرده نیست. سرور درخواست را دریافت می‌کند، سند HTML و اجزای آن را پیدا
    می‌کند و آن‌ها را از طریق پورتی که درخواست از آن آمده بود ارسال می‌کند. این
    یک تخصص محاسباتی است و اینتل و AMD اکنون در حال طراحی CPUهای چند هسته‌ای
    تخصصی برای خدمت به آن بازار هستند.</p>
<p>و آه، هسته‌ها. اینتل یک CPU 56 هسته‌ای را در سال 2022 عرضه کرد. هر هسته
    می‌تواند دو ترد را اجرا کند، برای مجموع 112 ترد. تراشه AMD Epyc Milan
    7763 یک سال زودتر عرضه شد و دارای 64 هسته است که قادر به اجرای مجموع 128
    ترد است.</p>
<p>یکی روی میزتان می‌خواهید؟ فقط برای شما… 7,900 دلار. برای تراشه. اما
    مگر اینکه نیاز به اجرای 128 چیز به‌طور موازی با سرعت بالا داشته باشید،
    برای شما فایده‌ای نخواهد داشت. این‌ها تراشه‌های مرکز داده هستند.</p>
<p>آن ماشین‌آلات ریزمعماری در زیرزمین با گذشت زمان تغییر و تکامل می‌یابند.
    سیستم‌های چهار هسته‌ای از سال 2007 وجود داشته‌اند، اما یک سیستم چهار هسته‌ای
    در سال 2022 بسیار سریع‌تر و کارآمدتر از سیستم‌های چهار هسته‌ای اولیه
    است.</p>
<p>طرح</p>
<p>من می‌توانم همه این‌ها را با قرض گرفتن یکی از قدرتمندترین استعاره‌های
    مربوط به محاسبات که تاکنون بیان شده است، خلاصه کنم: کامپیوتر جعبه‌ای است
    که از یک طرح پیروی می‌کند. این‌ها کلمات تد نلسون، نویسنده کتاب شگفت‌انگیز
    Computer Lib/Dream Machines (1974) و یکی از آن افراد بسیار نادری است که
    عادت خسته‌کننده‌ای به تقریباً همیشه درست بودن دارند.</p>
<p>شما طرح را می‌نویسید. کامپیوتر آن را با انتقال دستورالعمل‌ها، بایت به
    بایت، به CPU دنبال می‌کند. در پایین آن، این فرایند یک واکنش زنجیره‌ای
    الکتریکی به‌شدت پیچیده است که شامل صدها هزار سوئیچ متشکل از صدها هزار،
    میلیون‌ها یا حتی میلیاردها ترانزیستور است. با این حال، آن بخش از آن از
    شما پنهان است تا مجبور نباشید نگران آن باشید. هنگامی که به آن کوه
    ترانزیستورها بگویید چه کاری انجام دهند، آن‌ها می‌دانند چگونه آن را انجام
    دهند.</p>
<p>این طرح، این فهرست دستورالعمل‌های ماشینی در حافظه، برنامه زبان اسمبلی
    شماست. نقطه ثانویه این کتاب این است که به شما آموزش دهد چگونه
    دستورالعمل‌های ماشینی را به‌درستی در حافظه برای استفاده CPU ترتیب دهید.
    نقطه اصلی این کتاب این است که به شما آموزش دهد تا درک کنید که چگونه
    ماشین برنامه‌های شما را دنبال می‌کند تا کاری را که به آن نیاز دارید انجام
    دهد.</p>
<p>با اندکی شانس، تا کنون شما درک مفهومی معقولی از اینکه کامپیوترها چه
    هستند و چه می‌کنند دارید. زمان آن رسیده است که به‌طور دقیق‌تری به ماهیت
    عملیات‌هایی که دستورالعمل‌های ماشینی CPU را برای انجام آن‌ها هدایت می‌کنند
    نگاه کنیم. برای اکثر موارد، مانند همه چیز در محاسبات، این درباره حافظه
    است، هم حافظه معمولی روی مادربورد و هم آن امپراتوران یادآوری، رجیسترهای
    CPU.</p>

</body>
</html>