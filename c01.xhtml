<p>فصل ۱: همه چیز در طرح است: درک آنچه کامپیوترها واقعاً انجام می‌دهند</p>
<p><strong>یک شنبه‌ی دلپذیر دیگر در دره‌ی خوشایند</strong></p>
<p>“مایک، سریع باش، خواهرت و برادرت را بیدار کن؛ ساعت از ۷ گذشته است.
نیکی ساعت ۹ لیگ کوچک دارد و دیونه ساعت ۱۰ باله. به مکس قرص کرم قلبش را
بده! (مامان، یادتان هست که تمام شده‌اند؟) پدرت یک آخر هفته‌ی عالی برای
ماهیگیری انتخاب کرده… اینجا، بذار ۱۰ دلار بهت بدم و برو از دامپزشک
قرص‌های بیشتری بگیر… خدای من، درسته، هنک پول بنزین می‌خواست و من را بی‌پول
گذاشت. یک دستگاه خودپرداز نزدیک کی‌مارت هست، و اگر آنجا بروم، می‌توانم آن
صندلی توالت احمقانه را برگردانم و درستش را بگیرم.</p>
<p>“فکر کنم بهتره یک لیست تهیه کنم…”</p>
<p>این یک شنبه‌ی دلپذیر دیگر در دره‌ی خوشایند است، و حدود ۳۰ میلیون
خانه‌دار حومه‌شهر با یک مداد و دفترچه در میز آشپزخانه می‌نشینند تا سعی کنند
از صبحی که هر موجود ضعیف‌تری را می‌کشد و ترشی می‌اندازد، سر در بیاورند. در
ذهنش به وابستگی‌ها فکر می‌کند و مسیر را ترسیم می‌کند:</p>
<p>“نیکی را در پارک رند پیاده کن، برگرد به دمپستر، و حدود ۱۰ دقیقه تا
مرکز خرید گلف میل است. بنزین دارم؟ بهتره اول چک کنم—اگر نه، در دلز شل
توقف کن وگرنه به خیابان میلواکی نمی‌رسم. از دستگاه خودپرداز در گلف میل
پول بگیر؛ سپس از پارکینگ عبور کن به کی‌مارت تا صندلی توالتی که هنک آخر
هفته‌ی پیش بدون چک کردن شکلش خرید را برگردانم. باید یادم باشه که صندلی
توالت را پشت ون بندازم—این را بالای لیست بنویسم.</p>
<p>“تا اون موقع نیم ساعت گذشته، شاید بیشتر. باله تمام مسیر پایین گرینوود
در پارک ریج است. گردش به چپ از میلواکی نیست—اما مسیر مخفی پشت مرکز خرید
هست. باید یادم باشه که مثل همیشه به سمت راست به میلواکی نپیچم—این را
یادداشت کنم. وقتی در پارک ریج هستم، می‌توانم چک کنم ببینم عینک‌های جدید
هنک آماده است یا نه—باید تماس بگیرم، اما تا ساعت ۹:۳۰ باز نمی‌کنند. اوه،
و خرید—می‌توانم وقتی دیونه می‌رقصد انجام دهم. در راه برگشت می‌توانم به
اوکتون بروم و قرص‌های سگ را بگیرم.”</p>
<p>در حدود ۹۰ ثانیه لیست کامل می‌شود:</p>
<ul>
<li>صندلی توالت را داخل ون بینداز.</li>
<li>بنزین را چک کن—اگر خالی بود، در دلز شل توقف کن.</li>
<li>نیکی را در پارک رند پیاده کن.</li>
<li>در دستگاه خودپرداز گلف میل توقف کن.</li>
<li>صندلی توالت را در کی‌مارت برگردان.</li>
<li>دیونه را در باله پیاده کن (مسیر مخفی به گرینوود را به یاد داشته
باش).</li>
<li>ببین عینک‌های هنک در پرل ویژن هستند یا نه—اگر هستند، مطمئن شو که پوشش
ضد خش اضافی را به خاطر داشته باشند.</li>
<li>از جول خرید کن.</li>
<li>دیونه را بردار.</li>
<li>در دامپزشک برای قرص‌های کرم قلب توقف کن.</li>
<li>خریدها را در خانه بگذار.</li>
<li>اگر وقتش است، نیکی را بردار. اگر نه، چند دقیقه استراحت کن؛ سپس نیکی
را بردار.</li>
<li>استراحت کن!</li>
</ul>
<p>آنچه ما اغلب یک “لیست لباسشویی” می‌نامیم (چه شامل لباسشویی باشد یا نه)
استعاره‌ی کاملی برای یک برنامه‌ی کامپیوتری است. بدون اینکه متوجه شود،
خانه‌دار جسور ما برای خودش یک برنامه‌ی کامپیوتری نوشته و سپس (با خودش به
عنوان کامپیوتر) آن را اجرا می‌کند تا قبل از ظهر تمام شود.</p>
<p>برنامه‌نویسی کامپیوتر چیزی جز این نیست: شما برنامه‌نویس یک لیست از
مراحل و آزمون‌ها می‌نویسید. سپس کامپیوتر هر مرحله و آزمون را به ترتیب
انجام می‌دهد. وقتی لیست مراحل اجرا شد، کامپیوتر متوقف می‌شود.</p>
<p>یک برنامه‌ی کامپیوتری لیستی از مراحل و آزمون‌ها است، نه چیزی بیشتر.</p>
<p><strong>مراحل و آزمون‌ها</strong></p>
<p>لحظه‌ای به آنچه من در لیست لباسشویی قبلی یک آزمون می‌نامم فکر کنید. یک
آزمون نوعی تصمیم دوگانه است که ما ده‌ها یا صدها بار حتی در آرام‌ترین روزها
می‌گیریم، گاهی تقریباً بدون فکر کردن به آن.</p>
<p>خانه‌دار ما وقتی به ماجراجویی‌اش شروع کرد، یک آزمون انجام داد. او به
نشانگر بنزین نگاه کرد. نشانگر بنزین به او یکی از دو چیز را می‌گوید: (۱)
او به اندازه‌ی کافی بنزین دارد، یا (۲) ندارد. اگر به اندازه‌ی کافی بنزین
دارد، به راست می‌پیچد و به سمت پارک رند می‌رود. اگر بنزین کافی ندارد، به
چپ به سمت گوشه می‌رود و در دلز شل باک را پر می‌کند. (دل کارت اعتباری قبول
می‌کند.) سپس، با باک پر، برنامه را با یک گردش یو و حرکت به سمت پارک رند
ادامه می‌دهد.</p>
<p>به طور انتزاعی، یک آزمون از این دو بخش تشکیل شده است:</p>
<ul>
<li>اول، به چیزی نگاه می‌کنید که می‌تواند یکی از دو حالت را داشته
باشد.</li>
<li>سپس یکی از دو کار را انجام می‌دهید، بسته به آنچه دیدید.</li>
</ul>
<p>در انتهای برنامه، خانه‌دار ما به خانه رسید، خریدها را از ون بیرون آورد
و به ساعت نگاه کرد. اگر زمان برداشتن نیکی از لیگ کوچک نیست، او لحظه‌ای
برای استراحت روی کاناپه در یک خانه‌ی تقریباً خالی دارد. اگر زمان برداشتن
نیکی است، هیچ استراحتی برای خسته‌ها نیست: او به سمت ون می‌دود و به پارک
رند برمی‌گردد.</p>
<p>(حدسی دارید که آیا واقعاً وقتی برنامه تمام می‌شود، استراحت می‌کند یا
نه؟)</p>
<p><strong>بیش از دو راه؟</strong></p>
<p>ممکن است اعتراض کنید و بگویید که بسیاری یا بیشتر آزمون‌ها بیش از دو
انتخاب دارند. متأسفم، اشتباه می‌کنید—در هر مورد. این را دوبار بخوانید: به
جز رفتار کاملاً تکانشی یا روان‌پریشانه، هر تصمیم انسانی به انتخاب بین دو
گزینه برمی‌گردد.</p>
<p>باید کمی دقیق‌تر نگاه کنید که وقتی تصمیم می‌گیرید، در ذهنتان چه می‌گذرد.
دفعه‌ی بعد که به چای ناو برای غذای سریع چینی می‌روید، خودتان را هنگام مرور
منو مشاهده کنید. انتخاب ممکن است در ابتدا به نظر برسد که انتخاب یک مورد
از بین ۲۶ غذای اصلی کانتونی است. اینطور نیست—در واقع انتخاب بین انتخاب
یک مورد و انتخاب نکردن آن مورد است. چشمانتان روی مرغ با بادام هندی
می‌افتد. نه، خیلی بی‌مزه است. آن یک آزمون بود. به مورد بعدی می‌روید. مرغ با
قارچ سیاه. هوم، نه، هفته‌ی پیش آن را خوردم. آن یک آزمون دیگر بود. مورد
بعدی: مرغ کنگ پائو. بله، همین است! آن یک آزمون سوم بود.</p>
<p>انتخاب بین مرغ با بادام هندی، مرغ با قارچ سیاه، و مرغ کنگ پائو نبود.
هر غذا لحظه‌ای در مقابل چشم انتقادی ذهنتان قرار گرفت، و شما به طور فردی
آن را پذیرفتید یا رد کردید. در نهایت، یک غذا برنده شد، اما در همان بازی
“خوردن یا نخوردن” برنده شد.</p>
<p>بگذارید مثال دیگری به شما بدهم. بسیاری از پیچیده‌ترین تصمیمات زندگی به
این دلیل پیش می‌آیند که ۹۹٫۹۹۸۶۷ درصد از ما برهنه‌گرا نیستیم. شما آنجا
بوده‌اید: در کمد لباس‌هایتان با لباس زیر ایستاده‌اید و بین شلوارها ورق
می‌زنید. آزمون‌ها سریع و پیوسته می‌آیند. این یکی؟ نه. آن یکی؟ نه. این یکی؟
بله. یک جفت شلوار آبی انتخاب می‌کنید، بگوییم. (بعد از همه، دوشنبه است، و
آبی به نظر رنگ مناسبی می‌رسد.) سپس به سمت کشوی جوراب‌هایتان می‌روید و نگاهی
می‌اندازید. اوه، جوراب آبی ندارید. آن یک آزمون بود. بنابراین به کمد لباس
برمی‌گردید، شلوار آبی را دوباره روی رخت‌آویز می‌گذارید و دوباره شروع
می‌کنید. این یکی؟ نه. آن یکی؟ نه. این یکی؟ بله. این بار شلوار قهوه‌ای است،
و آن را روی بازویتان می‌اندازید و به سمت کشوی جوراب‌ها برای نگاه دیگری
می‌روید. نه، جوراب قهوه‌ای هم تمام شده است. پس دوباره به کمد لباس
برمی‌گردید….</p>
<p>آنچه ممکن است یک تصمیم واحد در نظر بگیرید، یا شاید دو تصمیم که به طور
جدایی‌ناپذیری در هم تنیده‌اند (مثل انتخاب شلوار و جوراب هم‌رنگ، با توجه به
موجودی)، در واقع یک سری تصمیمات کوچک است، همیشه دوگانه: انتخاب کن یا
انتخاب نکن. پیدا کن یا پیدا نکن. ماجرای صبح دوشنبه در کمد لباس یک تشبیه
خوب از ساختار برنامه‌نویسی به نام حلقه است: شما یک سری کارها را انجام
می‌دهید تا درست انجام شود، سپس متوقف می‌شوید (فرض کنید از آن دسته افراد
نیستید که با شلوار قهوه‌ای و جوراب آبی بیرون می‌روید). اما اینکه آیا همه
چیز درست می‌شود همیشه به یک دنباله از تصمیمات ساده‌ی یا این یا آن
برمی‌گردد.</p>
<p><strong>کامپیوترها مثل ما فکر می‌کنند</strong></p>
<p>می‌توانم تقریباً بشنوم که چه فکر می‌کنید: “مطمئناً، این یک کتاب کامپیوتری
است، و او سعی دارد من را وادار کند که مثل کامپیوتر فکر کنم.” اصلاً اینطور
نیست. کامپیوترها مثل ما فکر می‌کنند. ما آن‌ها را طراحی کردیم؛ چطور
می‌توانستند طور دیگری فکر کنند؟ نه، آنچه سعی دارم انجام دهم این است که
شما را وادار کنم نگاهی طولانی و سخت به نحوه‌ی تفکرتان بیندازید. ما در
زندگی‌مان روی حالت خودکار کار می‌کنیم تا حدی که بیشتر تفکراتمان را بدون
واقعاً فکر کردن انجام می‌دهیم.</p>
<p>بهترین مدل برای منطق یک برنامه‌ی کامپیوتری همان منطقی است که ما برای
برنامه‌ریزی و مدیریت امور روزمره‌مان استفاده می‌کنیم. مهم نیست چه کاری
انجام می‌دهیم، به انتخاب بین دو گزینه و انتخاب یکی برمی‌گردد. آنچه ممکن
است به عنوان یک تصمیم بزرگ و پیچیده در نظر بگیریم، چیزی جز یک درهم‌تنیدگی
نامرتب از بسیاری تصمیمات کوچکتر نیست. مهارت نگاه کردن به یک تصمیم پیچیده
و دیدن همه‌ی تصمیمات کوچکش به شما در یادگیری برنامه‌نویسی کمک زیادی خواهد
کرد. دفعه‌ی بعد که باید چیزی را تصمیم بگیرید، خودتان را مشاهده کنید.
تصمیمات کوچکی که تصمیم بزرگ را تشکیل می‌دهند بشمارید. شگفت‌زده خواهید
شد.</p>
<p>و، شگفتی! شما یک برنامه‌نویس خواهید شد.</p>
<p><strong>اگر این چیز واقعی بود…</strong></p>
<p>نگران نباشید. آنچه تجربه کردید یک استعاره بود. چیز واقعی نبود. (چیز
واقعی بعداً می‌آید.)</p>
<p>من در این کتاب زیاد از استعاره‌ها استفاده می‌کنم. استعاره یک مقایسه‌ی
آزاد بین چیزی آشنا (مثل لیست لباسشویی شنبه صبح) و چیزی ناآشنا (مثل یک
برنامه‌ی کامپیوتری) است. ایده این است که ناآشنا را به عباراتی از آشنا
لنگر کنیم تا وقتی شروع به ارائه‌ی حقایق می‌کنم، جایی راحت برای قرار
دادنشان داشته باشید.</p>
<p>مهم‌ترین کاری که الان باید انجام دهید این است که ذهنی باز داشته باشید.
اگر کمی درباره‌ی کامپیوترها یا برنامه‌نویسی می‌دانید، گیر ندهید. بله،
تفاوت‌های مهمی بین یک خانه‌دار که یک لیست لباسشویی دست‌نویس را دنبال می‌کند
و یک کامپیوتر که یک برنامه را اجرا می‌کند وجود دارد. در زمان مناسب به آن
تفاوت‌ها اشاره خواهم کرد.</p>
<p>فعلاً، هنوز فصل ۱ است. این استعاره‌های اولیه را با شرایط خودشان
بپذیرید. بعداً، کمک زیادی خواهند کرد.</p>
<p><strong>برنامه‌نویسی زبان اسمبلی مانند یک رقص مربع</strong></p>
<p>من و کارول علاقه‌ی خاصی به رقص‌های “با فراخوانی” داریم، که رایج‌ترین نوع
آن رقص مربع است. انواع دیگری هم وجود دارد، مثل رقص‌های کنترا نیو انگلند،
که خیلی شبیه رقص مربع هستند اما با موسیقی بهتر. در یک رقص با فراخوانی،
فراخوان در جلوی سالن حرکاتی را اعلام می‌کند، و رقصنده‌ها آن حرکات را انجام
می‌دهند. موسیقی یک ضرب فراهم می‌کند، مانند تیک تیک یک ساعت. دنباله‌ی حرکات
در مجموع رقص است، و رقص معمولاً یک نام دارد.</p>
<p>اولین باری که من و کارول در یک رقص کنترا شرکت کردیم، شگفت‌زده شدم: این
مثل برنامه‌نویسی زبان اسمبلی بود! فراخوان “آلمان چپ” را صدا می‌زند، و ما
حرکت معروف به “آلمان چپ” را انجام می‌دهیم. فراخوان “جلو و عقب” را صدا
می‌زند، و ما حرکت “جلو و عقب” را اجرا می‌کنیم. فراخوان “بوکس گنات” را صدا
می‌زند، و خوب، ما گنات را بوکس می‌کنیم. (من این را نمی‌سازم!) تعداد معقولی
حرکت وجود دارد، و برای خوب بودن در آن نوع رقص، باید همه‌ی آن‌ها را با نام
حفظ کنید. در غیر این صورت، اگر فراخوان حرکتی را صدا کند که نمی‌دانید، رقص
ممکن است تلو تلو بخورد یا متوقف شود. (صفحه‌ی آبی!)</p>
<p>در عمیق‌ترین سطح خود، یک کامپیوتر مجموعه‌ای از عملیات فردی به نام
دستورالعمل‌ها را درک می‌کند. این‌ها محاسبات انجام می‌دهند، منطقی مانند AND و
OR را اجرا می‌کنند، داده‌ها را جابجا می‌کنند، و کارهای زیادی دیگر انجام
می‌دهند. هر دستورالعمل در داخل تراشه‌ی CPU انجام می‌شود. درست مانند
مجموعه‌ای از حرکات رقص که اتم‌های حرکت تشکیل‌دهنده‌ی یک رقص مربع هستند،
دستورالعمل‌ها اتم‌های یک برنامه‌ی کامپیوتری هستند. برنامه مانند رقص به
عنوان یک کل است: دنباله‌ای از دستورالعمل‌ها که به ترتیب اجرا می‌شوند.
زوج‌هایی که در رقص شرکت می‌کنند، رقص/برنامه را اجرا می‌کنند در حالی که
فراخوان از لیست حرکات پایین می‌آید و هر کدام را به نوبت صدا می‌زند.
بنابراین زوج‌ها کامپیوتری هستند که رقص روی آن اجرا می‌شود.</p>
<p>این تقریباً تا جایی است که استعاره‌ی رقص مربع می‌رود. وقتی مهارت زبان
اسمبلی را به دست آوردید، هی، بروید کلاس‌های رقص مربع یا کنترا بگیرید و
ببینید آیا به همان نتیجه‌ای که من رسیدم نمی‌رسید.</p>
<p><strong>برنامه‌نویسی زبان اسمبلی مانند یک بازی تخته‌ای</strong></p>
<p>بازی‌های تخته‌ای وقتی من بچه بودم واقعاً مهم بودند، زمانی که بازی‌های
تخته‌ای واقعاً روی نوعی تخته چاپ می‌شدند. (باشه، مقوا.) مونوپولی یکی بود که
تقریباً همه داشتند. مسیری در اطراف لبه‌ی تخته وجود داشت که به مربع‌هایی
تقسیم شده بود. شما یک مهره‌ی بازی داشتید که بر اساس پرتاب تاس‌ها از مربعی
به مربع دیگر پیش می‌رفت، و وقتی مهره‌تان روی یک مربع می‌افتاد، می‌توانستید
یکی از چند کار را انجام دهید: خرید ملک‌هایی که هنوز خریداری نشده بودند،
پرداخت اجاره به املاکی که توسط بازیکنان دیگر مالکیت داشتند، کشیدن یک
کارت از دسته‌ی شانس، یا—آخ!—رفتن به زندان. شما یک توده پول مونوپولی برای
خرج کردن داشتید، و وقتی بازیکن دیگری باید اجاره پرداخت می‌کرد، بیشتر
می‌گرفتید.</p>
<p>جزئیات بازی مونوپولی در اینجا مهم نیستند. آنچه مهم است این است که شما
از طریق یک سری مراحل پیش می‌روید، و در هر مرحله، چیزی اتفاق می‌افتد. توده‌ی
پول شما رشد می‌کند یا کاهش می‌یابد. زبان اسمبلی کمی شبیه آن است: یک برنامه
مانند تخته‌ی بازی است. هر مرحله در برنامه کاری انجام می‌دهد. مکان‌هایی وجود
دارد که می‌توانید اعداد را ذخیره کنید. اعداد با حرکت در برنامه تغییر
می‌کنند.</p>
<p>حالا که به بازی‌های تخته‌ای فکر می‌کنید، به شکل ۱.۱ نگاه کنید. آنچه من
ترسیم کرده‌ام در واقع تقریباً شبیه زبان اسمبلی است همانطور که در برخی از
کامپیوترهای ساده‌تر ما ۵۰ یا ۶۰ سال پیش استفاده می‌شد. ستون با عنوان
“دستورالعمل‌های برنامه” مسیر اصلی در اطراف لبه‌ی تخته است که فقط بخشی از
آن می‌تواند در اینجا نشان داده شود. این برنامه‌ی کامپیوتری زبان اسمبلی
است، دنباله‌ی واقعی از مراحل و آزمون‌هایی که، وقتی اجرا می‌شود، باعث می‌شود
کامپیوتر کاری مفید انجام دهد. تنظیم این دنباله‌ی دستورالعمل‌های برنامه
چیزی است که برنامه‌نویسی در زبان اسمبلی واقعاً هست.</p>
<p>همه چیزهای دیگر خرده‌ریزهایی در وسط تخته هستند که بازی در حال انجام را
خدمت می‌کنند. بیشتر این‌ها مکان‌های ذخیره‌سازی هستند که داده‌های شما را شامل
می‌شوند. احتمالاً متوجه می‌شوید (شاید با روحیه‌ی پایین) که تعداد زیادی عدد
درگیر هستند. (آن‌ها اعداد عجیبی هم هستند. مثلاً “۰۰۴B” چه معنی می‌دهد؟ من
در فصل ۲، “مبنای بیگانه” با آن مسئله برخورد می‌کنم.) متاسفم، اما این صرفاً
نحوه‌ی بازی است. زبان اسمبلی، در عمیق‌ترین سطح خود، چیزی جز اعداد نیست، و
اگر از اعداد به همان اندازه که اکثر مردم از ماهی کولی متنفرند متنفر
هستید، دوران سختی خواهید داشت. (من ماهی کولی را دوست دارم، که بخشی از
افسانه‌ی من است. یاد بگیرید اعداد را دوست داشته باشید. آن‌ها به شوری
نیستند.) زبان‌های برنامه‌نویسی سطح بالاتر مانند پاسکال یا پایتون اعداد را
با نمادین کردن آن‌ها پنهان می‌کنند. اما زبان اسمبلی، خوب، فقط شما و اعداد
هستید.</p>
<p>باید به شما هشدار دهم که بازی زبان اسمبلی در شکل ۱.۱ هیچ پردازنده‌ی
کامپیوتری واقعی مانند اینتل کور i5 را نشان نمی‌دهد. همچنین، من نام
دستورالعمل‌ها را واضح‌تر از نام دستورالعمل‌ها در زبان اسمبلی اینتل کرده‌ام.
در دنیای واقعی، نام دستورالعمل‌ها معمولاً چیزهای کوتاهی مانند LAHF، STC،
INC، SHRX و دیگر رمزنگاری‌هایی هستند که بدون توضیحات قابل توجهی قابل درک
نیستند. ما داریم به این چیزها به صورت جانبی نزدیک می‌شویم، و در این فصل
باید برخی چیزها را کمی شیرین کنم تا استعاره‌ها را به وضوح ترسیم کنم.</p>
<p><strong>کد و داده</strong></p>
<p>مانند اکثر بازی‌های تخته‌ای، بازی تخته‌ای زبان اسمبلی از دو دسته‌ی گسترده
از عناصر تشکیل شده است: مراحل بازی و مکان‌هایی برای ذخیره کردن چیزها.
“مراحل بازی” همان مراحل و آزمون‌هایی هستند که تمام مدت درباره‌ی آن‌ها صحبت
کرده‌ام. مکان‌هایی برای ذخیره کردن چیزها دقیقاً همین هستند: سوراخ‌هایی که
می‌توانید اعداد را در آن‌ها قرار دهید، با اطمینان از اینکه آن اعداد در
جایی که قرار داده‌اید باقی می‌مانند تا زمانی که آن‌ها را بیرون بیاورید یا
به نحوی تغییر دهید.</p>
<p>در اصطلاح برنامه‌نویسی، مراحل بازی کد نامیده می‌شوند، و اعداد در
سوراخ‌هایشان (به عنوان مجزا از خود سوراخ‌ها) داده نامیده می‌شوند. خود
سوراخ‌ها معمولاً ذخیره‌سازی نامیده می‌شوند. (تفاوت بین مکان‌هایی که اطلاعات
را ذخیره می‌کنید و اطلاعاتی که در آن‌ها ذخیره می‌کنید بسیار مهم است. آن‌ها
را اشتباه نگیرید.) یک دستورالعمل در بازی زبان اسمبلی را در نظر بگیرید که
می‌گوید ADD 32 به A. یک دستورالعمل ADD در کد یک مقدار داده را که در
سوراخی به نام ثبات A ذخیره شده تغییر می‌دهد.</p>
<p>کد و داده دو نوع موجود بسیار متفاوت هستند، اما آن‌ها به روش‌هایی تعامل
می‌کنند که بازی را جالب می‌کند. کد شامل مراحلی است که داده را در ذخیره‌سازی
قرار می‌دهد (دستورالعمل‌های MOVE) و مراحلی که داده‌ای را که قبلاً در
ذخیره‌سازی است تغییر می‌دهد (دستورالعمل‌های INCREMENT و DECREMENT، و
دستورالعمل‌های ADD، در میان دیگران). بیشتر اوقات شما کد را به عنوان استاد
داده در نظر خواهید گرفت، به این معنا که کد مقادیر داده را در ذخیره‌سازی
می‌نویسد. با این حال، داده نیز بر کد تأثیر می‌گذارد. در میان آزمون‌هایی که
کد انجام می‌دهد، آزمون‌هایی هستند که داده در ذخیره‌سازی را بررسی می‌کنند،
دستورالعمل‌های COMPARE. اگر یک مقدار داده‌ی مشخص در ذخیره‌سازی وجود داشته
باشد، کد ممکن است یک کار را انجام دهد؛ اگر آن مقدار در ذخیره‌سازی وجود
نداشته باشد، کد کار دیگری انجام می‌دهد، مانند دستورالعمل‌های JUMP BACK و
JUMP AHEAD.</p>
<p>بلوک کوتاه دستورالعمل‌ها با عنوان PROCEDURE یک انحراف از جریان اصلی
دستورالعمل‌ها است. در هر نقطه‌ای از برنامه می‌توانید به رویه بروید، مراحل و
آزمون‌های آن را انجام دهید، و سپس به همان جایی که ترک کردید برگردید. این
اجازه می‌دهد تا یک دنباله از مراحل و آزمون‌هایی که به طور کلی مفید و مکرراً
استفاده می‌شوند، فقط در یک مکان وجود داشته باشد، به جای اینکه به صورت
نسخه‌های جداگانه در همه جاهایی که نیاز است وجود داشته باشد.</p>
<p><strong>آدرس‌ها</strong></p>
<p>مفهوم مهم دیگر در اعداد عجیب در سمت چپ مکان‌های مرحله‌ی برنامه و
مکان‌های داده قرار دارد. هر عدد منحصر به فرد است، به این معنا که یک مکان
با آن عدد فقط یک بار در داخل کامپیوتر ظاهر می‌شود. این مکان آدرس نامیده
می‌شود. داده با مشخص کردن آدرس داده در ماشین ذخیره و بازیابی می‌شود.
رویه‌ها با مشخص کردن آدرسی که در آن شروع می‌شوند فراخوانی می‌شوند.</p>
<p>جعبه‌ی کوچک (که آن هم یک مکان ذخیره‌سازی است) با عنوان “شمارنده‌ی
برنامه” آدرس دستورالعمل بعدی برای اجرا را نگه می‌دارد. عدد داخل شمارنده‌ی
برنامه هر بار که یک دستورالعمل اجرا می‌شود، یک واحد افزایش می‌یابد (افزایش
می‌یابد) مگر اینکه دستورالعمل به شمارنده‌ی برنامه بگوید کار دیگری انجام
دهد. برای مثال، به دستورالعمل JUMP BACK 9 در آدرس ۰۰۴B توجه کنید. وقتی
این دستورالعمل اجرا می‌شود، شمارنده‌ی برنامه “۹ مکان عقب‌تر” می‌رود. این
مشابه مفهوم “سه خانه به عقب بروید” در بیشتر بازی‌های تخته‌ای است.</p>
<p><strong>بررسی استعاره!</strong></p>
<p>این تقریباً تمام توضیحی است که در مورد بازی زبان اسمبلی در حال حاضر
ارائه خواهم داد. هنوز فصل ۱ است، و ما هنوز در قلمرو استعاره هستیم.
افرادی که کمی با کامپیوترها آشنا هستند، برخی از آنچه شکل ۱.۱ انجام می‌دهد
را تشخیص داده و درک خواهند کرد. افرادی که اصلاً با درون کامپیوتر آشنایی
ندارند نباید احساس کنند که برای کاملاً گم شدن عقب مانده‌اند. من بازی زبان
اسمبلی را صرفاً برای انتقال نکات زیر ایجاد کردم:</p>
<ul>
<li>مراحل فردی بسیار ساده هستند. یک دستورالعمل واحد به ندرت بیش از
جابجایی یک مقدار واحد از یک سوراخ ذخیره‌سازی به دیگری انجام می‌دهد، انجام
محاسبات بسیار ابتدایی مانند جمع یا تفریق، یا مقایسه مقدار موجود در یک
سوراخ ذخیره‌سازی با مقداری موجود در دیگری. این خبر خوبی است، زیرا به شما
اجازه می‌دهد روی کار ساده‌ای که توسط یک دستورالعمل واحد انجام می‌شود تمرکز
کنید بدون اینکه از پیچیدگی غرق شوید. با این حال، خبر بد نکته‌ی بعدی
است.</li>
<li>انجام هر کاری مفید به مراحل زیادی نیاز دارد. شما می‌توانید اغلب یک
برنامه‌ی مفید را در زبان‌هایی مانند پاسکال یا بیسیک در پنج یا شش خط
بنویسید. شما می‌توانید در سیستم‌های برنامه‌نویسی بصری مانند ویژوال بیسیک،
دلفی، یا لازاروس بدون نوشتن هیچ کدی برنامه‌های مفیدی ایجاد کنید. (کد هنوز
وجود دارد… اما کد “کنسرو شده” است و شما واقعاً فقط انتخاب می‌کنید که کدام
تکه‌های کد کنسرو شده در مجموعه‌ی بسیاری از چنین تکه‌هایی اجرا شوند.) یک
برنامه‌ی مفید زبان اسمبلی را نمی‌توان در کمتر از حدود ۵۰ خط پیاده‌سازی کرد،
و هر چیزی چالش‌برانگیز صدها یا هزاران—یا ده‌ها هزار—خط نیاز دارد. مهارت
برنامه‌نویسی زبان اسمبلی در ساختاردهی این صدها یا هزاران دستورالعمل نهفته
است تا برنامه هم به درستی عمل کند و هم توسط برنامه‌نویسان دیگر—و
خودتان—شش ماه بعد قابل خواندن و درک باشد.</li>
<li>کلید زبان اسمبلی در درک آدرس‌های حافظه است. در زبان‌هایی مانند پاسکال
و بیسیک، کامپایلر مراقب مکان یک چیز است—شما فقط باید به آن چیز یک نام
نمادین بدهید و هر زمان که می‌خواهید آن را ببینید یا تغییر دهید، با آن نام
صدا بزنید. در زبان اسمبلی، شما باید همیشه آگاه باشید که چیزها در حافظه‌ی
کامپیوتر یا مجموعه‌ی ثبات‌ها کجا هستند. بنابراین، در کار با این کتاب، توجه
ویژه‌ای به مفهوم آدرس‌دهی حافظه داشته باشید، که چیزی جز هنر مشخص کردن مکان
یک چیز نیست. بازی زبان اسمبلی پر از آدرس‌ها و دستورالعمل‌هایی است که با
آدرس‌ها کار می‌کنند (مانند MOVE data at B to C، که به معنای جابجایی داده‌ی
ذخیره‌شده در آدرس مشخص‌شده توسط ثبات B به ثبات C است). آدرس‌دهی به مراتب
سخت‌ترین بخش زبان اسمبلی است، اما آن را تسلط پیدا کنید و بیشتر کل چیز را
در جیب دارید.</li>
</ul>
<p>هر چیزی که تا کنون گفته‌ام جهت‌گیری بوده است. سعی کرده‌ام یک طعم از
تصویر بزرگ زبان اسمبلی و نحوه‌ی ارتباط اصول بنیادی آن با زندگی که تمام
مدت داشته‌اید را به شما بدهم. زندگی یک دنباله از مراحل و آزمون‌ها است،
همانطور که رقص‌های مربع و بازی‌های تخته‌ای هستند—و زبان اسمبلی نیز همینطور
است. این استعاره‌ها را در ذهن داشته باشید وقتی که به واقعیت نزدیک می‌شویم
و با طبیعت اعداد کامپیوتری روبرو می‌شویم.</p>
